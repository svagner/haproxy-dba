!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
51DEGREES_INC	./Makefile	/^51DEGREES_INC = $(51DEGREES_SRC)$/;"	m
51DEGREES_LIB	./Makefile	/^51DEGREES_LIB = $(51DEGREES_SRC)$/;"	m
51DEGREES_SRC	./Makefile	/^51DEGREES_SRC =$/;"	m
A32	./src/xxhash.c	/^#define A32(/;"	d	file:
A64	./src/xxhash.c	/^#define A64(/;"	d	file:
ABORT_NOW	./include/common/debug.h	/^#define ABORT_NOW(/;"	d
ACCEPT4_USE_SOCKETCALL	./include/common/syscall.h	/^#define ACCEPT4_USE_SOCKETCALL /;"	d
ACCEPT_FIELD	./contrib/halog/halog.c	/^#define ACCEPT_FIELD /;"	d	file:
ACCESS_LVL_ADMIN	./include/types/global.h	/^#define ACCESS_LVL_ADMIN /;"	d
ACCESS_LVL_NONE	./include/types/global.h	/^#define ACCESS_LVL_NONE /;"	d
ACCESS_LVL_OPER	./include/types/global.h	/^#define ACCESS_LVL_OPER /;"	d
ACCESS_LVL_USER	./include/types/global.h	/^#define ACCESS_LVL_USER /;"	d
ACL_COND_IF	./include/types/acl.h	/^	ACL_COND_IF,		\/* positive condition (after 'if') *\/$/;"	e	enum:acl_cond_pol
ACL_COND_NONE	./include/types/acl.h	/^	ACL_COND_NONE,		\/* no polarity set yet *\/$/;"	e	enum:acl_cond_pol
ACL_COND_UNLESS	./include/types/acl.h	/^	ACL_COND_UNLESS,	\/* negative condition (after 'unless') *\/$/;"	e	enum:acl_cond_pol
ACL_TEST_FAIL	./include/types/acl.h	/^	ACL_TEST_FAIL = 0,           \/* test failed *\/$/;"	e	enum:acl_test_res
ACL_TEST_MISS	./include/types/acl.h	/^	ACL_TEST_MISS = 1,           \/* test may pass with more info *\/$/;"	e	enum:acl_test_res
ACL_TEST_PASS	./include/types/acl.h	/^	ACL_TEST_PASS = 3,           \/* test passed *\/$/;"	e	enum:acl_test_res
ACT_ACTION_ALLOW	./include/types/action.h	/^	ACT_ACTION_ALLOW,$/;"	e	enum:act_name
ACT_ACTION_DENY	./include/types/action.h	/^	ACT_ACTION_DENY,$/;"	e	enum:act_name
ACT_ACTION_TRK_SC0	./include/types/action.h	/^	ACT_ACTION_TRK_SC0,$/;"	e	enum:act_name
ACT_ACTION_TRK_SCMAX	./include/types/action.h	/^	ACT_ACTION_TRK_SCMAX = ACT_ACTION_TRK_SC0 + MAX_SESS_STKCTR - 1,$/;"	e	enum:act_name
ACT_ALLOW	./include/common/regex.h	/^#define ACT_ALLOW	/;"	d
ACT_CUSTOM	./include/types/action.h	/^	ACT_CUSTOM = 0,$/;"	e	enum:act_name
ACT_DENY	./include/common/regex.h	/^#define ACT_DENY	/;"	d
ACT_FLAG_FINAL	./include/types/action.h	/^	ACT_FLAG_FINAL = 0x00000001,  \/* last call, cannot yield *\/$/;"	e	enum:act_flag
ACT_FLAG_FIRST	./include/types/action.h	/^	ACT_FLAG_FIRST = 0x00000002,  \/* first call for this action *\/$/;"	e	enum:act_flag
ACT_FLAG_NONE	./include/types/action.h	/^	ACT_FLAG_NONE  = 0x00000000,  \/* no flag *\/$/;"	e	enum:act_flag
ACT_F_HTTP_REQ	./include/types/action.h	/^	ACT_F_HTTP_REQ,    \/* http-request *\/$/;"	e	enum:act_from
ACT_F_HTTP_RES	./include/types/action.h	/^	ACT_F_HTTP_RES,    \/* http-response *\/$/;"	e	enum:act_from
ACT_F_TCP_REQ_CNT	./include/types/action.h	/^	ACT_F_TCP_REQ_CNT, \/* tcp-request content *\/$/;"	e	enum:act_from
ACT_F_TCP_REQ_CON	./include/types/action.h	/^	ACT_F_TCP_REQ_CON, \/* tcp-request connection *\/$/;"	e	enum:act_from
ACT_F_TCP_RES_CNT	./include/types/action.h	/^	ACT_F_TCP_RES_CNT, \/* tcp-response content *\/$/;"	e	enum:act_from
ACT_HTTP_ADD_ACL	./include/types/action.h	/^	ACT_HTTP_ADD_ACL,$/;"	e	enum:act_name
ACT_HTTP_ADD_HDR	./include/types/action.h	/^	ACT_HTTP_ADD_HDR,$/;"	e	enum:act_name
ACT_HTTP_DEL_ACL	./include/types/action.h	/^	ACT_HTTP_DEL_ACL,$/;"	e	enum:act_name
ACT_HTTP_DEL_HDR	./include/types/action.h	/^	ACT_HTTP_DEL_HDR,$/;"	e	enum:act_name
ACT_HTTP_DEL_MAP	./include/types/action.h	/^	ACT_HTTP_DEL_MAP,$/;"	e	enum:act_name
ACT_HTTP_REDIR	./include/types/action.h	/^	ACT_HTTP_REDIR,$/;"	e	enum:act_name
ACT_HTTP_REPLACE_HDR	./include/types/action.h	/^	ACT_HTTP_REPLACE_HDR,$/;"	e	enum:act_name
ACT_HTTP_REPLACE_VAL	./include/types/action.h	/^	ACT_HTTP_REPLACE_VAL,$/;"	e	enum:act_name
ACT_HTTP_REQ_AUTH	./include/types/action.h	/^	ACT_HTTP_REQ_AUTH,$/;"	e	enum:act_name
ACT_HTTP_REQ_SET_SRC	./include/types/action.h	/^	ACT_HTTP_REQ_SET_SRC,$/;"	e	enum:act_name
ACT_HTTP_REQ_TARPIT	./include/types/action.h	/^	ACT_HTTP_REQ_TARPIT,$/;"	e	enum:act_name
ACT_HTTP_SET_HDR	./include/types/action.h	/^	ACT_HTTP_SET_HDR,$/;"	e	enum:act_name
ACT_HTTP_SET_LOGL	./include/types/action.h	/^	ACT_HTTP_SET_LOGL,$/;"	e	enum:act_name
ACT_HTTP_SET_MAP	./include/types/action.h	/^	ACT_HTTP_SET_MAP,$/;"	e	enum:act_name
ACT_HTTP_SET_MARK	./include/types/action.h	/^	ACT_HTTP_SET_MARK,$/;"	e	enum:act_name
ACT_HTTP_SET_NICE	./include/types/action.h	/^	ACT_HTTP_SET_NICE,$/;"	e	enum:act_name
ACT_HTTP_SET_TOS	./include/types/action.h	/^	ACT_HTTP_SET_TOS,$/;"	e	enum:act_name
ACT_PASS	./include/common/regex.h	/^#define ACT_PASS	/;"	d
ACT_REMOVE	./include/common/regex.h	/^#define ACT_REMOVE	/;"	d
ACT_REPLACE	./include/common/regex.h	/^#define ACT_REPLACE	/;"	d
ACT_RET_CONT	./include/types/action.h	/^	ACT_RET_CONT,  \/* continue processing. *\/$/;"	e	enum:act_return
ACT_RET_ERR	./include/types/action.h	/^	ACT_RET_ERR,   \/* processing error. *\/$/;"	e	enum:act_return
ACT_RET_PRS_ERR	./include/types/action.h	/^	ACT_RET_PRS_ERR,   \/* abort processing. *\/$/;"	e	enum:act_parse_ret
ACT_RET_PRS_OK	./include/types/action.h	/^	ACT_RET_PRS_OK,    \/* continue processing. *\/$/;"	e	enum:act_parse_ret
ACT_RET_STOP	./include/types/action.h	/^	ACT_RET_STOP,  \/* stop processing. *\/$/;"	e	enum:act_return
ACT_RET_YIELD	./include/types/action.h	/^	ACT_RET_YIELD, \/* call me again. *\/$/;"	e	enum:act_return
ACT_TARPIT	./include/common/regex.h	/^#define ACT_TARPIT	/;"	d
ACT_TCP_CAPTURE	./include/types/action.h	/^	ACT_TCP_CAPTURE, \/* capture a fetched sample *\/$/;"	e	enum:act_name
ACT_TCP_CLOSE	./include/types/action.h	/^	ACT_TCP_CLOSE, \/* close at the sender's *\/$/;"	e	enum:act_name
ACT_TCP_EXPECT_PX	./include/types/action.h	/^	ACT_TCP_EXPECT_PX,$/;"	e	enum:act_name
ADDINC	./Makefile	/^ADDINC =$/;"	m
ADDLIB	./Makefile	/^ADDLIB =$/;"	m
ALLSPHINXOPTS	./doc/lua-api/Makefile	/^ALLSPHINXOPTS   = -d $(BUILDDIR)\/doctrees $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .$/;"	m
AN_REQ_ALL	./include/types/channel.h	/^#define AN_REQ_ALL /;"	d
AN_REQ_HTTP_BODY	./include/types/channel.h	/^#define AN_REQ_HTTP_BODY /;"	d
AN_REQ_HTTP_INNER	./include/types/channel.h	/^#define AN_REQ_HTTP_INNER /;"	d
AN_REQ_HTTP_PROCESS_BE	./include/types/channel.h	/^#define AN_REQ_HTTP_PROCESS_BE /;"	d
AN_REQ_HTTP_PROCESS_FE	./include/types/channel.h	/^#define AN_REQ_HTTP_PROCESS_FE /;"	d
AN_REQ_HTTP_TARPIT	./include/types/channel.h	/^#define AN_REQ_HTTP_TARPIT /;"	d
AN_REQ_HTTP_XFER_BODY	./include/types/channel.h	/^#define AN_REQ_HTTP_XFER_BODY /;"	d
AN_REQ_INSPECT_BE	./include/types/channel.h	/^#define AN_REQ_INSPECT_BE /;"	d
AN_REQ_INSPECT_FE	./include/types/channel.h	/^#define AN_REQ_INSPECT_FE /;"	d
AN_REQ_PRST_RDP_COOKIE	./include/types/channel.h	/^#define AN_REQ_PRST_RDP_COOKIE /;"	d
AN_REQ_SRV_RULES	./include/types/channel.h	/^#define AN_REQ_SRV_RULES /;"	d
AN_REQ_STICKING_RULES	./include/types/channel.h	/^#define AN_REQ_STICKING_RULES /;"	d
AN_REQ_SWITCHING_RULES	./include/types/channel.h	/^#define AN_REQ_SWITCHING_RULES /;"	d
AN_REQ_WAIT_HTTP	./include/types/channel.h	/^#define AN_REQ_WAIT_HTTP /;"	d
AN_RES_HTTP_PROCESS_BE	./include/types/channel.h	/^#define AN_RES_HTTP_PROCESS_BE /;"	d
AN_RES_HTTP_PROCESS_FE	./include/types/channel.h	/^#define AN_RES_HTTP_PROCESS_FE /;"	d
AN_RES_HTTP_XFER_BODY	./include/types/channel.h	/^#define AN_RES_HTTP_XFER_BODY /;"	d
AN_RES_INSPECT	./include/types/channel.h	/^#define AN_RES_INSPECT /;"	d
AN_RES_STORE_RULES	./include/types/channel.h	/^#define AN_RES_STORE_RULES /;"	d
AN_RES_WAIT_HTTP	./include/types/channel.h	/^#define AN_RES_WAIT_HTTP /;"	d
APPLET_100C	./src/hlua.c	/^#define APPLET_100C /;"	d	file:
APPLET_CHUNKED	./src/hlua.c	/^#define APPLET_CHUNKED /;"	d	file:
APPLET_DONE	./src/hlua.c	/^#define APPLET_DONE /;"	d	file:
APPLET_HDR_SENT	./src/hlua.c	/^#define APPLET_HDR_SENT /;"	d	file:
APPLET_HTTP11	./src/hlua.c	/^#define APPLET_HTTP11 /;"	d	file:
APPLET_LAST_CHK	./src/hlua.c	/^#define APPLET_LAST_CHK /;"	d	file:
ARCH	./Makefile	/^ARCH =$/;"	m
ARCH_FLAGS	./Makefile	/^ARCH_FLAGS        = $(ARCH_FLAGS.$(ARCH))$/;"	m
ARCH_FLAGS.32	./Makefile	/^ARCH_FLAGS.32     = -m32$/;"	m
ARCH_FLAGS.64	./Makefile	/^ARCH_FLAGS.64     = -m64$/;"	m
ARCH_FLAGS.i386	./Makefile	/^ARCH_FLAGS.i386   = -m32 -march=i386$/;"	m
ARCH_FLAGS.i486	./Makefile	/^ARCH_FLAGS.i486   = -m32 -march=i486$/;"	m
ARCH_FLAGS.i586	./Makefile	/^ARCH_FLAGS.i586   = -m32 -march=i586$/;"	m
ARCH_FLAGS.i686	./Makefile	/^ARCH_FLAGS.i686   = -m32 -march=i686$/;"	m
ARCH_FLAGS.x86_64	./Makefile	/^ARCH_FLAGS.x86_64 = -m64 -march=x86-64$/;"	m
ARG1	./include/proto/arg.h	/^#define ARG1(/;"	d
ARG2	./include/proto/arg.h	/^#define ARG2(/;"	d
ARG3	./include/proto/arg.h	/^#define ARG3(/;"	d
ARG4	./include/proto/arg.h	/^#define ARG4(/;"	d
ARG5	./include/proto/arg.h	/^#define ARG5(/;"	d
ARGC_ACL	./include/types/arg.h	/^	ARGC_ACL = 0,  \/* ACL *\/$/;"	e	enum:__anon36
ARGC_CAP	./include/types/arg.h	/^	ARGC_CAP,      \/* capture rule *\/$/;"	e	enum:__anon36
ARGC_HRQ	./include/types/arg.h	/^	ARGC_HRQ,      \/* http-request *\/$/;"	e	enum:__anon36
ARGC_HRS	./include/types/arg.h	/^	ARGC_HRS,      \/* http-response *\/$/;"	e	enum:__anon36
ARGC_LOG	./include/types/arg.h	/^	ARGC_LOG,      \/* log-format *\/$/;"	e	enum:__anon36
ARGC_LOGSD	./include/types/arg.h	/^	ARGC_LOGSD,    \/* log-format-sd *\/$/;"	e	enum:__anon36
ARGC_RDR	./include/types/arg.h	/^	ARGC_RDR,      \/* redirect *\/$/;"	e	enum:__anon36
ARGC_SRV	./include/types/arg.h	/^	ARGC_SRV,      \/* server line *\/$/;"	e	enum:__anon36
ARGC_STK	./include/types/arg.h	/^	ARGC_STK,      \/* sticking rule *\/$/;"	e	enum:__anon36
ARGC_TRK	./include/types/arg.h	/^	ARGC_TRK,      \/* tracking rule *\/$/;"	e	enum:__anon36
ARGC_UIF	./include/types/arg.h	/^	ARGC_UIF,      \/* unique-id-format *\/$/;"	e	enum:__anon36
ARGF_REG_GLOB	./include/types/arg.h	/^#define ARGF_REG_GLOB /;"	d
ARGF_REG_ICASE	./include/types/arg.h	/^#define ARGF_REG_ICASE /;"	d
ARGM	./include/proto/arg.h	/^#define ARGM(/;"	d
ARGM_BITS	./include/types/arg.h	/^#define ARGM_BITS /;"	d
ARGM_MASK	./include/types/arg.h	/^#define ARGM_MASK /;"	d
ARGM_NBARGS	./include/types/arg.h	/^#define ARGM_NBARGS /;"	d
ARGT_BE	./include/types/arg.h	/^	ARGT_BE,       \/* a pointer to a backend only *\/$/;"	e	enum:__anon35
ARGT_BITS	./include/types/arg.h	/^#define ARGT_BITS /;"	d
ARGT_FE	./include/types/arg.h	/^	ARGT_FE,       \/* a pointer to a frontend only *\/$/;"	e	enum:__anon35
ARGT_IPV4	./include/types/arg.h	/^	ARGT_IPV4,     \/* an IPv4 address *\/$/;"	e	enum:__anon35
ARGT_IPV6	./include/types/arg.h	/^	ARGT_IPV6,     \/* an IPv6 address *\/$/;"	e	enum:__anon35
ARGT_MAP	./include/types/arg.h	/^	ARGT_MAP,      \/* a pointer to a map descriptor *\/$/;"	e	enum:__anon35
ARGT_MASK	./include/types/arg.h	/^#define ARGT_MASK /;"	d
ARGT_MSK4	./include/types/arg.h	/^	ARGT_MSK4,     \/* an IPv4 address mask (integer or dotted), stored as ARGT_IPV4 *\/$/;"	e	enum:__anon35
ARGT_MSK6	./include/types/arg.h	/^	ARGT_MSK6,     \/* an IPv6 address mask (integer or dotted), stored as ARGT_IPV4 *\/$/;"	e	enum:__anon35
ARGT_NBTYPES	./include/types/arg.h	/^#define ARGT_NBTYPES /;"	d
ARGT_REG	./include/types/arg.h	/^	ARGT_REG,      \/* a pointer to a regex *\/$/;"	e	enum:__anon35
ARGT_SINT	./include/types/arg.h	/^	ARGT_SINT,     \/* signed 64 bit integer. *\/$/;"	e	enum:__anon35
ARGT_SIZE	./include/types/arg.h	/^	ARGT_SIZE,     \/* a size in bytes by default, stored as ARGT_UINT *\/$/;"	e	enum:__anon35
ARGT_SRV	./include/types/arg.h	/^	ARGT_SRV,      \/* a pointer to a server *\/$/;"	e	enum:__anon35
ARGT_STOP	./include/types/arg.h	/^	ARGT_STOP = 0, \/* end of the arg list *\/$/;"	e	enum:__anon35
ARGT_STR	./include/types/arg.h	/^	ARGT_STR,      \/* string *\/$/;"	e	enum:__anon35
ARGT_TAB	./include/types/arg.h	/^	ARGT_TAB,      \/* a pointer to a stick table *\/$/;"	e	enum:__anon35
ARGT_TIME	./include/types/arg.h	/^	ARGT_TIME,     \/* a delay in ms by default, stored as ARGT_UINT *\/$/;"	e	enum:__anon35
ARGT_USR	./include/types/arg.h	/^	ARGT_USR,      \/* a pointer to a user list *\/$/;"	e	enum:__anon35
ARGT_VAR	./include/types/arg.h	/^	ARGT_VAR,      \/* contains a variable description. *\/$/;"	e	enum:__anon35
ARG_T_DELAY	./include/types/stick_table.h	/^	ARG_T_DELAY,              \/* a delay which supports time units *\/$/;"	e	enum:__anon126
ARG_T_INT	./include/types/stick_table.h	/^	ARG_T_INT,                \/* signed integer *\/$/;"	e	enum:__anon126
ARG_T_NONE	./include/types/stick_table.h	/^	ARG_T_NONE = 0,           \/* data type takes no argument (default) *\/$/;"	e	enum:__anon126
ASSUME_SPLICE_WORKS	./Makefile	/^  ASSUME_SPLICE_WORKS= implicit$/;"	m
AU_O_INSECURE	./include/types/auth.h	/^#define AU_O_INSECURE	/;"	d
Alert	./src/log.c	/^void Alert(const char *fmt, ...)$/;"	f
B64BASE	./src/base64.c	/^#define B64BASE	/;"	d	file:
B64CMAX	./src/base64.c	/^#define B64CMAX	/;"	d	file:
B64CMIN	./src/base64.c	/^#define B64CMIN	/;"	d	file:
B64MAX	./contrib/base64/base64rev-gen.c	/^#define B64MAX	/;"	d	file:
B64PADV	./contrib/base64/base64rev-gen.c	/^#define B64PADV /;"	d	file:
B64PADV	./src/base64.c	/^#define B64PADV	/;"	d	file:
BC_SSL_O_NONE	./include/types/listener.h	/^#define BC_SSL_O_NONE /;"	d
BC_SSL_O_NO_SSLV3	./include/types/listener.h	/^#define BC_SSL_O_NO_SSLV3 /;"	d
BC_SSL_O_NO_TLSV10	./include/types/listener.h	/^#define BC_SSL_O_NO_TLSV10 /;"	d
BC_SSL_O_NO_TLSV11	./include/types/listener.h	/^#define BC_SSL_O_NO_TLSV11 /;"	d
BC_SSL_O_NO_TLSV12	./include/types/listener.h	/^#define BC_SSL_O_NO_TLSV12 /;"	d
BC_SSL_O_NO_TLS_TICKETS	./include/types/listener.h	/^#define BC_SSL_O_NO_TLS_TICKETS /;"	d
BC_SSL_O_USE_SSLV3	./include/types/listener.h	/^#define BC_SSL_O_USE_SSLV3 /;"	d
BC_SSL_O_USE_TLSV10	./include/types/listener.h	/^#define BC_SSL_O_USE_TLSV10 /;"	d
BC_SSL_O_USE_TLSV11	./include/types/listener.h	/^#define BC_SSL_O_USE_TLSV11 /;"	d
BC_SSL_O_USE_TLSV12	./include/types/listener.h	/^#define BC_SSL_O_USE_TLSV12 /;"	d
BE_LB_ALGO	./include/types/backend.h	/^#define BE_LB_ALGO /;"	d
BE_LB_ALGO_FAS	./include/types/backend.h	/^#define BE_LB_ALGO_FAS /;"	d
BE_LB_ALGO_HH	./include/types/backend.h	/^#define BE_LB_ALGO_HH	/;"	d
BE_LB_ALGO_LC	./include/types/backend.h	/^#define BE_LB_ALGO_LC /;"	d
BE_LB_ALGO_NONE	./include/types/backend.h	/^#define BE_LB_ALGO_NONE /;"	d
BE_LB_ALGO_PH	./include/types/backend.h	/^#define BE_LB_ALGO_PH	/;"	d
BE_LB_ALGO_RCH	./include/types/backend.h	/^#define BE_LB_ALGO_RCH	/;"	d
BE_LB_ALGO_RR	./include/types/backend.h	/^#define BE_LB_ALGO_RR /;"	d
BE_LB_ALGO_SH	./include/types/backend.h	/^#define BE_LB_ALGO_SH	/;"	d
BE_LB_ALGO_SRR	./include/types/backend.h	/^#define BE_LB_ALGO_SRR /;"	d
BE_LB_ALGO_UH	./include/types/backend.h	/^#define BE_LB_ALGO_UH	/;"	d
BE_LB_CB_FAS	./include/types/backend.h	/^#define BE_LB_CB_FAS /;"	d
BE_LB_CB_LC	./include/types/backend.h	/^#define BE_LB_CB_LC /;"	d
BE_LB_HASH_CONS	./include/types/backend.h	/^#define BE_LB_HASH_CONS /;"	d
BE_LB_HASH_FUNC	./include/types/backend.h	/^#define BE_LB_HASH_FUNC /;"	d
BE_LB_HASH_HDR	./include/types/backend.h	/^#define BE_LB_HASH_HDR /;"	d
BE_LB_HASH_MAP	./include/types/backend.h	/^#define BE_LB_HASH_MAP /;"	d
BE_LB_HASH_MOD	./include/types/backend.h	/^#define BE_LB_HASH_MOD /;"	d
BE_LB_HASH_PRM	./include/types/backend.h	/^#define BE_LB_HASH_PRM /;"	d
BE_LB_HASH_RDP	./include/types/backend.h	/^#define BE_LB_HASH_RDP /;"	d
BE_LB_HASH_SRC	./include/types/backend.h	/^#define BE_LB_HASH_SRC /;"	d
BE_LB_HASH_TYPE	./include/types/backend.h	/^#define BE_LB_HASH_TYPE /;"	d
BE_LB_HASH_URI	./include/types/backend.h	/^#define BE_LB_HASH_URI /;"	d
BE_LB_HFCN_CRC32	./include/types/backend.h	/^#define BE_LB_HFCN_CRC32 /;"	d
BE_LB_HFCN_DJB2	./include/types/backend.h	/^#define BE_LB_HFCN_DJB2 /;"	d
BE_LB_HFCN_SDBM	./include/types/backend.h	/^#define BE_LB_HFCN_SDBM /;"	d
BE_LB_HFCN_WT6	./include/types/backend.h	/^#define BE_LB_HFCN_WT6 /;"	d
BE_LB_HMOD_AVAL	./include/types/backend.h	/^#define BE_LB_HMOD_AVAL /;"	d
BE_LB_KIND	./include/types/backend.h	/^#define BE_LB_KIND /;"	d
BE_LB_KIND_CB	./include/types/backend.h	/^#define BE_LB_KIND_CB /;"	d
BE_LB_KIND_HI	./include/types/backend.h	/^#define BE_LB_KIND_HI /;"	d
BE_LB_KIND_NONE	./include/types/backend.h	/^#define BE_LB_KIND_NONE /;"	d
BE_LB_KIND_RR	./include/types/backend.h	/^#define BE_LB_KIND_RR /;"	d
BE_LB_LKUP	./include/types/backend.h	/^#define BE_LB_LKUP /;"	d
BE_LB_LKUP_CHTREE	./include/types/backend.h	/^#define BE_LB_LKUP_CHTREE /;"	d
BE_LB_LKUP_FSTREE	./include/types/backend.h	/^#define BE_LB_LKUP_FSTREE /;"	d
BE_LB_LKUP_LCTREE	./include/types/backend.h	/^#define BE_LB_LKUP_LCTREE /;"	d
BE_LB_LKUP_MAP	./include/types/backend.h	/^#define BE_LB_LKUP_MAP /;"	d
BE_LB_LKUP_NONE	./include/types/backend.h	/^#define BE_LB_LKUP_NONE /;"	d
BE_LB_LKUP_RRTREE	./include/types/backend.h	/^#define BE_LB_LKUP_RRTREE /;"	d
BE_LB_NEED	./include/types/backend.h	/^#define BE_LB_NEED /;"	d
BE_LB_NEED_ADDR	./include/types/backend.h	/^#define BE_LB_NEED_ADDR	/;"	d
BE_LB_NEED_DATA	./include/types/backend.h	/^#define BE_LB_NEED_DATA	/;"	d
BE_LB_NEED_HTTP	./include/types/backend.h	/^#define BE_LB_NEED_HTTP	/;"	d
BE_LB_NEED_NONE	./include/types/backend.h	/^#define BE_LB_NEED_NONE	/;"	d
BE_LB_PARM	./include/types/backend.h	/^#define BE_LB_PARM /;"	d
BE_LB_PROP_DYN	./include/types/backend.h	/^#define BE_LB_PROP_DYN /;"	d
BE_LB_RR_DYN	./include/types/backend.h	/^#define BE_LB_RR_DYN /;"	d
BE_LB_RR_STATIC	./include/types/backend.h	/^#define BE_LB_RR_STATIC /;"	d
BE_WEIGHT_SCALE	./include/types/backend.h	/^#define BE_WEIGHT_SCALE /;"	d
BITS_PER_INT	./include/common/compat.h	/^#define BITS_PER_INT /;"	d
BUFSIZE	./include/common/defaults.h	/^#define BUFSIZE	/;"	d
BUILDDIR	./doc/lua-api/Makefile	/^BUILDDIR      = _build$/;"	m
BUILD_OPTIONS	./Makefile	/^BUILD_OPTIONS =$/;"	m
BYTE	./src/xxhash.c	/^typedef uint8_t  BYTE;$/;"	t	file:
BYTE	./src/xxhash.c	/^typedef unsigned char      BYTE;$/;"	t	file:
BYTES_SENT_FIELD	./contrib/halog/halog.c	/^#define BYTES_SENT_FIELD /;"	d	file:
CALLOC	./include/common/config.h	/^#define CALLOC	/;"	d
CAPTURE_LEN	./include/common/defaults.h	/^#define CAPTURE_LEN /;"	d
CC	./Makefile	/^CC = clang$/;"	m
CC	./contrib/halog/Makefile	/^CC       = gcc$/;"	m
CC	./contrib/ip6range/Makefile	/^CC       = gcc$/;"	m
CC	./contrib/iprange/Makefile	/^CC       = gcc$/;"	m
CFG_GLOBAL	./include/common/cfgparse.h	/^#define CFG_GLOBAL	/;"	d
CFG_LISTEN	./include/common/cfgparse.h	/^#define CFG_LISTEN	/;"	d
CFG_NONE	./include/common/cfgparse.h	/^#define CFG_NONE	/;"	d
CFG_PEERS	./include/common/cfgparse.h	/^#define CFG_PEERS	/;"	d
CFG_USERLIST	./include/common/cfgparse.h	/^#define CFG_USERLIST	/;"	d
CFLAGS	./Makefile	/^CFLAGS = $(ARCH_FLAGS) $(CPU_CFLAGS) $(DEBUG_CFLAGS) $(SPEC_CFLAGS)$/;"	m
CF_ANA_TIMEOUT	./include/types/channel.h	/^#define CF_ANA_TIMEOUT /;"	d
CF_AUTO_CLOSE	./include/types/channel.h	/^#define CF_AUTO_CLOSE /;"	d
CF_AUTO_CONNECT	./include/types/channel.h	/^#define CF_AUTO_CONNECT /;"	d
CF_DONT_READ	./include/types/channel.h	/^#define CF_DONT_READ /;"	d
CF_EXPECT_MORE	./include/types/channel.h	/^#define CF_EXPECT_MORE /;"	d
CF_ISRESP	./include/types/channel.h	/^#define CF_ISRESP /;"	d
CF_KERN_SPLICING	./include/types/channel.h	/^#define CF_KERN_SPLICING /;"	d
CF_MASK_ANALYSER	./include/types/channel.h	/^#define CF_MASK_ANALYSER /;"	d
CF_MASK_STATIC	./include/types/channel.h	/^#define CF_MASK_STATIC /;"	d
CF_NEVER_WAIT	./include/types/channel.h	/^#define CF_NEVER_WAIT /;"	d
CF_READ_ACTIVITY	./include/types/channel.h	/^#define CF_READ_ACTIVITY /;"	d
CF_READ_ATTACHED	./include/types/channel.h	/^#define CF_READ_ATTACHED /;"	d
CF_READ_DONTWAIT	./include/types/channel.h	/^#define CF_READ_DONTWAIT /;"	d
CF_READ_ERROR	./include/types/channel.h	/^#define CF_READ_ERROR /;"	d
CF_READ_NOEXP	./include/types/channel.h	/^#define CF_READ_NOEXP /;"	d
CF_READ_NULL	./include/types/channel.h	/^#define CF_READ_NULL /;"	d
CF_READ_PARTIAL	./include/types/channel.h	/^#define CF_READ_PARTIAL /;"	d
CF_READ_TIMEOUT	./include/types/channel.h	/^#define CF_READ_TIMEOUT /;"	d
CF_SEND_DONTWAIT	./include/types/channel.h	/^#define CF_SEND_DONTWAIT /;"	d
CF_SHUTR	./include/types/channel.h	/^#define CF_SHUTR /;"	d
CF_SHUTR_NOW	./include/types/channel.h	/^#define CF_SHUTR_NOW /;"	d
CF_SHUTW	./include/types/channel.h	/^#define CF_SHUTW /;"	d
CF_SHUTW_NOW	./include/types/channel.h	/^#define CF_SHUTW_NOW /;"	d
CF_STREAMER	./include/types/channel.h	/^#define CF_STREAMER /;"	d
CF_STREAMER_FAST	./include/types/channel.h	/^#define CF_STREAMER_FAST /;"	d
CF_WAKE_CONNECT	./include/types/channel.h	/^#define CF_WAKE_CONNECT /;"	d
CF_WAKE_ONCE	./include/types/channel.h	/^#define CF_WAKE_ONCE /;"	d
CF_WAKE_WRITE	./include/types/channel.h	/^#define CF_WAKE_WRITE /;"	d
CF_WRITE_ACTIVITY	./include/types/channel.h	/^#define CF_WRITE_ACTIVITY /;"	d
CF_WRITE_ERROR	./include/types/channel.h	/^#define CF_WRITE_ERROR /;"	d
CF_WRITE_NULL	./include/types/channel.h	/^#define CF_WRITE_NULL /;"	d
CF_WRITE_PARTIAL	./include/types/channel.h	/^#define CF_WRITE_PARTIAL /;"	d
CF_WRITE_TIMEOUT	./include/types/channel.h	/^#define CF_WRITE_TIMEOUT /;"	d
CF_WROTE_DATA	./include/types/channel.h	/^#define CF_WROTE_DATA /;"	d
CHECK_HTTP_MESSAGE_FIRST	./include/proto/proto_http.h	/^#define CHECK_HTTP_MESSAGE_FIRST(/;"	d
CHECK_HTTP_MESSAGE_FIRST_PERM	./include/proto/proto_http.h	/^#define CHECK_HTTP_MESSAGE_FIRST_PERM(/;"	d
CHK_CONNTIME	./include/common/defaults.h	/^#define	CHK_CONNTIME /;"	d
CHK_RES_CONDPASS	./include/types/checks.h	/^	CHK_RES_CONDPASS,               \/* check reports the server doesn't want new sessions *\/$/;"	e	enum:chk_result
CHK_RES_FAILED	./include/types/checks.h	/^	CHK_RES_FAILED,                 \/* check failed *\/$/;"	e	enum:chk_result
CHK_RES_NEUTRAL	./include/types/checks.h	/^	CHK_RES_NEUTRAL,                \/* valid check but no status information *\/$/;"	e	enum:chk_result
CHK_RES_PASSED	./include/types/checks.h	/^	CHK_RES_PASSED,                 \/* check succeeded and server is fully up again *\/$/;"	e	enum:chk_result
CHK_RES_UNKNOWN	./include/types/checks.h	/^	CHK_RES_UNKNOWN = 0,            \/* initialized to this by default *\/$/;"	e	enum:chk_result
CHK_ST_AGENT	./include/types/checks.h	/^#define CHK_ST_AGENT /;"	d
CHK_ST_CONFIGURED	./include/types/checks.h	/^#define CHK_ST_CONFIGURED /;"	d
CHK_ST_ENABLED	./include/types/checks.h	/^#define CHK_ST_ENABLED /;"	d
CHK_ST_INPROGRESS	./include/types/checks.h	/^#define CHK_ST_INPROGRESS /;"	d
CHK_ST_PAUSED	./include/types/checks.h	/^#define CHK_ST_PAUSED /;"	d
CHN_INFINITE_FORWARD	./include/types/channel.h	/^#define CHN_INFINITE_FORWARD /;"	d
CLASS_APPLET_HTTP	./include/types/hlua.h	/^#define CLASS_APPLET_HTTP /;"	d
CLASS_APPLET_TCP	./include/types/hlua.h	/^#define CLASS_APPLET_TCP /;"	d
CLASS_CHANNEL	./include/types/hlua.h	/^#define CLASS_CHANNEL /;"	d
CLASS_CONVERTERS	./include/types/hlua.h	/^#define CLASS_CONVERTERS /;"	d
CLASS_CORE	./include/types/hlua.h	/^#define CLASS_CORE /;"	d
CLASS_FETCHES	./include/types/hlua.h	/^#define CLASS_FETCHES /;"	d
CLASS_HTTP	./include/types/hlua.h	/^#define CLASS_HTTP /;"	d
CLASS_MAP	./include/types/hlua.h	/^#define CLASS_MAP /;"	d
CLASS_SOCKET	./include/types/hlua.h	/^#define CLASS_SOCKET /;"	d
CLASS_TXN	./include/types/hlua.h	/^#define CLASS_TXN /;"	d
CONFIG_HAP_MEM_OPTIM	./include/common/config.h	/^#  define CONFIG_HAP_MEM_OPTIM$/;"	d
CONFIG_HAP_TRANSPARENT	./include/common/compat.h	/^#define CONFIG_HAP_TRANSPARENT$/;"	d
CONNECT_DEFAULT_CIPHERS	./include/common/defaults.h	/^#define CONNECT_DEFAULT_CIPHERS /;"	d
CONN_FIELD	./contrib/halog/halog.c	/^#define CONN_FIELD /;"	d	file:
CONN_RETRIES	./include/common/defaults.h	/^#define CONN_RETRIES /;"	d
COOKIE_DELIM	./include/common/defaults.h	/^#define COOKIE_DELIM /;"	d
COOKIE_DELIM_DATE	./include/common/defaults.h	/^#define COOKIE_DELIM_DATE /;"	d
COPTS	./Makefile	/^COPTS  = -Iinclude -I$(EBTREE_DIR) -Wall$/;"	m
CO_ER_ADDR_INUSE	./include/types/connection.h	/^	CO_ER_ADDR_INUSE,       \/* local address already in use *\/$/;"	e	enum:__anon47
CO_ER_CANT_BIND	./include/types/connection.h	/^	CO_ER_CANT_BIND,        \/* can't bind to source address *\/$/;"	e	enum:__anon47
CO_ER_CONF_FDLIM	./include/types/connection.h	/^	CO_ER_CONF_FDLIM,       \/* reached process' configured FD limitation *\/$/;"	e	enum:__anon47
CO_ER_FREE_PORTS	./include/types/connection.h	/^	CO_ER_FREE_PORTS,       \/* no more free ports on the system *\/$/;"	e	enum:__anon47
CO_ER_NONE	./include/types/connection.h	/^	CO_ER_NONE,             \/* no error *\/$/;"	e	enum:__anon47
CO_ER_NOPROTO	./include/types/connection.h	/^	CO_ER_NOPROTO,          \/* protocol not supported *\/$/;"	e	enum:__anon47
CO_ER_PORT_RANGE	./include/types/connection.h	/^	CO_ER_PORT_RANGE,       \/* source port range exhausted *\/$/;"	e	enum:__anon47
CO_ER_PROC_FDLIM	./include/types/connection.h	/^	CO_ER_PROC_FDLIM,       \/* reached process' FD limitation *\/$/;"	e	enum:__anon47
CO_ER_PRX_ABORT	./include/types/connection.h	/^	CO_ER_PRX_ABORT,        \/* client abort during PROXY protocol header *\/$/;"	e	enum:__anon47
CO_ER_PRX_BAD_HDR	./include/types/connection.h	/^	CO_ER_PRX_BAD_HDR,      \/* bad PROXY protocol header *\/$/;"	e	enum:__anon47
CO_ER_PRX_BAD_PROTO	./include/types/connection.h	/^	CO_ER_PRX_BAD_PROTO,    \/* unsupported protocol in PROXY header *\/$/;"	e	enum:__anon47
CO_ER_PRX_EMPTY	./include/types/connection.h	/^	CO_ER_PRX_EMPTY,        \/* nothing received in PROXY protocol header *\/$/;"	e	enum:__anon47
CO_ER_PRX_NOT_HDR	./include/types/connection.h	/^	CO_ER_PRX_NOT_HDR,      \/* not a PROXY protocol header *\/$/;"	e	enum:__anon47
CO_ER_PRX_TIMEOUT	./include/types/connection.h	/^	CO_ER_PRX_TIMEOUT,      \/* timeout while waiting for a PROXY header *\/$/;"	e	enum:__anon47
CO_ER_PRX_TRUNCATED	./include/types/connection.h	/^	CO_ER_PRX_TRUNCATED,    \/* truncated PROXY protocol header *\/$/;"	e	enum:__anon47
CO_ER_SOCK_ERR	./include/types/connection.h	/^	CO_ER_SOCK_ERR,         \/* other socket error *\/$/;"	e	enum:__anon47
CO_ER_SSL_ABORT	./include/types/connection.h	/^	CO_ER_SSL_ABORT,        \/* client abort during SSL handshake *\/$/;"	e	enum:__anon47
CO_ER_SSL_CA_FAIL	./include/types/connection.h	/^	CO_ER_SSL_CA_FAIL,      \/* client cert verification failed in the CA chain *\/$/;"	e	enum:__anon47
CO_ER_SSL_CRT_FAIL	./include/types/connection.h	/^	CO_ER_SSL_CRT_FAIL,     \/* client cert verification failed on the certificate *\/$/;"	e	enum:__anon47
CO_ER_SSL_EMPTY	./include/types/connection.h	/^	CO_ER_SSL_EMPTY,        \/* client closed during SSL handshake *\/$/;"	e	enum:__anon47
CO_ER_SSL_HANDSHAKE	./include/types/connection.h	/^	CO_ER_SSL_HANDSHAKE,    \/* SSL error during handshake *\/$/;"	e	enum:__anon47
CO_ER_SSL_HANDSHAKE_HB	./include/types/connection.h	/^	CO_ER_SSL_HANDSHAKE_HB, \/* SSL error during handshake with heartbeat present *\/$/;"	e	enum:__anon47
CO_ER_SSL_KILLED_HB	./include/types/connection.h	/^	CO_ER_SSL_KILLED_HB,    \/* Stopped a TLSv1 heartbeat attack (CVE-2014-0160) *\/$/;"	e	enum:__anon47
CO_ER_SSL_NO_MEM	./include/types/connection.h	/^	CO_ER_SSL_NO_MEM,       \/* no more memory to allocate an SSL connection *\/$/;"	e	enum:__anon47
CO_ER_SSL_NO_TARGET	./include/types/connection.h	/^	CO_ER_SSL_NO_TARGET,    \/* unknown target (not client nor server) *\/$/;"	e	enum:__anon47
CO_ER_SSL_RENEG	./include/types/connection.h	/^	CO_ER_SSL_RENEG,        \/* forbidden client renegociation *\/$/;"	e	enum:__anon47
CO_ER_SSL_TIMEOUT	./include/types/connection.h	/^	CO_ER_SSL_TIMEOUT,      \/* timeout during SSL handshake *\/$/;"	e	enum:__anon47
CO_ER_SSL_TOO_MANY	./include/types/connection.h	/^	CO_ER_SSL_TOO_MANY,     \/* too many SSL connections *\/$/;"	e	enum:__anon47
CO_ER_SYS_FDLIM	./include/types/connection.h	/^	CO_ER_SYS_FDLIM,        \/* reached system's FD limitation *\/$/;"	e	enum:__anon47
CO_ER_SYS_MEMLIM	./include/types/connection.h	/^	CO_ER_SYS_MEMLIM,       \/* reached system buffers limitation *\/$/;"	e	enum:__anon47
CO_FL_ACCEPT_PROXY	./include/types/connection.h	/^	CO_FL_ACCEPT_PROXY  = 0x04000000,  \/* receive a valid PROXY protocol header *\/$/;"	e	enum:__anon46
CO_FL_ADDR_FROM_SET	./include/types/connection.h	/^	CO_FL_ADDR_FROM_SET = 0x00001000,  \/* addr.from is set *\/$/;"	e	enum:__anon46
CO_FL_ADDR_TO_SET	./include/types/connection.h	/^	CO_FL_ADDR_TO_SET   = 0x00002000,  \/* addr.to is set *\/$/;"	e	enum:__anon46
CO_FL_CONNECTED	./include/types/connection.h	/^	CO_FL_CONNECTED     = 0x00200000,  \/* the connection is now established *\/$/;"	e	enum:__anon46
CO_FL_CONN_STATE	./include/types/connection.h	/^	CO_FL_CONN_STATE    = 0x00FF0000,  \/* all shut\/connected flags *\/$/;"	e	enum:__anon46
CO_FL_CTRL_READY	./include/types/connection.h	/^	CO_FL_CTRL_READY    = 0x00000100, \/* FD was registered, fd_delete() needed *\/$/;"	e	enum:__anon46
CO_FL_CURR_RD_ENA	./include/types/connection.h	/^	CO_FL_CURR_RD_ENA   = 0x00000004,  \/* receiving is currently allowed *\/$/;"	e	enum:__anon46
CO_FL_CURR_WR_ENA	./include/types/connection.h	/^	CO_FL_CURR_WR_ENA   = 0x00000040,  \/* sending is currently desired *\/$/;"	e	enum:__anon46
CO_FL_DATA_RD_ENA	./include/types/connection.h	/^	CO_FL_DATA_RD_ENA   = 0x00000002,  \/* receiving data is allowed *\/$/;"	e	enum:__anon46
CO_FL_DATA_RD_SH	./include/types/connection.h	/^	CO_FL_DATA_RD_SH    = 0x00010000,  \/* DATA layer was notified about shutr\/read0 *\/$/;"	e	enum:__anon46
CO_FL_DATA_WR_ENA	./include/types/connection.h	/^	CO_FL_DATA_WR_ENA   = 0x00000020,  \/* sending data is desired *\/$/;"	e	enum:__anon46
CO_FL_DATA_WR_SH	./include/types/connection.h	/^	CO_FL_DATA_WR_SH    = 0x00020000,  \/* DATA layer asked for shutw *\/$/;"	e	enum:__anon46
CO_FL_ERROR	./include/types/connection.h	/^	CO_FL_ERROR         = 0x00100000,  \/* a fatal error was reported     *\/$/;"	e	enum:__anon46
CO_FL_HANDSHAKE	./include/types/connection.h	/^	CO_FL_HANDSHAKE     = CO_FL_SEND_PROXY | CO_FL_SSL_WAIT_HS | CO_FL_ACCEPT_PROXY,$/;"	e	enum:__anon46
CO_FL_INIT_DATA	./include/types/connection.h	/^	CO_FL_INIT_DATA     = 0x00004000,  \/* initialize the data layer before using it *\/$/;"	e	enum:__anon46
CO_FL_NONE	./include/types/connection.h	/^	CO_FL_NONE          = 0x00000000,  \/* Just for initialization purposes *\/$/;"	e	enum:__anon46
CO_FL_POLL_SOCK	./include/types/connection.h	/^	CO_FL_POLL_SOCK     = CO_FL_HANDSHAKE | CO_FL_WAIT_L4_CONN | CO_FL_WAIT_L6_CONN,$/;"	e	enum:__anon46
CO_FL_PRIVATE	./include/types/connection.h	/^	CO_FL_PRIVATE       = 0x10000000,$/;"	e	enum:__anon46
CO_FL_SEND_PROXY	./include/types/connection.h	/^	CO_FL_SEND_PROXY    = 0x01000000,  \/* send a valid PROXY protocol header *\/$/;"	e	enum:__anon46
CO_FL_SOCK_RD_ENA	./include/types/connection.h	/^	CO_FL_SOCK_RD_ENA   = 0x00000001,  \/* receiving handshakes is allowed *\/$/;"	e	enum:__anon46
CO_FL_SOCK_RD_SH	./include/types/connection.h	/^	CO_FL_SOCK_RD_SH    = 0x00040000,  \/* SOCK layer was notified about shutr\/read0 *\/$/;"	e	enum:__anon46
CO_FL_SOCK_WR_ENA	./include/types/connection.h	/^	CO_FL_SOCK_WR_ENA   = 0x00000010,  \/* sending handshakes is desired *\/$/;"	e	enum:__anon46
CO_FL_SOCK_WR_SH	./include/types/connection.h	/^	CO_FL_SOCK_WR_SH    = 0x00080000,  \/* SOCK layer asked for shutw *\/$/;"	e	enum:__anon46
CO_FL_SSL_WAIT_HS	./include/types/connection.h	/^	CO_FL_SSL_WAIT_HS   = 0x02000000,  \/* wait for an SSL handshake to complete *\/$/;"	e	enum:__anon46
CO_FL_WAIT_DATA	./include/types/connection.h	/^	CO_FL_WAIT_DATA     = 0x00000400,  \/* data source is empty *\/$/;"	e	enum:__anon46
CO_FL_WAIT_L4_CONN	./include/types/connection.h	/^	CO_FL_WAIT_L4_CONN  = 0x00400000,  \/* waiting for L4 to be connected *\/$/;"	e	enum:__anon46
CO_FL_WAIT_L6_CONN	./include/types/connection.h	/^	CO_FL_WAIT_L6_CONN  = 0x00800000,  \/* waiting for L6 to be connected (eg: SSL) *\/$/;"	e	enum:__anon46
CO_FL_WAIT_ROOM	./include/types/connection.h	/^	CO_FL_WAIT_ROOM     = 0x00000800,  \/* data sink is full *\/$/;"	e	enum:__anon46
CO_FL_WAKE_DATA	./include/types/connection.h	/^	CO_FL_WAKE_DATA     = 0x00008000,  \/* wake-up data layer upon activity at the transport layer *\/$/;"	e	enum:__anon46
CO_FL_XPRT_READY	./include/types/connection.h	/^	CO_FL_XPRT_READY    = 0x00000200, \/* xprt_init() done, xprt_close() needed *\/$/;"	e	enum:__anon46
CO_FL_XPRT_TRACKED	./include/types/connection.h	/^	CO_FL_XPRT_TRACKED  = 0x80000000,$/;"	e	enum:__anon46
CO_SFL_MSG_MORE	./include/types/connection.h	/^	CO_SFL_MSG_MORE    = 0x0001,    \/* More data to come afterwards *\/$/;"	e	enum:__anon49
CO_SFL_STREAMER	./include/types/connection.h	/^	CO_SFL_STREAMER    = 0x0002,    \/* Producer is continuously streaming data *\/$/;"	e	enum:__anon49
CO_SRC_BIND	./include/types/connection.h	/^	CO_SRC_BIND        = 0x0008,    \/* bind to a specific source address when connecting *\/$/;"	e	enum:__anon48
CO_SRC_TPROXY_ADDR	./include/types/connection.h	/^	CO_SRC_TPROXY_ADDR = 0x0001,    \/* bind to this non-local address when connecting *\/$/;"	e	enum:__anon48
CO_SRC_TPROXY_CIP	./include/types/connection.h	/^	CO_SRC_TPROXY_CIP  = 0x0002,    \/* bind to the client's IP address when connecting *\/$/;"	e	enum:__anon48
CO_SRC_TPROXY_CLI	./include/types/connection.h	/^	CO_SRC_TPROXY_CLI  = 0x0003,    \/* bind to the client's IP+port when connecting *\/$/;"	e	enum:__anon48
CO_SRC_TPROXY_DYN	./include/types/connection.h	/^	CO_SRC_TPROXY_DYN  = 0x0004,    \/* bind to a dynamically computed non-local address *\/$/;"	e	enum:__anon48
CO_SRC_TPROXY_MASK	./include/types/connection.h	/^	CO_SRC_TPROXY_MASK = 0x0007,    \/* bind to a non-local address when connecting *\/$/;"	e	enum:__anon48
CPU	./Makefile	/^CPU = generic$/;"	m
CPU_CFLAGS	./Makefile	/^CPU_CFLAGS            = $(CPU_CFLAGS.$(CPU))$/;"	m
CPU_CFLAGS.generic	./Makefile	/^CPU_CFLAGS.generic    = -O2$/;"	m
CPU_CFLAGS.i586	./Makefile	/^CPU_CFLAGS.i586       = -O2 -march=i586$/;"	m
CPU_CFLAGS.i686	./Makefile	/^CPU_CFLAGS.i686       = -O2 -march=i686$/;"	m
CPU_CFLAGS.native	./Makefile	/^CPU_CFLAGS.native     = -O2 -march=native$/;"	m
CPU_CFLAGS.ultrasparc	./Makefile	/^CPU_CFLAGS.ultrasparc = -O6 -mcpu=v9 -mtune=ultrasparc$/;"	m
CT_EXTENSION_TYPE	./src/ssl_sock.c	/^#define CT_EXTENSION_TYPE /;"	d	file:
DAY	./include/common/standard.h	/^#define DAY /;"	d
DA_COOKIENAME_DEFAULT	./src/da.c	/^#define	DA_COOKIENAME_DEFAULT	/;"	d	file:
DA_MAX_HEADERS	./src/da.c	/^#define DA_MAX_HEADERS /;"	d	file:
DBMANAGE_DEFAULT_URI	./include/common/uri_auth.h	/^#define DBMANAGE_DEFAULT_URI /;"	d
DEBUG	./Makefile	/^DEBUG =$/;"	m
DEBUG_CFLAGS	./Makefile	/^  DEBUG_CFLAGS    =$/;"	m
DEBUG_CFLAGS	./Makefile	/^DEBUG_CFLAGS = -g$/;"	m
DEFAULT_MAXCONN	./include/common/defaults.h	/^#define DEFAULT_MAXCONN /;"	d
DEFAULT_MAXCONN	./include/common/defaults.h	/^#undef  DEFAULT_MAXCONN$/;"	d
DEFAULT_PAT_LRU_SIZE	./include/common/defaults.h	/^#define DEFAULT_PAT_LRU_SIZE /;"	d
DEFAULT_SSL_CTX_CACHE	./include/common/defaults.h	/^#define DEFAULT_SSL_CTX_CACHE /;"	d
DEFINE	./Makefile	/^DEFINE =$/;"	m
DEFINE	./contrib/halog/Makefile	/^DEFINE   =$/;"	m
DEF_AGENT_FALLTIME	./include/common/defaults.h	/^#define DEF_AGENT_FALLTIME /;"	d
DEF_AGENT_RISETIME	./include/common/defaults.h	/^#define DEF_AGENT_RISETIME /;"	d
DEF_CHECK_PATH	./include/common/defaults.h	/^#define DEF_CHECK_PATH /;"	d
DEF_CHECK_REQ	./include/common/defaults.h	/^#define DEF_CHECK_REQ /;"	d
DEF_CHKINTR	./include/common/defaults.h	/^#define	DEF_CHKINTR /;"	d
DEF_FALLTIME	./include/common/defaults.h	/^#define DEF_FALLTIME /;"	d
DEF_HANA_ERRLIMIT	./include/common/defaults.h	/^#define DEF_HANA_ERRLIMIT	/;"	d
DEF_HANA_ONERR	./include/common/defaults.h	/^#define DEF_HANA_ONERR	/;"	d
DEF_LDAP_CHECK_REQ	./include/common/defaults.h	/^#define DEF_LDAP_CHECK_REQ /;"	d
DEF_REDIS_CHECK_REQ	./include/common/defaults.h	/^#define DEF_REDIS_CHECK_REQ /;"	d
DEF_RISETIME	./include/common/defaults.h	/^#define DEF_RISETIME /;"	d
DEF_SMTP_CHECK_REQ	./include/common/defaults.h	/^#define DEF_SMTP_CHECK_REQ /;"	d
DEF_XFORWARDFOR_HDR	./include/common/defaults.h	/^#define DEF_XFORWARDFOR_HDR	/;"	d
DEF_XORIGINALTO_HDR	./include/common/defaults.h	/^#define DEF_XORIGINALTO_HDR	/;"	d
DESTDIR	./Makefile	/^DESTDIR =$/;"	m
DEVICEATLAS_INC	./Makefile	/^DEVICEATLAS_INC = $(DEVICEATLAS_SRC)$/;"	m
DEVICEATLAS_LIB	./Makefile	/^DEVICEATLAS_LIB = $(DEVICEATLAS_SRC)$/;"	m
DEVICEATLAS_SRC	./Makefile	/^DEVICEATLAS_SRC =$/;"	m
DIR_RD	./include/types/fd.h	/^	DIR_RD=0,$/;"	e	enum:__anon70
DIR_WR	./include/types/fd.h	/^	DIR_WR=1,$/;"	e	enum:__anon70
DLMALLOC_SRC	./Makefile	/^DLMALLOC_SRC=src\/dlmalloc.c$/;"	m
DLMALLOC_THRES	./Makefile	/^DLMALLOC_THRES = 4096$/;"	m
DNS_FLAG_REPLYCODE	./include/types/dns.h	/^#define DNS_FLAG_REPLYCODE	/;"	d
DNS_FLAG_TRUNCATED	./include/types/dns.h	/^#define DNS_FLAG_TRUNCATED	/;"	d
DNS_INVALID_CHARACTER	./include/types/dns.h	/^#define DNS_INVALID_CHARACTER	/;"	d
DNS_LABEL_TOO_LONG	./include/types/dns.h	/^#define DNS_LABEL_TOO_LONG	/;"	d
DNS_MAX_LABEL_SIZE	./include/types/dns.h	/^#define DNS_MAX_LABEL_SIZE	/;"	d
DNS_MAX_NAME_SIZE	./include/types/dns.h	/^#define DNS_MAX_NAME_SIZE	/;"	d
DNS_MAX_UDP_MESSAGE	./include/types/dns.h	/^#define DNS_MAX_UDP_MESSAGE	/;"	d
DNS_RCLASS_IN	./include/types/dns.h	/^#define DNS_RCLASS_IN	/;"	d
DNS_RCODE_NO_ERROR	./include/types/dns.h	/^#define DNS_RCODE_NO_ERROR	/;"	d
DNS_RCODE_NX_DOMAIN	./include/types/dns.h	/^#define DNS_RCODE_NX_DOMAIN	/;"	d
DNS_RCODE_REFUSED	./include/types/dns.h	/^#define DNS_RCODE_REFUSED	/;"	d
DNS_RESP_ANCOUNT_ZERO	./include/types/dns.h	/^	DNS_RESP_ANCOUNT_ZERO,		\/* no answers in the response *\/$/;"	e	enum:__anon68
DNS_RESP_CNAME_ERROR	./include/types/dns.h	/^	DNS_RESP_CNAME_ERROR,		\/* error when resolving a CNAME in an atomic response *\/$/;"	e	enum:__anon68
DNS_RESP_ERROR	./include/types/dns.h	/^	DNS_RESP_ERROR,			\/* DNS error code *\/$/;"	e	enum:__anon68
DNS_RESP_INVALID	./include/types/dns.h	/^	DNS_RESP_INVALID,		\/* invalid response (various type of errors can trigger it) *\/$/;"	e	enum:__anon68
DNS_RESP_NO_EXPECTED_RECORD	./include/types/dns.h	/^	DNS_RESP_NO_EXPECTED_RECORD,	\/* No expected records were found in the response *\/$/;"	e	enum:__anon68
DNS_RESP_NX_DOMAIN	./include/types/dns.h	/^	DNS_RESP_NX_DOMAIN,		\/* resolution unsuccessful *\/$/;"	e	enum:__anon68
DNS_RESP_REFUSED	./include/types/dns.h	/^	DNS_RESP_REFUSED,		\/* DNS server refused to answer *\/$/;"	e	enum:__anon68
DNS_RESP_TIMEOUT	./include/types/dns.h	/^	DNS_RESP_TIMEOUT,		\/* DNS server has not answered in time *\/$/;"	e	enum:__anon68
DNS_RESP_TRUNCATED	./include/types/dns.h	/^	DNS_RESP_TRUNCATED,		\/* DNS response is truncated *\/$/;"	e	enum:__anon68
DNS_RESP_VALID	./include/types/dns.h	/^	DNS_RESP_VALID		= 0,	\/* valid response *\/$/;"	e	enum:__anon68
DNS_RESP_WRONG_NAME	./include/types/dns.h	/^	DNS_RESP_WRONG_NAME,		\/* response does not match query name *\/$/;"	e	enum:__anon68
DNS_RTYPE_A	./include/types/dns.h	/^#define DNS_RTYPE_A	/;"	d
DNS_RTYPE_AAAA	./include/types/dns.h	/^#define DNS_RTYPE_AAAA	/;"	d
DNS_RTYPE_ANY	./include/types/dns.h	/^#define DNS_RTYPE_ANY	/;"	d
DNS_RTYPE_CNAME	./include/types/dns.h	/^#define DNS_RTYPE_CNAME	/;"	d
DNS_TOO_LONG_FQDN	./include/types/dns.h	/^#define DNS_TOO_LONG_FQDN	/;"	d
DNS_UPD_CNAME	./include/types/dns.h	/^	DNS_UPD_CNAME,			\/* CNAME without any IP provided in the response *\/$/;"	e	enum:__anon69
DNS_UPD_NAME_ERROR	./include/types/dns.h	/^	DNS_UPD_NAME_ERROR,		\/* name in the response did not match the query *\/$/;"	e	enum:__anon69
DNS_UPD_NO	./include/types/dns.h	/^	DNS_UPD_NO 		= 1,	\/* provided IP was found and preference is matched$/;"	e	enum:__anon69
DNS_UPD_NO_IP_FOUND	./include/types/dns.h	/^	DNS_UPD_NO_IP_FOUND,		\/* no IP could be found in the response *\/$/;"	e	enum:__anon69
DNS_UPD_SRVIP_NOT_FOUND	./include/types/dns.h	/^	DNS_UPD_SRVIP_NOT_FOUND,	\/* provided IP not found$/;"	e	enum:__anon69
DOCDIR	./Makefile	/^DOCDIR = $(PREFIX)\/doc\/haproxy$/;"	m
DOCUMENTATION	./Makefile	/^DOCUMENTATION = $(filter-out $(EXCLUDE_DOCUMENTATION),$(patsubst doc\/%.txt,%,$(wildcard doc\/*.txt)))$/;"	m
DPRINTF	./include/common/debug.h	/^#define DPRINTF(/;"	d
EAT_AND_JUMP_OR_RETURN	./src/proto_http.c	/^#define EAT_AND_JUMP_OR_RETURN(/;"	d	file:
EB32_ROOT	./ebtree/eb32tree.h	/^#define EB32_ROOT	/;"	d
EB32_TREE_HEAD	./ebtree/eb32tree.h	/^#define EB32_TREE_HEAD	/;"	d
EB64_ROOT	./ebtree/eb64tree.h	/^#define EB64_ROOT	/;"	d
EB64_TREE_HEAD	./ebtree/eb64tree.h	/^#define EB64_TREE_HEAD	/;"	d
EBMB_ROOT	./ebtree/ebmbtree.h	/^#define EBMB_ROOT	/;"	d
EBMB_TREE_HEAD	./ebtree/ebmbtree.h	/^#define EBMB_TREE_HEAD	/;"	d
EBPT_ROOT	./ebtree/ebpttree.h	/^#define EBPT_ROOT	/;"	d
EBPT_TREE_HEAD	./ebtree/ebpttree.h	/^#define EBPT_TREE_HEAD	/;"	d
EBTREE_DIR	./Makefile	/^EBTREE_DIR := ebtree$/;"	m
EBTREE_DIR	./contrib/halog/Makefile	/^EBTREE_DIR = ..\/..\/ebtree$/;"	m
EBTREE_OBJS	./Makefile	/^EBTREE_OBJS = $(EBTREE_DIR)\/ebtree.o \\$/;"	m
EB_LEAF	./ebtree/ebtree.h	/^#define EB_LEAF /;"	d
EB_LEFT	./ebtree/ebtree.h	/^#define EB_LEFT /;"	d
EB_NODE	./ebtree/ebtree.h	/^#define EB_NODE /;"	d
EB_NODE_BITS	./ebtree/ebtree.h	/^#define EB_NODE_BITS /;"	d
EB_NODE_BRANCHES	./ebtree/ebtree.h	/^#define EB_NODE_BRANCHES /;"	d
EB_NODE_BRANCH_MASK	./ebtree/ebtree.h	/^#define EB_NODE_BRANCH_MASK /;"	d
EB_NORMAL	./ebtree/ebtree.h	/^#define EB_NORMAL /;"	d
EB_RGHT	./ebtree/ebtree.h	/^#define EB_RGHT /;"	d
EB_ROOT	./ebtree/ebtree.h	/^#define EB_ROOT	/;"	d
EB_ROOT_UNIQUE	./ebtree/ebtree.h	/^#define EB_ROOT_UNIQUE	/;"	d
EB_TREE_HEAD	./ebtree/ebtree.h	/^#define EB_TREE_HEAD(/;"	d
EB_UNIQUE	./ebtree/ebtree.h	/^#define EB_UNIQUE /;"	d
ECDHE_DEFAULT_CURVE	./include/common/defaults.h	/^#define ECDHE_DEFAULT_CURVE /;"	d
EPOLLERR	./include/common/epoll.h	/^#define EPOLLERR /;"	d
EPOLLET	./include/common/epoll.h	/^#define EPOLLET /;"	d
EPOLLHUP	./include/common/epoll.h	/^#define EPOLLHUP /;"	d
EPOLLIN	./include/common/epoll.h	/^#define EPOLLIN /;"	d
EPOLLONESHOT	./include/common/epoll.h	/^#define EPOLLONESHOT /;"	d
EPOLLOUT	./include/common/epoll.h	/^#define EPOLLOUT /;"	d
EPOLLPRI	./include/common/epoll.h	/^#define EPOLLPRI /;"	d
EPOLLRDHUP	./src/ev_epoll.c	/^#define EPOLLRDHUP /;"	d	file:
EPOLL_CTL_ADD	./include/common/epoll.h	/^#define EPOLL_CTL_ADD /;"	d
EPOLL_CTL_DEL	./include/common/epoll.h	/^#define EPOLL_CTL_DEL /;"	d
EPOLL_CTL_MOD	./include/common/epoll.h	/^#define EPOLL_CTL_MOD /;"	d
ERR_ABORT	./include/common/errors.h	/^#define ERR_ABORT	/;"	d
ERR_ALERT	./include/common/errors.h	/^#define ERR_ALERT	/;"	d
ERR_CODE	./include/common/errors.h	/^#define ERR_CODE	/;"	d
ERR_FATAL	./include/common/errors.h	/^#define ERR_FATAL	/;"	d
ERR_NONE	./include/common/errors.h	/^#define ERR_NONE	/;"	d
ERR_RETRYABLE	./include/common/errors.h	/^#define ERR_RETRYABLE	/;"	d
ERR_WARN	./include/common/errors.h	/^#define ERR_WARN	/;"	d
EXCLUDE_DOCUMENTATION	./Makefile	/^EXCLUDE_DOCUMENTATION = lgpl gpl coding-style$/;"	m
EXPECT_LF_HERE	./src/proto_http.c	/^#define EXPECT_LF_HERE(/;"	d	file:
EXTCHK_HAPROXY_PROXY_ADDR	./include/types/checks.h	/^	EXTCHK_HAPROXY_PROXY_ADDR,	\/* the first bind address if available (or empty) *\/$/;"	e	enum:__anon39
EXTCHK_HAPROXY_PROXY_ID	./include/types/checks.h	/^	EXTCHK_HAPROXY_PROXY_ID,	\/* the backend id *\/$/;"	e	enum:__anon39
EXTCHK_HAPROXY_PROXY_NAME	./include/types/checks.h	/^	EXTCHK_HAPROXY_PROXY_NAME,	\/* the backend name *\/$/;"	e	enum:__anon39
EXTCHK_HAPROXY_PROXY_PORT	./include/types/checks.h	/^	EXTCHK_HAPROXY_PROXY_PORT,	\/* the first bind port if available (or empty) *\/$/;"	e	enum:__anon39
EXTCHK_HAPROXY_SERVER_ADDR	./include/types/checks.h	/^	EXTCHK_HAPROXY_SERVER_ADDR,	\/* the server address *\/$/;"	e	enum:__anon39
EXTCHK_HAPROXY_SERVER_CURCONN	./include/types/checks.h	/^	EXTCHK_HAPROXY_SERVER_CURCONN,	\/* the current number of connections on the server *\/$/;"	e	enum:__anon39
EXTCHK_HAPROXY_SERVER_ID	./include/types/checks.h	/^	EXTCHK_HAPROXY_SERVER_ID,	\/* the server id *\/$/;"	e	enum:__anon39
EXTCHK_HAPROXY_SERVER_MAXCONN	./include/types/checks.h	/^	EXTCHK_HAPROXY_SERVER_MAXCONN,	\/* the server max connections *\/$/;"	e	enum:__anon39
EXTCHK_HAPROXY_SERVER_NAME	./include/types/checks.h	/^	EXTCHK_HAPROXY_SERVER_NAME,	\/* the server name *\/$/;"	e	enum:__anon39
EXTCHK_HAPROXY_SERVER_PORT	./include/types/checks.h	/^	EXTCHK_HAPROXY_SERVER_PORT,	\/* the server port if available (or empty) *\/$/;"	e	enum:__anon39
EXTCHK_PATH	./include/types/checks.h	/^	EXTCHK_PATH = 0,$/;"	e	enum:__anon39
EXTCHK_SETENV	./src/checks.c	/^#define EXTCHK_SETENV(/;"	d	file:
EXTCHK_SIZE	./include/types/checks.h	/^	EXTCHK_SIZE$/;"	e	enum:__anon39
EXTCHK_SIZE_EVAL_INIT	./include/types/checks.h	/^#define EXTCHK_SIZE_EVAL_INIT /;"	d
EXTCHK_SIZE_ULONG	./include/types/checks.h	/^#define EXTCHK_SIZE_ULONG /;"	d
EXTRA	./Makefile	/^EXTRA =$/;"	m
FD_EV_ACTIVE	./include/types/fd.h	/^#define FD_EV_ACTIVE /;"	d
FD_EV_ACTIVE_R	./include/types/fd.h	/^#define FD_EV_ACTIVE_R /;"	d
FD_EV_ACTIVE_RW	./include/types/fd.h	/^#define FD_EV_ACTIVE_RW /;"	d
FD_EV_ACTIVE_W	./include/types/fd.h	/^#define FD_EV_ACTIVE_W /;"	d
FD_EV_POLLED	./include/types/fd.h	/^#define FD_EV_POLLED /;"	d
FD_EV_POLLED_R	./include/types/fd.h	/^#define FD_EV_POLLED_R /;"	d
FD_EV_POLLED_RW	./include/types/fd.h	/^#define FD_EV_POLLED_RW /;"	d
FD_EV_POLLED_W	./include/types/fd.h	/^#define FD_EV_POLLED_W /;"	d
FD_EV_READY	./include/types/fd.h	/^#define FD_EV_READY /;"	d
FD_EV_READY_R	./include/types/fd.h	/^#define FD_EV_READY_R /;"	d
FD_EV_READY_RW	./include/types/fd.h	/^#define FD_EV_READY_RW /;"	d
FD_EV_READY_W	./include/types/fd.h	/^#define FD_EV_READY_W /;"	d
FD_EV_STATUS	./include/types/fd.h	/^#define FD_EV_STATUS /;"	d
FD_EV_STATUS_R	./include/types/fd.h	/^#define FD_EV_STATUS_R /;"	d
FD_EV_STATUS_W	./include/types/fd.h	/^#define FD_EV_STATUS_W /;"	d
FD_POLL_DATA	./include/types/fd.h	/^#define FD_POLL_DATA /;"	d
FD_POLL_ERR	./include/types/fd.h	/^#define FD_POLL_ERR	/;"	d
FD_POLL_HUP	./include/types/fd.h	/^#define FD_POLL_HUP	/;"	d
FD_POLL_IN	./include/types/fd.h	/^#define FD_POLL_IN	/;"	d
FD_POLL_OUT	./include/types/fd.h	/^#define FD_POLL_OUT	/;"	d
FD_POLL_PRI	./include/types/fd.h	/^#define FD_POLL_PRI	/;"	d
FD_POLL_STICKY	./include/types/fd.h	/^#define FD_POLL_STICKY /;"	d
FD_SETS_ARE_BITFIELDS	./src/proto_http.c	/^#define FD_SETS_ARE_BITFIELDS$/;"	d	file:
FD_ST_ABORT	./include/types/fd.h	/^	FD_ST_ABORT,$/;"	e	enum:fd_states
FD_ST_ACTIVE	./include/types/fd.h	/^	FD_ST_ACTIVE,$/;"	e	enum:fd_states
FD_ST_DISABLED	./include/types/fd.h	/^	FD_ST_DISABLED = 0,$/;"	e	enum:fd_states
FD_ST_MUSTPOLL	./include/types/fd.h	/^	FD_ST_MUSTPOLL,$/;"	e	enum:fd_states
FD_ST_PAUSED	./include/types/fd.h	/^	FD_ST_PAUSED,$/;"	e	enum:fd_states
FD_ST_POLLED	./include/types/fd.h	/^	FD_ST_POLLED,$/;"	e	enum:fd_states
FD_ST_READY	./include/types/fd.h	/^	FD_ST_READY$/;"	e	enum:fd_states
FD_ST_STOPPED	./include/types/fd.h	/^	FD_ST_STOPPED,$/;"	e	enum:fd_states
FGETS2_BUFSIZE	./contrib/halog/fgets2.c	/^#define FGETS2_BUFSIZE	/;"	d	file:
FIELD_INDEX	./contrib/netsnmp-perl/haproxy.pl	/^use constant FIELD_INDEX => 10001;$/;"	c
FIELD_NAME	./contrib/netsnmp-perl/haproxy.pl	/^use constant FIELD_NAME => 10002;$/;"	c
FILT2_TIMESTAMP	./contrib/halog/halog.c	/^#define FILT2_TIMESTAMP	/;"	d	file:
FILT_ACC_COUNT	./contrib/halog/halog.c	/^#define FILT_ACC_COUNT	/;"	d	file:
FILT_ACC_DELAY	./contrib/halog/halog.c	/^#define FILT_ACC_DELAY	/;"	d	file:
FILT_COUNT_COOK_CODES	./contrib/halog/halog.c	/^#define FILT_COUNT_COOK_CODES /;"	d	file:
FILT_COUNT_IP_COUNT	./contrib/halog/halog.c	/^#define FILT_COUNT_IP_COUNT /;"	d	file:
FILT_COUNT_ONLY	./contrib/halog/halog.c	/^#define FILT_COUNT_ONLY	/;"	d	file:
FILT_COUNT_SRV_STATUS	./contrib/halog/halog.c	/^#define FILT_COUNT_SRV_STATUS /;"	d	file:
FILT_COUNT_STATUS	./contrib/halog/halog.c	/^#define FILT_COUNT_STATUS /;"	d	file:
FILT_COUNT_TERM_CODES	./contrib/halog/halog.c	/^#define FILT_COUNT_TERM_CODES /;"	d	file:
FILT_COUNT_URL_ANY	./contrib/halog/halog.c	/^#define FILT_COUNT_URL_ANY /;"	d	file:
FILT_COUNT_URL_BAVG	./contrib/halog/halog.c	/^#define FILT_COUNT_URL_BAVG /;"	d	file:
FILT_COUNT_URL_BTOT	./contrib/halog/halog.c	/^#define FILT_COUNT_URL_BTOT /;"	d	file:
FILT_COUNT_URL_COUNT	./contrib/halog/halog.c	/^#define FILT_COUNT_URL_COUNT /;"	d	file:
FILT_COUNT_URL_ERR	./contrib/halog/halog.c	/^#define FILT_COUNT_URL_ERR /;"	d	file:
FILT_COUNT_URL_ONLY	./contrib/halog/halog.c	/^#define FILT_COUNT_URL_ONLY /;"	d	file:
FILT_COUNT_URL_TAVG	./contrib/halog/halog.c	/^#define FILT_COUNT_URL_TAVG /;"	d	file:
FILT_COUNT_URL_TAVGO	./contrib/halog/halog.c	/^#define FILT_COUNT_URL_TAVGO /;"	d	file:
FILT_COUNT_URL_TTOT	./contrib/halog/halog.c	/^#define FILT_COUNT_URL_TTOT /;"	d	file:
FILT_COUNT_URL_TTOTO	./contrib/halog/halog.c	/^#define FILT_COUNT_URL_TTOTO /;"	d	file:
FILT_ERRORS_ONLY	./contrib/halog/halog.c	/^#define FILT_ERRORS_ONLY	/;"	d	file:
FILT_GRAPH_TIMERS	./contrib/halog/halog.c	/^#define FILT_GRAPH_TIMERS	/;"	d	file:
FILT_HTTP_ONLY	./contrib/halog/halog.c	/^#define FILT_HTTP_ONLY /;"	d	file:
FILT_HTTP_STATUS	./contrib/halog/halog.c	/^#define FILT_HTTP_STATUS /;"	d	file:
FILT_INVERT	./contrib/halog/halog.c	/^#define FILT_INVERT	/;"	d	file:
FILT_INVERT_ERRORS	./contrib/halog/halog.c	/^#define FILT_INVERT_ERRORS /;"	d	file:
FILT_INVERT_HTTP_STATUS	./contrib/halog/halog.c	/^#define FILT_INVERT_HTTP_STATUS /;"	d	file:
FILT_INVERT_TERM_CODE_NAME	./contrib/halog/halog.c	/^#define FILT_INVERT_TERM_CODE_NAME /;"	d	file:
FILT_INVERT_TIME_RESP	./contrib/halog/halog.c	/^#define FILT_INVERT_TIME_RESP /;"	d	file:
FILT_PERCENTILE	./contrib/halog/halog.c	/^#define FILT_PERCENTILE	/;"	d	file:
FILT_QUEUE_ONLY	./contrib/halog/halog.c	/^#define FILT_QUEUE_ONLY /;"	d	file:
FILT_QUEUE_SRV_ONLY	./contrib/halog/halog.c	/^#define FILT_QUEUE_SRV_ONLY /;"	d	file:
FILT_QUIET	./contrib/halog/halog.c	/^#define FILT_QUIET	/;"	d	file:
FILT_TERM_CODE_NAME	./contrib/halog/halog.c	/^#define FILT_TERM_CODE_NAME /;"	d	file:
FILT_TIME_RESP	./contrib/halog/halog.c	/^#define FILT_TIME_RESP /;"	d	file:
FNV_32_PRIME	./tests/test_hashes.c	/^#define FNV_32_PRIME /;"	d	file:
FORCE_INLINE	./src/xxhash.c	/^#    define FORCE_INLINE /;"	d	file:
FORCE_INLINE	./src/xxhash.c	/^#  define FORCE_INLINE /;"	d	file:
FREE	./include/common/config.h	/^#define FREE	/;"	d
FSM_PRINTF	./include/common/debug.h	/^#define FSM_PRINTF(/;"	d
F_SETPIPE_SZ	./include/common/compat.h	/^#define F_SETPIPE_SZ /;"	d
Fnv32_t	./tests/test_hashes.c	/^typedef unsigned long Fnv32_t;$/;"	t	file:
GCC_VERSION	./src/xxhash.c	/^#define GCC_VERSION /;"	d	file:
GTUNE_USE_EPOLL	./include/types/global.h	/^#define GTUNE_USE_EPOLL /;"	d
GTUNE_USE_GAI	./include/types/global.h	/^#define GTUNE_USE_GAI /;"	d
GTUNE_USE_KQUEUE	./include/types/global.h	/^#define GTUNE_USE_KQUEUE /;"	d
GTUNE_USE_POLL	./include/types/global.h	/^#define GTUNE_USE_POLL /;"	d
GTUNE_USE_SELECT	./include/types/global.h	/^#define GTUNE_USE_SELECT /;"	d
GTUNE_USE_SPLICE	./include/types/global.h	/^#define GTUNE_USE_SPLICE /;"	d
HANA_OBS_LAYER4	./include/types/checks.h	/^	HANA_OBS_LAYER4,		\/* Observe L4 - for example tcp *\/$/;"	e	enum:__anon44
HANA_OBS_LAYER7	./include/types/checks.h	/^	HANA_OBS_LAYER7,		\/* Observe L7 - for example http *\/$/;"	e	enum:__anon44
HANA_OBS_NONE	./include/types/checks.h	/^	HANA_OBS_NONE		= 0,$/;"	e	enum:__anon44
HANA_OBS_SIZE	./include/types/checks.h	/^	HANA_OBS_SIZE$/;"	e	enum:__anon44
HANA_ONERR_FAILCHK	./include/types/checks.h	/^	HANA_ONERR_FAILCHK,		\/* Simulate a failed check *\/$/;"	e	enum:__anon41
HANA_ONERR_FASTINTER	./include/types/checks.h	/^	HANA_ONERR_FASTINTER,		\/* Force fastinter*\/$/;"	e	enum:__anon41
HANA_ONERR_MARKDWN	./include/types/checks.h	/^	HANA_ONERR_MARKDWN,		\/* Mark this server down, now! *\/$/;"	e	enum:__anon41
HANA_ONERR_SUDDTH	./include/types/checks.h	/^	HANA_ONERR_SUDDTH,		\/* Enters sudden death - one more failed check will mark this server down *\/$/;"	e	enum:__anon41
HANA_ONERR_UNKNOWN	./include/types/checks.h	/^	HANA_ONERR_UNKNOWN	= 0,$/;"	e	enum:__anon41
HANA_ONMARKEDDOWN_NONE	./include/types/checks.h	/^	HANA_ONMARKEDDOWN_NONE	= 0,$/;"	e	enum:__anon42
HANA_ONMARKEDDOWN_SHUTDOWNSESSIONS	./include/types/checks.h	/^	HANA_ONMARKEDDOWN_SHUTDOWNSESSIONS,	\/* Shutdown peer sessions *\/$/;"	e	enum:__anon42
HANA_ONMARKEDUP_NONE	./include/types/checks.h	/^	HANA_ONMARKEDUP_NONE	= 0,$/;"	e	enum:__anon43
HANA_ONMARKEDUP_SHUTDOWNBACKUPSESSIONS	./include/types/checks.h	/^	HANA_ONMARKEDUP_SHUTDOWNBACKUPSESSIONS,	\/* Shutdown peer sessions *\/$/;"	e	enum:__anon43
HANA_STATUS_HTTP_BROKEN_PIPE	./include/types/checks.h	/^	HANA_STATUS_HTTP_BROKEN_PIPE,	\/* Unexpected close from server *\/$/;"	e	enum:__anon40
HANA_STATUS_HTTP_HDRRSP	./include/types/checks.h	/^	HANA_STATUS_HTTP_HDRRSP,	\/* Invalid http response (headers) *\/$/;"	e	enum:__anon40
HANA_STATUS_HTTP_OK	./include/types/checks.h	/^	HANA_STATUS_HTTP_OK,		\/* Correct http response *\/$/;"	e	enum:__anon40
HANA_STATUS_HTTP_READ_ERROR	./include/types/checks.h	/^	HANA_STATUS_HTTP_READ_ERROR,	\/* Read error *\/$/;"	e	enum:__anon40
HANA_STATUS_HTTP_READ_TIMEOUT	./include/types/checks.h	/^	HANA_STATUS_HTTP_READ_TIMEOUT,	\/* Read timeout *\/$/;"	e	enum:__anon40
HANA_STATUS_HTTP_RSP	./include/types/checks.h	/^	HANA_STATUS_HTTP_RSP,		\/* Invalid http response *\/$/;"	e	enum:__anon40
HANA_STATUS_HTTP_STS	./include/types/checks.h	/^	HANA_STATUS_HTTP_STS,		\/* Wrong http response, for example HTTP 5xx *\/$/;"	e	enum:__anon40
HANA_STATUS_L4_ERR	./include/types/checks.h	/^	HANA_STATUS_L4_ERR,		\/* L4 unsuccessful connection *\/$/;"	e	enum:__anon40
HANA_STATUS_L4_OK	./include/types/checks.h	/^	HANA_STATUS_L4_OK,		\/* L4 successful connection *\/$/;"	e	enum:__anon40
HANA_STATUS_SIZE	./include/types/checks.h	/^	HANA_STATUS_SIZE$/;"	e	enum:__anon40
HANA_STATUS_UNKNOWN	./include/types/checks.h	/^	HANA_STATUS_UNKNOWN	= 0,$/;"	e	enum:__anon40
HAPROXY_BACKENDS	./tests/test_hashes.c	/^#define HAPROXY_BACKENDS /;"	d	file:
HAPROXY_DATE	./include/common/version.h	/^#define HAPROXY_DATE /;"	d
HAPROXY_VERSION	./include/common/version.h	/^#define HAPROXY_VERSION /;"	d
HASHSIZE	./tests/test_hashes.c	/^#define HASHSIZE /;"	d	file:
HASH_FUNCT	./src/ssl_sock.c	/^#define HASH_FUNCT /;"	d	file:
HCHK_DESC_LEN	./include/common/defaults.h	/^#define HCHK_DESC_LEN	/;"	d
HCHK_STATUS_CHECKED	./include/types/checks.h	/^	HCHK_STATUS_CHECKED,		\/* DUMMY STATUS *\/$/;"	e	enum:__anon38
HCHK_STATUS_HANA	./include/types/checks.h	/^	HCHK_STATUS_HANA,		\/* Health analyze detected enough consecutive errors *\/$/;"	e	enum:__anon38
HCHK_STATUS_INI	./include/types/checks.h	/^	HCHK_STATUS_INI,		\/* Initializing *\/$/;"	e	enum:__anon38
HCHK_STATUS_L4CON	./include/types/checks.h	/^	HCHK_STATUS_L4CON,		\/* L4 connection problem, for example: *\/$/;"	e	enum:__anon38
HCHK_STATUS_L4OK	./include/types/checks.h	/^	HCHK_STATUS_L4OK,		\/* L4 check passed, for example tcp connect *\/$/;"	e	enum:__anon38
HCHK_STATUS_L4TOUT	./include/types/checks.h	/^	HCHK_STATUS_L4TOUT,		\/* L4 timeout *\/$/;"	e	enum:__anon38
HCHK_STATUS_L57DATA	./include/types/checks.h	/^	HCHK_STATUS_L57DATA,		\/* DUMMY STATUS *\/$/;"	e	enum:__anon38
HCHK_STATUS_L6OK	./include/types/checks.h	/^	HCHK_STATUS_L6OK,		\/* L6 check passed *\/$/;"	e	enum:__anon38
HCHK_STATUS_L6RSP	./include/types/checks.h	/^	HCHK_STATUS_L6RSP,		\/* L6 invalid response - protocol error *\/$/;"	e	enum:__anon38
HCHK_STATUS_L6TOUT	./include/types/checks.h	/^	HCHK_STATUS_L6TOUT,		\/* L6 (SSL) timeout *\/$/;"	e	enum:__anon38
HCHK_STATUS_L7OKCD	./include/types/checks.h	/^	HCHK_STATUS_L7OKCD,		\/* L7 check conditionally passed *\/$/;"	e	enum:__anon38
HCHK_STATUS_L7OKD	./include/types/checks.h	/^	HCHK_STATUS_L7OKD,		\/* L7 check passed *\/$/;"	e	enum:__anon38
HCHK_STATUS_L7RSP	./include/types/checks.h	/^	HCHK_STATUS_L7RSP,		\/* L7 invalid response - protocol error *\/$/;"	e	enum:__anon38
HCHK_STATUS_L7STS	./include/types/checks.h	/^	HCHK_STATUS_L7STS,		\/* L7 response error, for example HTTP 5xx *\/$/;"	e	enum:__anon38
HCHK_STATUS_L7TOUT	./include/types/checks.h	/^	HCHK_STATUS_L7TOUT,		\/* L7 (HTTP\/SMTP) timeout *\/$/;"	e	enum:__anon38
HCHK_STATUS_PROCERR	./include/types/checks.h	/^	HCHK_STATUS_PROCERR,		\/* External process check failure *\/$/;"	e	enum:__anon38
HCHK_STATUS_PROCOK	./include/types/checks.h	/^	HCHK_STATUS_PROCOK,		\/* External process check passed *\/$/;"	e	enum:__anon38
HCHK_STATUS_PROCTOUT	./include/types/checks.h	/^	HCHK_STATUS_PROCTOUT,		\/* External process check timeout *\/$/;"	e	enum:__anon38
HCHK_STATUS_SIZE	./include/types/checks.h	/^	HCHK_STATUS_SIZE$/;"	e	enum:__anon38
HCHK_STATUS_SOCKERR	./include/types/checks.h	/^	HCHK_STATUS_SOCKERR,		\/* Socket error *\/$/;"	e	enum:__anon38
HCHK_STATUS_START	./include/types/checks.h	/^	HCHK_STATUS_START,		\/* Check started - SPECIAL STATUS *\/$/;"	e	enum:__anon38
HCHK_STATUS_UNKNOWN	./include/types/checks.h	/^	HCHK_STATUS_UNKNOWN	 = 0,	\/* Unknown *\/$/;"	e	enum:__anon38
HLSR_READ_ALL	./src/hlua.c	/^#define HLSR_READ_ALL /;"	d	file:
HLSR_READ_LINE	./src/hlua.c	/^#define HLSR_READ_LINE /;"	d	file:
HLUA_CLR_CTRLYIELD	./include/proto/hlua.h	/^#define HLUA_CLR_CTRLYIELD(/;"	d
HLUA_CLR_RUN	./include/proto/hlua.h	/^#define HLUA_CLR_RUN(/;"	d
HLUA_CLR_WAKEREQWR	./include/proto/hlua.h	/^#define HLUA_CLR_WAKEREQWR(/;"	d
HLUA_CLR_WAKERESWR	./include/proto/hlua.h	/^#define HLUA_CLR_WAKERESWR(/;"	d
HLUA_CTRLYIELD	./include/types/hlua.h	/^#define HLUA_CTRLYIELD /;"	d
HLUA_EXIT	./include/types/hlua.h	/^#define HLUA_EXIT /;"	d
HLUA_E_AGAIN	./include/types/hlua.h	/^	HLUA_E_AGAIN,  \/* LUA yield, must resume the stack execution later, when$/;"	e	enum:hlua_exec
HLUA_E_ERR	./include/types/hlua.h	/^	HLUA_E_ERR,    \/* LUA stack execution failed without error message. *\/$/;"	e	enum:hlua_exec
HLUA_E_ERRMSG	./include/types/hlua.h	/^	HLUA_E_ERRMSG, \/* LUA stack execution failed with a string error message$/;"	e	enum:hlua_exec
HLUA_E_OK	./include/types/hlua.h	/^	HLUA_E_OK = 0,$/;"	e	enum:hlua_exec
HLUA_F_AS_STRING	./include/types/hlua.h	/^#define HLUA_F_AS_STRING /;"	d
HLUA_F_MAY_USE_HTTP	./include/types/hlua.h	/^#define HLUA_F_MAY_USE_HTTP /;"	d
HLUA_INIT	./include/proto/hlua.h	/^#define HLUA_INIT(/;"	d
HLUA_IS_CTRLYIELDING	./include/proto/hlua.h	/^#define HLUA_IS_CTRLYIELDING(/;"	d
HLUA_IS_RUNNING	./include/proto/hlua.h	/^#define HLUA_IS_RUNNING(/;"	d
HLUA_IS_WAKEREQWR	./include/proto/hlua.h	/^#define HLUA_IS_WAKEREQWR(/;"	d
HLUA_IS_WAKERESWR	./include/proto/hlua.h	/^#define HLUA_IS_WAKERESWR(/;"	d
HLUA_MUST_GC	./include/types/hlua.h	/^#define HLUA_MUST_GC /;"	d
HLUA_RUN	./include/types/hlua.h	/^#define HLUA_RUN /;"	d
HLUA_SET_CTRLYIELD	./include/proto/hlua.h	/^#define HLUA_SET_CTRLYIELD(/;"	d
HLUA_SET_RUN	./include/proto/hlua.h	/^#define HLUA_SET_RUN(/;"	d
HLUA_SET_WAKEREQWR	./include/proto/hlua.h	/^#define HLUA_SET_WAKEREQWR(/;"	d
HLUA_SET_WAKERESWR	./include/proto/hlua.h	/^#define HLUA_SET_WAKERESWR(/;"	d
HLUA_WAKEREQWR	./include/types/hlua.h	/^#define HLUA_WAKEREQWR /;"	d
HLUA_WAKERESWR	./include/types/hlua.h	/^#define HLUA_WAKERESWR /;"	d
HOUR	./include/common/standard.h	/^#define HOUR /;"	d
HTTP_100	./src/proto_http.c	/^const char HTTP_100[] =$/;"	v
HTTP_100C	./src/hlua.c	/^#define HTTP_100C /;"	d	file:
HTTP_301	./src/proto_http.c	/^const char *HTTP_301 =$/;"	v
HTTP_302	./src/proto_http.c	/^const char *HTTP_302 =$/;"	v
HTTP_303	./src/proto_http.c	/^const char *HTTP_303 =$/;"	v
HTTP_307	./src/proto_http.c	/^const char *HTTP_307 =$/;"	v
HTTP_308	./src/proto_http.c	/^const char *HTTP_308 =$/;"	v
HTTP_401_fmt	./src/proto_http.c	/^const char *HTTP_401_fmt =$/;"	v
HTTP_407_fmt	./src/proto_http.c	/^const char *HTTP_407_fmt =$/;"	v
HTTP_AUTH_BASIC	./include/types/proto_http.h	/^	HTTP_AUTH_BASIC,$/;"	e	enum:ht_auth_m
HTTP_AUTH_DIGEST	./include/types/proto_http.h	/^	HTTP_AUTH_DIGEST,$/;"	e	enum:ht_auth_m
HTTP_AUTH_UNKNOWN	./include/types/proto_http.h	/^	HTTP_AUTH_UNKNOWN	= 0,$/;"	e	enum:ht_auth_m
HTTP_AUTH_WRONG	./include/types/proto_http.h	/^	HTTP_AUTH_WRONG		= -1,		\/* missing or unknown *\/$/;"	e	enum:ht_auth_m
HTTP_ERR_200	./include/types/proto_http.h	/^	HTTP_ERR_200 = 0,$/;"	e	enum:__anon97
HTTP_ERR_400	./include/types/proto_http.h	/^	HTTP_ERR_400,$/;"	e	enum:__anon97
HTTP_ERR_403	./include/types/proto_http.h	/^	HTTP_ERR_403,$/;"	e	enum:__anon97
HTTP_ERR_405	./include/types/proto_http.h	/^	HTTP_ERR_405,$/;"	e	enum:__anon97
HTTP_ERR_408	./include/types/proto_http.h	/^	HTTP_ERR_408,$/;"	e	enum:__anon97
HTTP_ERR_429	./include/types/proto_http.h	/^	HTTP_ERR_429,$/;"	e	enum:__anon97
HTTP_ERR_500	./include/types/proto_http.h	/^	HTTP_ERR_500,$/;"	e	enum:__anon97
HTTP_ERR_502	./include/types/proto_http.h	/^	HTTP_ERR_502,$/;"	e	enum:__anon97
HTTP_ERR_503	./include/types/proto_http.h	/^	HTTP_ERR_503,$/;"	e	enum:__anon97
HTTP_ERR_504	./include/types/proto_http.h	/^	HTTP_ERR_504,$/;"	e	enum:__anon97
HTTP_ERR_SIZE	./include/types/proto_http.h	/^	HTTP_ERR_SIZE$/;"	e	enum:__anon97
HTTP_IS_CRLF	./include/proto/proto_http.h	/^#define HTTP_IS_CRLF(/;"	d
HTTP_IS_CTL	./include/proto/proto_http.h	/^#define HTTP_IS_CTL(/;"	d
HTTP_IS_LWS	./include/proto/proto_http.h	/^#define HTTP_IS_LWS(/;"	d
HTTP_IS_SEP	./include/proto/proto_http.h	/^#define HTTP_IS_SEP(/;"	d
HTTP_IS_SPHT	./include/proto/proto_http.h	/^#define HTTP_IS_SPHT(/;"	d
HTTP_IS_TOKEN	./include/proto/proto_http.h	/^#define HTTP_IS_TOKEN(/;"	d
HTTP_IS_VER_TOKEN	./include/proto/proto_http.h	/^#define HTTP_IS_VER_TOKEN(/;"	d
HTTP_METH_CONNECT	./include/types/sample.h	/^	HTTP_METH_CONNECT,$/;"	e	enum:http_meth_t
HTTP_METH_DELETE	./include/types/sample.h	/^	HTTP_METH_DELETE,$/;"	e	enum:http_meth_t
HTTP_METH_GET	./include/types/sample.h	/^	HTTP_METH_GET,$/;"	e	enum:http_meth_t
HTTP_METH_HEAD	./include/types/sample.h	/^	HTTP_METH_HEAD,$/;"	e	enum:http_meth_t
HTTP_METH_OPTIONS	./include/types/sample.h	/^	HTTP_METH_OPTIONS,$/;"	e	enum:http_meth_t
HTTP_METH_OTHER	./include/types/sample.h	/^	HTTP_METH_OTHER, \/* Must be the last entry *\/$/;"	e	enum:http_meth_t
HTTP_METH_POST	./include/types/sample.h	/^	HTTP_METH_POST,$/;"	e	enum:http_meth_t
HTTP_METH_PUT	./include/types/sample.h	/^	HTTP_METH_PUT,$/;"	e	enum:http_meth_t
HTTP_METH_TRACE	./include/types/sample.h	/^	HTTP_METH_TRACE,$/;"	e	enum:http_meth_t
HTTP_MSGF_CNT_LEN	./include/types/proto_http.h	/^#define HTTP_MSGF_CNT_LEN /;"	d
HTTP_MSGF_TE_CHNK	./include/types/proto_http.h	/^#define HTTP_MSGF_TE_CHNK /;"	d
HTTP_MSGF_VER_11	./include/types/proto_http.h	/^#define HTTP_MSGF_VER_11 /;"	d
HTTP_MSGF_WAIT_CONN	./include/types/proto_http.h	/^#define HTTP_MSGF_WAIT_CONN /;"	d
HTTP_MSGF_XFER_LEN	./include/types/proto_http.h	/^#define HTTP_MSGF_XFER_LEN /;"	d
HTTP_MSG_100_SENT	./include/types/proto_http.h	/^	HTTP_MSG_100_SENT     = 28, \/\/ parsing body after a 100-Continue was sent$/;"	e	enum:ht_state
HTTP_MSG_BODY	./include/types/proto_http.h	/^	HTTP_MSG_BODY         = 27, \/\/ parsing body at end of headers$/;"	e	enum:ht_state
HTTP_MSG_CHUNK_CRLF	./include/types/proto_http.h	/^	HTTP_MSG_CHUNK_CRLF   = 31, \/\/ skipping CRLF after data chunk$/;"	e	enum:ht_state
HTTP_MSG_CHUNK_SIZE	./include/types/proto_http.h	/^	HTTP_MSG_CHUNK_SIZE   = 29, \/\/ parsing the chunk size (RFC2616 #3.6.1)$/;"	e	enum:ht_state
HTTP_MSG_CLOSED	./include/types/proto_http.h	/^	HTTP_MSG_CLOSED       = 35, \/\/ shutdown_w done, all bytes sent$/;"	e	enum:ht_state
HTTP_MSG_CLOSING	./include/types/proto_http.h	/^	HTTP_MSG_CLOSING      = 34, \/\/ shutdown_w done, not all bytes sent yet$/;"	e	enum:ht_state
HTTP_MSG_DATA	./include/types/proto_http.h	/^	HTTP_MSG_DATA         = 30, \/\/ skipping data chunk \/ content-length data$/;"	e	enum:ht_state
HTTP_MSG_DONE	./include/types/proto_http.h	/^	HTTP_MSG_DONE         = 33, \/\/ message end received, waiting for resync or close$/;"	e	enum:ht_state
HTTP_MSG_ERROR	./include/types/proto_http.h	/^	HTTP_MSG_ERROR        = 26, \/\/ an error occurred$/;"	e	enum:ht_state
HTTP_MSG_HDR_COL	./include/types/proto_http.h	/^	HTTP_MSG_HDR_COL      = 18, \/\/ parsing header colon$/;"	e	enum:ht_state
HTTP_MSG_HDR_FIRST	./include/types/proto_http.h	/^	HTTP_MSG_HDR_FIRST    = 16, \/\/ waiting for first header or last CRLF (no LWS possible)$/;"	e	enum:ht_state
HTTP_MSG_HDR_L1_LF	./include/types/proto_http.h	/^	HTTP_MSG_HDR_L1_LF    = 20, \/\/ parsing header LWS (LF) before value$/;"	e	enum:ht_state
HTTP_MSG_HDR_L1_LWS	./include/types/proto_http.h	/^	HTTP_MSG_HDR_L1_LWS   = 21, \/\/ checking whether it's a new header or an LWS$/;"	e	enum:ht_state
HTTP_MSG_HDR_L1_SP	./include/types/proto_http.h	/^	HTTP_MSG_HDR_L1_SP    = 19, \/\/ parsing header LWS (SP|HT) before value$/;"	e	enum:ht_state
HTTP_MSG_HDR_L2_LF	./include/types/proto_http.h	/^	HTTP_MSG_HDR_L2_LF    = 23, \/\/ parsing header LWS (LF) inside\/after value$/;"	e	enum:ht_state
HTTP_MSG_HDR_L2_LWS	./include/types/proto_http.h	/^	HTTP_MSG_HDR_L2_LWS   = 24, \/\/ checking whether it's a new header or an LWS$/;"	e	enum:ht_state
HTTP_MSG_HDR_NAME	./include/types/proto_http.h	/^	HTTP_MSG_HDR_NAME     = 17, \/\/ parsing header name$/;"	e	enum:ht_state
HTTP_MSG_HDR_VAL	./include/types/proto_http.h	/^	HTTP_MSG_HDR_VAL      = 22, \/\/ parsing header value$/;"	e	enum:ht_state
HTTP_MSG_LAST_LF	./include/types/proto_http.h	/^	HTTP_MSG_LAST_LF      = 25, \/\/ parsing last LF$/;"	e	enum:ht_state
HTTP_MSG_RPBEFORE	./include/types/proto_http.h	/^	HTTP_MSG_RPBEFORE     =  8, \/\/ response: leading LF, before start line$/;"	e	enum:ht_state
HTTP_MSG_RPBEFORE_CR	./include/types/proto_http.h	/^	HTTP_MSG_RPBEFORE_CR  =  9, \/\/ response: leading CRLF, before start line$/;"	e	enum:ht_state
HTTP_MSG_RPCODE	./include/types/proto_http.h	/^	HTTP_MSG_RPCODE       = 12, \/\/ response code$/;"	e	enum:ht_state
HTTP_MSG_RPCODE_SP	./include/types/proto_http.h	/^	HTTP_MSG_RPCODE_SP    = 13, \/\/ space(s) after the response code$/;"	e	enum:ht_state
HTTP_MSG_RPLINE_END	./include/types/proto_http.h	/^	HTTP_MSG_RPLINE_END   = 15, \/\/ end of response line (CR or LF)$/;"	e	enum:ht_state
HTTP_MSG_RPREASON	./include/types/proto_http.h	/^	HTTP_MSG_RPREASON     = 14, \/\/ response reason$/;"	e	enum:ht_state
HTTP_MSG_RPVER	./include/types/proto_http.h	/^	HTTP_MSG_RPVER        = 10, \/\/ parsing the Response Version$/;"	e	enum:ht_state
HTTP_MSG_RPVER_SP	./include/types/proto_http.h	/^	HTTP_MSG_RPVER_SP     = 11, \/\/ space(s) after the Response Version$/;"	e	enum:ht_state
HTTP_MSG_RQBEFORE	./include/types/proto_http.h	/^	HTTP_MSG_RQBEFORE     =  0, \/\/ request: leading LF, before start line$/;"	e	enum:ht_state
HTTP_MSG_RQBEFORE_CR	./include/types/proto_http.h	/^	HTTP_MSG_RQBEFORE_CR  =  1, \/\/ request: leading CRLF, before start line$/;"	e	enum:ht_state
HTTP_MSG_RQLINE_END	./include/types/proto_http.h	/^	HTTP_MSG_RQLINE_END   =  7, \/\/ end of request line (CR or LF)$/;"	e	enum:ht_state
HTTP_MSG_RQMETH	./include/types/proto_http.h	/^	HTTP_MSG_RQMETH       =  2, \/\/ parsing the Method$/;"	e	enum:ht_state
HTTP_MSG_RQMETH_SP	./include/types/proto_http.h	/^	HTTP_MSG_RQMETH_SP    =  3, \/\/ space(s) after the Method$/;"	e	enum:ht_state
HTTP_MSG_RQURI	./include/types/proto_http.h	/^	HTTP_MSG_RQURI        =  4, \/\/ parsing the Request URI$/;"	e	enum:ht_state
HTTP_MSG_RQURI_SP	./include/types/proto_http.h	/^	HTTP_MSG_RQURI_SP     =  5, \/\/ space(s) after the Request URI$/;"	e	enum:ht_state
HTTP_MSG_RQVER	./include/types/proto_http.h	/^	HTTP_MSG_RQVER        =  6, \/\/ parsing the Request Version$/;"	e	enum:ht_state
HTTP_MSG_TRAILERS	./include/types/proto_http.h	/^	HTTP_MSG_TRAILERS     = 32, \/\/ trailers (post-data entity headers)$/;"	e	enum:ht_state
HTTP_MSG_TUNNEL	./include/types/proto_http.h	/^	HTTP_MSG_TUNNEL       = 36, \/\/ tunneled data after DONE$/;"	e	enum:ht_state
HTTP_RULE_RES_ABRT	./include/types/proto_http.h	/^	HTTP_RULE_RES_ABRT,      \/* abort request, msg already sent (eg: auth) *\/$/;"	e	enum:rule_result
HTTP_RULE_RES_BADREQ	./include/types/proto_http.h	/^	HTTP_RULE_RES_BADREQ,    \/* bad request *\/$/;"	e	enum:rule_result
HTTP_RULE_RES_CONT	./include/types/proto_http.h	/^	HTTP_RULE_RES_CONT = 0,  \/* nothing special, continue rules evaluation *\/$/;"	e	enum:rule_result
HTTP_RULE_RES_DENY	./include/types/proto_http.h	/^	HTTP_RULE_RES_DENY,      \/* deny (or tarpit if TX_CLTARPIT)  *\/$/;"	e	enum:rule_result
HTTP_RULE_RES_DONE	./include/types/proto_http.h	/^	HTTP_RULE_RES_DONE,      \/* processing done, stop processing (eg: redirect) *\/$/;"	e	enum:rule_result
HTTP_RULE_RES_STOP	./include/types/proto_http.h	/^	HTTP_RULE_RES_STOP,      \/* stopped processing on an accept *\/$/;"	e	enum:rule_result
HTTP_RULE_RES_YIELD	./include/types/proto_http.h	/^	HTTP_RULE_RES_YIELD,     \/* call me later because some data is missing. *\/$/;"	e	enum:rule_result
HiLink	./examples/haproxy.vim	/^	command -nargs=+ HiLink hi def link <args>$/;"	c
HiLink	./examples/haproxy.vim	/^	command -nargs=+ HiLink hi link <args>$/;"	c
I18NSPHINXOPTS	./doc/lua-api/Makefile	/^I18NSPHINXOPTS  = $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .$/;"	m
ILH	./include/common/mini-clist.h	/^#define ILH	/;"	d
IN6_IS_ADDR_V4MAPPED	./include/common/compat.h	/^#define IN6_IS_ADDR_V4MAPPED(/;"	d
INCLUDE	./contrib/halog/Makefile	/^INCLUDE  = -I..\/..\/include -I$(EBTREE_DIR)$/;"	m
IPV6_TRANSPARENT	./include/common/compat.h	/^#define IPV6_TRANSPARENT /;"	d
IP_FREEBIND	./include/common/compat.h	/^#define IP_FREEBIND /;"	d
IP_TRANSPARENT	./include/common/compat.h	/^#define IP_TRANSPARENT /;"	d
IT_ASCII	./src/sample.c	/^	IT_ASCII = 0,$/;"	e	enum:input_type	file:
IT_UTF8	./src/sample.c	/^	IT_UTF8,$/;"	e	enum:input_type	file:
IT_UTF8P	./src/sample.c	/^	IT_UTF8P,$/;"	e	enum:input_type	file:
IT_UTF8PS	./src/sample.c	/^	IT_UTF8PS,$/;"	e	enum:input_type	file:
IT_UTF8S	./src/sample.c	/^	IT_UTF8S,$/;"	e	enum:input_type	file:
KWM_DEF	./src/cfgparse.c	/^	KWM_DEF,      \/* "default" prefixed before the keyword *\/$/;"	e	enum:kw_mod	file:
KWM_NO	./src/cfgparse.c	/^	KWM_NO,       \/* "no" prefixed before the keyword *\/$/;"	e	enum:kw_mod	file:
KWM_STD	./src/cfgparse.c	/^	KWM_STD = 0,  \/* normal *\/$/;"	e	enum:kw_mod	file:
LBOUND	./include/common/standard.h	/^#define LBOUND(/;"	d
LB_MAP_RECALC	./include/types/lb_map.h	/^#define LB_MAP_RECALC /;"	d
LD	./Makefile	/^LD = $(CC)$/;"	m
LDFLAGS	./Makefile	/^LDFLAGS = $(ARCH_FLAGS) -g$/;"	m
LDFLAGS	./contrib/ip6range/Makefile	/^LDFLAGS  = -s$/;"	m
LDFLAGS	./contrib/iprange/Makefile	/^LDFLAGS  = -s$/;"	m
LDOPTS	./Makefile	/^LDOPTS = $(TARGET_LDFLAGS) $(OPTIONS_LDFLAGS) $(ADDLIB)$/;"	m
LF_EDARG	./include/types/log.h	/^	LF_EDARG,      \/\/ '}' after '%{'$/;"	e	enum:__anon81
LF_EDEXPR	./include/types/log.h	/^	LF_EDEXPR,     \/\/ ']' after '%['$/;"	e	enum:__anon81
LF_END	./include/types/log.h	/^	LF_END,        \/\/ \\0 found$/;"	e	enum:__anon81
LF_INIT	./include/types/log.h	/^	LF_INIT = 0,   \/\/ before first character$/;"	e	enum:__anon81
LF_SEPARATOR	./include/types/log.h	/^	LF_SEPARATOR,  \/\/ a single separator$/;"	e	enum:__anon81
LF_STARG	./include/types/log.h	/^	LF_STARG,      \/\/ after '%{' and berore '}'$/;"	e	enum:__anon81
LF_STARTVAR	./include/types/log.h	/^	LF_STARTVAR,   \/\/ % in text$/;"	e	enum:__anon81
LF_STEXPR	./include/types/log.h	/^	LF_STEXPR,     \/\/ after '%[' or '%{..}[' and berore ']'$/;"	e	enum:__anon81
LF_TEXT	./include/types/log.h	/^	LF_TEXT,       \/\/ normal text$/;"	e	enum:__anon81
LF_VAR	./include/types/log.h	/^	LF_VAR,        \/\/ variable name, after '%' or '%{..}'$/;"	e	enum:__anon81
LIB_EBTREE	./Makefile	/^LIB_EBTREE = $(EBTREE_DIR)\/libebtree.a$/;"	m
LIM2A	./include/common/standard.h	/^static inline const char *LIM2A(unsigned long n, const char *alt)$/;"	f
LINESIZE	./include/common/defaults.h	/^#define LINESIZE	/;"	d
LISTEN_DEFAULT_CIPHERS	./include/common/defaults.h	/^#define LISTEN_DEFAULT_CIPHERS /;"	d
LIST_ADD	./include/common/mini-clist.h	/^#define LIST_ADD(/;"	d
LIST_ADD	./src/lru.c	/^#define LIST_ADD(/;"	d	file:
LIST_ADDQ	./include/common/mini-clist.h	/^#define LIST_ADDQ(/;"	d
LIST_DEL	./include/common/mini-clist.h	/^#define LIST_DEL(/;"	d
LIST_DEL	./src/lru.c	/^#define LIST_DEL(/;"	d	file:
LIST_ELEM	./include/common/mini-clist.h	/^#define LIST_ELEM(/;"	d
LIST_HEAD	./include/common/mini-clist.h	/^#define LIST_HEAD(/;"	d
LIST_HEAD	./include/common/mini-clist.h	/^#undef LIST_HEAD$/;"	d
LIST_HEAD_INIT	./include/common/mini-clist.h	/^#define LIST_HEAD_INIT(/;"	d
LIST_INIT	./include/common/mini-clist.h	/^#define LIST_INIT(/;"	d
LIST_INIT	./include/common/mini-clist.h	/^#undef LIST_INIT$/;"	d
LIST_ISEMPTY	./include/common/mini-clist.h	/^#define LIST_ISEMPTY(/;"	d
LIST_NEXT	./include/common/mini-clist.h	/^#define LIST_NEXT(/;"	d
LIST_NEXT	./include/common/mini-clist.h	/^#undef LIST_NEXT$/;"	d
LIST_PREV	./include/common/mini-clist.h	/^#define LIST_PREV(/;"	d
LIST_PREV	./include/common/mini-clist.h	/^#undef LIST_PREV$/;"	d
LI_ASSIGNED	./include/types/listener.h	/^	LI_ASSIGNED,    \/* assigned to the protocol, but not listening yet *\/$/;"	e	enum:li_state
LI_FULL	./include/types/listener.h	/^	LI_FULL,        \/* reached its connection limit *\/$/;"	e	enum:li_state
LI_INIT	./include/types/listener.h	/^	LI_INIT,        \/* all parameters filled in, but not assigned yet *\/$/;"	e	enum:li_state
LI_LIMITED	./include/types/listener.h	/^	LI_LIMITED,     \/* transient state: limits have been reached, listener is queued *\/$/;"	e	enum:li_state
LI_LISTEN	./include/types/listener.h	/^	LI_LISTEN,      \/* started, listening but not enabled *\/$/;"	e	enum:li_state
LI_NEW	./include/types/listener.h	/^	LI_NEW	= 0,    \/* not initialized yet *\/$/;"	e	enum:li_state
LI_O_ACC_PROXY	./include/types/listener.h	/^#define LI_O_ACC_PROXY /;"	d
LI_O_CHK_MONNET	./include/types/listener.h	/^#define LI_O_CHK_MONNET /;"	d
LI_O_DEF_ACCEPT	./include/types/listener.h	/^#define LI_O_DEF_ACCEPT	/;"	d
LI_O_FOREIGN	./include/types/listener.h	/^#define LI_O_FOREIGN	/;"	d
LI_O_NOLINGER	./include/types/listener.h	/^#define LI_O_NOLINGER	/;"	d
LI_O_NONE	./include/types/listener.h	/^#define LI_O_NONE	/;"	d
LI_O_NOQUICKACK	./include/types/listener.h	/^#define LI_O_NOQUICKACK	/;"	d
LI_O_TCP_FO	./include/types/listener.h	/^#define LI_O_TCP_FO /;"	d
LI_O_TCP_RULES	./include/types/listener.h	/^#define LI_O_TCP_RULES /;"	d
LI_O_UNLIMITED	./include/types/listener.h	/^#define LI_O_UNLIMITED /;"	d
LI_O_V4V6	./include/types/listener.h	/^#define LI_O_V4V6 /;"	d
LI_O_V6ONLY	./include/types/listener.h	/^#define LI_O_V6ONLY /;"	d
LI_PAUSED	./include/types/listener.h	/^	LI_PAUSED,      \/* listener was paused, it's bound but not listening  *\/$/;"	e	enum:li_state
LI_READY	./include/types/listener.h	/^	LI_READY,       \/* started, listening and enabled *\/$/;"	e	enum:li_state
LLONG_MAX	./include/common/standard.h	/^# define LLONG_MAX /;"	d
LLONG_MIN	./include/common/standard.h	/^# define LLONG_MIN /;"	d
LOGCHAR	./src/log.c	/^#define LOGCHAR(/;"	d	file:
LOG_FMT_ACTCONN	./include/types/log.h	/^	LOG_FMT_ACTCONN,$/;"	e	enum:__anon80
LOG_FMT_BACKEND	./include/types/log.h	/^	LOG_FMT_BACKEND,$/;"	e	enum:__anon80
LOG_FMT_BACKENDIP	./include/types/log.h	/^	LOG_FMT_BACKENDIP,$/;"	e	enum:__anon80
LOG_FMT_BACKENDPORT	./include/types/log.h	/^	LOG_FMT_BACKENDPORT,$/;"	e	enum:__anon80
LOG_FMT_BCKQUEUE	./include/types/log.h	/^	LOG_FMT_BCKQUEUE,$/;"	e	enum:__anon80
LOG_FMT_BECONN	./include/types/log.h	/^	LOG_FMT_BECONN,$/;"	e	enum:__anon80
LOG_FMT_BYTES	./include/types/log.h	/^	LOG_FMT_BYTES,$/;"	e	enum:__anon80
LOG_FMT_BYTES_UP	./include/types/log.h	/^	LOG_FMT_BYTES_UP,$/;"	e	enum:__anon80
LOG_FMT_CCLIENT	./include/types/log.h	/^	LOG_FMT_CCLIENT,$/;"	e	enum:__anon80
LOG_FMT_CLIENTIP	./include/types/log.h	/^	LOG_FMT_CLIENTIP,$/;"	e	enum:__anon80
LOG_FMT_CLIENTPORT	./include/types/log.h	/^	LOG_FMT_CLIENTPORT,$/;"	e	enum:__anon80
LOG_FMT_CONN	./include/types/log.h	/^	LOG_FMT_CONN,$/;"	e	enum:__anon80
LOG_FMT_COUNTER	./include/types/log.h	/^	LOG_FMT_COUNTER,$/;"	e	enum:__anon80
LOG_FMT_CSERVER	./include/types/log.h	/^	LOG_FMT_CSERVER,$/;"	e	enum:__anon80
LOG_FMT_DATE	./include/types/log.h	/^	LOG_FMT_DATE,$/;"	e	enum:__anon80
LOG_FMT_DATEGMT	./include/types/log.h	/^	LOG_FMT_DATEGMT,$/;"	e	enum:__anon80
LOG_FMT_DATELOCAL	./include/types/log.h	/^	LOG_FMT_DATELOCAL,$/;"	e	enum:__anon80
LOG_FMT_EXPR	./include/types/log.h	/^	LOG_FMT_EXPR,     \/* sample expression *\/$/;"	e	enum:__anon80
LOG_FMT_FECONN	./include/types/log.h	/^	LOG_FMT_FECONN,$/;"	e	enum:__anon80
LOG_FMT_FRONTEND	./include/types/log.h	/^	LOG_FMT_FRONTEND,$/;"	e	enum:__anon80
LOG_FMT_FRONTENDIP	./include/types/log.h	/^	LOG_FMT_FRONTENDIP,$/;"	e	enum:__anon80
LOG_FMT_FRONTENDPORT	./include/types/log.h	/^	LOG_FMT_FRONTENDPORT,$/;"	e	enum:__anon80
LOG_FMT_FRONTEND_XPRT	./include/types/log.h	/^	LOG_FMT_FRONTEND_XPRT,$/;"	e	enum:__anon80
LOG_FMT_GLOBAL	./include/types/log.h	/^	LOG_FMT_GLOBAL,$/;"	e	enum:__anon80
LOG_FMT_HDRREQUEST	./include/types/log.h	/^	LOG_FMT_HDRREQUEST,$/;"	e	enum:__anon80
LOG_FMT_HDRREQUESTLIST	./include/types/log.h	/^	LOG_FMT_HDRREQUESTLIST,$/;"	e	enum:__anon80
LOG_FMT_HDRRESPONS	./include/types/log.h	/^	LOG_FMT_HDRRESPONS,$/;"	e	enum:__anon80
LOG_FMT_HDRRESPONSLIST	./include/types/log.h	/^	LOG_FMT_HDRRESPONSLIST,$/;"	e	enum:__anon80
LOG_FMT_HOSTNAME	./include/types/log.h	/^	LOG_FMT_HOSTNAME,$/;"	e	enum:__anon80
LOG_FMT_HTTP_METHOD	./include/types/log.h	/^	LOG_FMT_HTTP_METHOD,$/;"	e	enum:__anon80
LOG_FMT_HTTP_PATH	./include/types/log.h	/^	LOG_FMT_HTTP_PATH,$/;"	e	enum:__anon80
LOG_FMT_HTTP_QUERY	./include/types/log.h	/^	LOG_FMT_HTTP_QUERY,$/;"	e	enum:__anon80
LOG_FMT_HTTP_URI	./include/types/log.h	/^	LOG_FMT_HTTP_URI,$/;"	e	enum:__anon80
LOG_FMT_HTTP_VERSION	./include/types/log.h	/^	LOG_FMT_HTTP_VERSION,$/;"	e	enum:__anon80
LOG_FMT_LOGCNT	./include/types/log.h	/^	LOG_FMT_LOGCNT,$/;"	e	enum:__anon80
LOG_FMT_MS	./include/types/log.h	/^	LOG_FMT_MS,$/;"	e	enum:__anon80
LOG_FMT_PID	./include/types/log.h	/^	LOG_FMT_PID,$/;"	e	enum:__anon80
LOG_FMT_QUEUES	./include/types/log.h	/^	LOG_FMT_QUEUES,$/;"	e	enum:__anon80
LOG_FMT_REQ	./include/types/log.h	/^	LOG_FMT_REQ,$/;"	e	enum:__anon80
LOG_FMT_RETRIES	./include/types/log.h	/^	LOG_FMT_RETRIES,$/;"	e	enum:__anon80
LOG_FMT_SEPARATOR	./include/types/log.h	/^	LOG_FMT_SEPARATOR, \/* separator replaced by one space *\/$/;"	e	enum:__anon80
LOG_FMT_SERVER	./include/types/log.h	/^	LOG_FMT_SERVER,$/;"	e	enum:__anon80
LOG_FMT_SERVERIP	./include/types/log.h	/^	LOG_FMT_SERVERIP,$/;"	e	enum:__anon80
LOG_FMT_SERVERPORT	./include/types/log.h	/^	LOG_FMT_SERVERPORT,$/;"	e	enum:__anon80
LOG_FMT_SRVCONN	./include/types/log.h	/^	LOG_FMT_SRVCONN,$/;"	e	enum:__anon80
LOG_FMT_SRVQUEUE	./include/types/log.h	/^	LOG_FMT_SRVQUEUE,$/;"	e	enum:__anon80
LOG_FMT_SSL_CIPHER	./include/types/log.h	/^	LOG_FMT_SSL_CIPHER,$/;"	e	enum:__anon80
LOG_FMT_SSL_VERSION	./include/types/log.h	/^	LOG_FMT_SSL_VERSION,$/;"	e	enum:__anon80
LOG_FMT_STATUS	./include/types/log.h	/^	LOG_FMT_STATUS,$/;"	e	enum:__anon80
LOG_FMT_T	./include/types/log.h	/^	LOG_FMT_T,$/;"	e	enum:__anon80
LOG_FMT_TC	./include/types/log.h	/^	LOG_FMT_TC,$/;"	e	enum:__anon80
LOG_FMT_TERMSTATE	./include/types/log.h	/^	LOG_FMT_TERMSTATE,$/;"	e	enum:__anon80
LOG_FMT_TERMSTATE_CK	./include/types/log.h	/^	LOG_FMT_TERMSTATE_CK,$/;"	e	enum:__anon80
LOG_FMT_TEXT	./include/types/log.h	/^	LOG_FMT_TEXT = 0, \/* raw text *\/$/;"	e	enum:__anon80
LOG_FMT_TQ	./include/types/log.h	/^	LOG_FMT_TQ,$/;"	e	enum:__anon80
LOG_FMT_TR	./include/types/log.h	/^	LOG_FMT_TR,$/;"	e	enum:__anon80
LOG_FMT_TS	./include/types/log.h	/^	LOG_FMT_TS,$/;"	e	enum:__anon80
LOG_FMT_TT	./include/types/log.h	/^	LOG_FMT_TT,$/;"	e	enum:__anon80
LOG_FMT_TW	./include/types/log.h	/^	LOG_FMT_TW,$/;"	e	enum:__anon80
LOG_FMT_UNIQUEID	./include/types/log.h	/^	LOG_FMT_UNIQUEID,$/;"	e	enum:__anon80
LOG_FMT_VARIABLE	./include/types/log.h	/^	LOG_FMT_VARIABLE,$/;"	e	enum:__anon80
LOG_FORMATS	./include/types/log.h	/^	LOG_FORMATS,          \/* number of supported log formats, must always be last *\/$/;"	e	enum:__anon79
LOG_FORMAT_RFC3164	./include/types/log.h	/^	LOG_FORMAT_RFC3164 = 0,$/;"	e	enum:__anon79
LOG_FORMAT_RFC5424	./include/types/log.h	/^	LOG_FORMAT_RFC5424,$/;"	e	enum:__anon79
LOG_OPT_HEXA	./include/types/log.h	/^#define LOG_OPT_HEXA	/;"	d
LOG_OPT_HTTP	./include/types/log.h	/^#define LOG_OPT_HTTP /;"	d
LOG_OPT_MANDATORY	./include/types/log.h	/^#define LOG_OPT_MANDATORY	/;"	d
LOG_OPT_QUOTE	./include/types/log.h	/^#define LOG_OPT_QUOTE	/;"	d
LOG_OPT_REQ_CAP	./include/types/log.h	/^#define LOG_OPT_REQ_CAP /;"	d
LOG_OPT_RES_CAP	./include/types/log.h	/^#define LOG_OPT_RES_CAP /;"	d
LONGBITS	./include/common/standard.h	/^#define LONGBITS /;"	d
LSTCHK_CAP_BIND	./include/types/global.h	/^#define LSTCHK_CAP_BIND	/;"	d
LSTCHK_NETADM	./include/types/global.h	/^#define LSTCHK_NETADM	/;"	d
LUA_LD_FLAGS	./Makefile	/^LUA_LD_FLAGS := $(if $(LUA_LIB),-L$(LUA_LIB))$/;"	m
LUA_LIB_NAME	./Makefile	/^LUA_LIB_NAME := $(firstword $(foreach lib,lua5.3 lua53 lua,$(call check_lua_lib,$(lib),$(LUA_LD_FLAGS))))$/;"	m
LW_BCKIP	./include/types/log.h	/^#define LW_BCKIP	/;"	d
LW_BYTES	./include/types/log.h	/^#define LW_BYTES	/;"	d
LW_CLIP	./include/types/log.h	/^#define LW_CLIP	/;"	d
LW_COOKIE	./include/types/log.h	/^#define LW_COOKIE	/;"	d
LW_FRTIP	./include/types/log.h	/^#define LW_FRTIP /;"	d
LW_INIT	./include/types/log.h	/^#define LW_INIT	/;"	d
LW_REQ	./include/types/log.h	/^#define	LW_REQ	/;"	d
LW_REQHDR	./include/types/log.h	/^#define LW_REQHDR	/;"	d
LW_RESP	./include/types/log.h	/^#define LW_RESP	/;"	d
LW_RSPHDR	./include/types/log.h	/^#define LW_RSPHDR	/;"	d
LW_SVID	./include/types/log.h	/^#define LW_SVID	/;"	d
LW_SVIP	./include/types/log.h	/^#define LW_SVIP	/;"	d
LW_XPRT	./include/types/log.h	/^#define LW_XPRT	/;"	d
MALLOC	./include/common/config.h	/^#define MALLOC	/;"	d
MANDIR	./Makefile	/^MANDIR = $(PREFIX)\/share\/man$/;"	m
MAX	./include/common/tools.h	/^#define MAX(/;"	d
MAXLINE	./contrib/halog/halog.c	/^#define MAXLINE /;"	d	file:
MAXLINE	./contrib/ip6range/ip6range.c	/^#define MAXLINE /;"	d	file:
MAXLINE	./contrib/iprange/iprange.c	/^#define MAXLINE /;"	d	file:
MAXLINE	./tests/ip-hash.c	/^#define MAXLINE /;"	d	file:
MAXLINE	./tests/uri_hash.c	/^#define MAXLINE /;"	d	file:
MAXPATHLEN	./include/common/compat.h	/^#define MAXPATHLEN /;"	d
MAXREWRITE	./include/common/defaults.h	/^#define MAXREWRITE /;"	d
MAX_DELAY_MS	./include/common/time.h	/^#define MAX_DELAY_MS /;"	d
MAX_HDR_HISTORY	./include/common/defaults.h	/^#define MAX_HDR_HISTORY /;"	d
MAX_HOSTNAME_LEN	./include/common/defaults.h	/^#define MAX_HOSTNAME_LEN	/;"	d
MAX_HTTP_HDR	./include/common/defaults.h	/^#define MAX_HTTP_HDR /;"	d
MAX_LINE_ARGS	./include/common/defaults.h	/^#define MAX_LINE_ARGS /;"	d
MAX_MATCH	./include/common/defaults.h	/^#define	MAX_MATCH /;"	d
MAX_POLLERS	./include/types/fd.h	/^#define MAX_POLLERS	/;"	d
MAX_POLL_EVENTS	./include/common/defaults.h	/^#define MAX_POLL_EVENTS /;"	d
MAX_RANGE	./include/common/tools.h	/^#define MAX_RANGE(/;"	d
MAX_READ_POLL_LOOPS	./include/common/defaults.h	/^#define MAX_READ_POLL_LOOPS /;"	d
MAX_SESS_STKCTR	./include/common/defaults.h	/^#define MAX_SESS_STKCTR /;"	d
MAX_SIGNAL	./include/common/defaults.h	/^#define MAX_SIGNAL /;"	d
MAX_SPLICE_AT_ONCE	./src/raw_sock.c	/^#define MAX_SPLICE_AT_ONCE	/;"	d	file:
MAX_START_RETRIES	./src/haproxy.c	/^#define MAX_START_RETRIES	/;"	d	file:
MAX_STATS_ARGS	./include/common/defaults.h	/^#define MAX_STATS_ARGS /;"	d
MAX_SYSLOG_LEN	./include/common/defaults.h	/^#define MAX_SYSLOG_LEN /;"	d
MAY_LJMP	./src/hlua.c	/^#define MAY_LJMP(/;"	d	file:
MEM_F_SHARED	./include/common/memory.h	/^#define MEM_F_SHARED	/;"	d
MEM_USABLE_RATIO	./include/common/defaults.h	/^#define MEM_USABLE_RATIO /;"	d
METH_FIELD	./contrib/halog/halog.c	/^#define METH_FIELD /;"	d	file:
MID_RANGE	./include/common/tools.h	/^#define MID_RANGE(/;"	d
MIN	./include/common/tools.h	/^#define MIN(/;"	d
MINTIME	./include/common/time.h	/^#define MINTIME(/;"	d
MINUTE	./include/common/standard.h	/^#define MINUTE /;"	d
MIN_RECV_AT_ONCE_ENOUGH	./include/common/defaults.h	/^#define MIN_RECV_AT_ONCE_ENOUGH /;"	d
MIN_SPLICE_FORWARD	./include/common/defaults.h	/^#define MIN_SPLICE_FORWARD /;"	d
MODE_CHECK	./include/types/global.h	/^#define	MODE_CHECK	/;"	d
MODE_DAEMON	./include/types/global.h	/^#define	MODE_DAEMON	/;"	d
MODE_DEBUG	./include/types/global.h	/^#define	MODE_DEBUG	/;"	d
MODE_FOREGROUND	./include/types/global.h	/^#define	MODE_FOREGROUND	/;"	d
MODE_QUIET	./include/types/global.h	/^#define	MODE_QUIET	/;"	d
MODE_STARTING	./include/types/global.h	/^#define	MODE_STARTING	/;"	d
MODE_SYSTEMD	./include/types/global.h	/^#define	MODE_SYSTEMD	/;"	d
MODE_VERBOSE	./include/types/global.h	/^#define	MODE_VERBOSE	/;"	d
MSG_DONTWAIT	./include/common/compat.h	/^#define MSG_DONTWAIT	/;"	d
MSG_MORE	./include/common/compat.h	/^#define MSG_MORE	/;"	d
MSG_NOSIGNAL	./include/common/compat.h	/^#define MSG_NOSIGNAL	/;"	d
MSG_TRUNC_CLEARS_INPUT	./include/common/compat.h	/^#define MSG_TRUNC_CLEARS_INPUT$/;"	d
MS_TO_TICKS	./include/common/ticks.h	/^#define MS_TO_TICKS(/;"	d
Mref	./include/types/hlua.h	/^	int Mref; \/* The reference of the memory context in coroutine case.$/;"	m	struct:hlua
MyPackage	./examples/check	/^package MyPackage;$/;"	p
NB_ITOA_STR	./include/common/standard.h	/^#define NB_ITOA_STR	/;"	d
NB_LLMAX_STR	./include/common/standard.h	/^#define NB_LLMAX_STR /;"	d
NB_LOG_FACILITIES	./include/types/log.h	/^#define NB_LOG_FACILITIES /;"	d
NB_LOG_LEVELS	./include/types/log.h	/^#define NB_LOG_LEVELS /;"	d
NB_MSG_IOVEC_ELEMENTS	./include/types/log.h	/^#define NB_MSG_IOVEC_ELEMENTS /;"	d
NB_QSTR	./include/common/standard.h	/^#define NB_QSTR /;"	d
NSERV	./tests/ip-hash.c	/^#define NSERV /;"	d	file:
NSERV	./tests/uri_hash.c	/^#define NSERV /;"	d	file:
OBJS	./Makefile	/^OBJS = src\/haproxy.o src\/base64.o src\/protocol.o \\$/;"	m
OBJS	./contrib/halog/Makefile	/^OBJS     = halog$/;"	m
OBJS	./contrib/ip6range/Makefile	/^OBJS     = ip6range$/;"	m
OBJS	./contrib/iprange/Makefile	/^OBJS     = iprange$/;"	m
OBJ_TYPE_APPCTX	./include/types/obj_type.h	/^	OBJ_TYPE_APPCTX,       \/* object is a struct appctx *\/$/;"	e	enum:obj_type
OBJ_TYPE_APPLET	./include/types/obj_type.h	/^	OBJ_TYPE_APPLET,       \/* object is a struct applet *\/$/;"	e	enum:obj_type
OBJ_TYPE_CONN	./include/types/obj_type.h	/^	OBJ_TYPE_CONN,         \/* object is a struct connection *\/$/;"	e	enum:obj_type
OBJ_TYPE_ENTRIES	./include/types/obj_type.h	/^	OBJ_TYPE_ENTRIES       \/* last one : number of entries *\/$/;"	e	enum:obj_type
OBJ_TYPE_LISTENER	./include/types/obj_type.h	/^	OBJ_TYPE_LISTENER,     \/* object is a struct listener *\/$/;"	e	enum:obj_type
OBJ_TYPE_NONE	./include/types/obj_type.h	/^	OBJ_TYPE_NONE = 0,     \/* pointer is NULL by definition *\/$/;"	e	enum:obj_type
OBJ_TYPE_PROXY	./include/types/obj_type.h	/^	OBJ_TYPE_PROXY,        \/* object is a struct proxy *\/$/;"	e	enum:obj_type
OBJ_TYPE_SERVER	./include/types/obj_type.h	/^	OBJ_TYPE_SERVER,       \/* object is a struct server *\/$/;"	e	enum:obj_type
OCSP_MAX_CERTID_ASN1_LENGTH	./include/common/defaults.h	/^#define OCSP_MAX_CERTID_ASN1_LENGTH /;"	d
OCSP_MAX_RESPONSE_TIME_SKEW	./include/common/defaults.h	/^#define OCSP_MAX_RESPONSE_TIME_SKEW /;"	d
OID_HAPROXY	./contrib/netsnmp-perl/haproxy.pl	/^use constant OID_HAPROXY => '1.3.6.1.4.1.29385.106';$/;"	c
OID_HAPROXY_INFO	./contrib/netsnmp-perl/haproxy.pl	/^use constant OID_HAPROXY_INFO => OID_HAPROXY . '.2';$/;"	c
OID_HAPROXY_STATS	./contrib/netsnmp-perl/haproxy.pl	/^use constant OID_HAPROXY_STATS => OID_HAPROXY . '.1';$/;"	c
OPTIMIZE	./contrib/halog/Makefile	/^OPTIMIZE = -O3$/;"	m
OPTIMIZE	./contrib/ip6range/Makefile	/^OPTIMIZE = -O3$/;"	m
OPTIMIZE	./contrib/iprange/Makefile	/^OPTIMIZE = -O3$/;"	m
OPTIONS_CFLAGS	./Makefile	/^OPTIONS_CFLAGS  =$/;"	m
OPTIONS_LDFLAGS	./Makefile	/^OPTIONS_LDFLAGS =$/;"	m
OPTIONS_OBJS	./Makefile	/^OPTIONS_OBJS    =$/;"	m
PAPER	./doc/lua-api/Makefile	/^PAPER         =$/;"	m
PAPEROPT_a4	./doc/lua-api/Makefile	/^PAPEROPT_a4     = -D latex_paper_size=a4$/;"	m
PAPEROPT_letter	./doc/lua-api/Makefile	/^PAPEROPT_letter = -D latex_paper_size=letter$/;"	m
PAT_MATCH	./include/types/pattern.h	/^	PAT_MATCH = 3,           \/* sample matched at least one pattern *\/$/;"	e	enum:pat_match_res
PAT_MATCH_BEG	./include/types/pattern.h	/^	PAT_MATCH_BEG,   \/* beginning of string (str) *\/$/;"	e	enum:__anon86
PAT_MATCH_BIN	./include/types/pattern.h	/^	PAT_MATCH_BIN,   \/* hex string (bin) *\/$/;"	e	enum:__anon86
PAT_MATCH_BOOL	./include/types/pattern.h	/^	PAT_MATCH_BOOL,  \/* match fetch's integer value as boolean *\/$/;"	e	enum:__anon86
PAT_MATCH_DIR	./include/types/pattern.h	/^	PAT_MATCH_DIR,   \/* directory-like sub-string (str) *\/$/;"	e	enum:__anon86
PAT_MATCH_DOM	./include/types/pattern.h	/^	PAT_MATCH_DOM,   \/* domain-like sub-string (str) *\/$/;"	e	enum:__anon86
PAT_MATCH_END	./include/types/pattern.h	/^	PAT_MATCH_END,   \/* end of string (str) *\/$/;"	e	enum:__anon86
PAT_MATCH_FOUND	./include/types/pattern.h	/^	PAT_MATCH_FOUND, \/* just ensure that fetch found the sample *\/$/;"	e	enum:__anon86
PAT_MATCH_INT	./include/types/pattern.h	/^	PAT_MATCH_INT,   \/* unsigned integer (int) *\/$/;"	e	enum:__anon86
PAT_MATCH_IP	./include/types/pattern.h	/^	PAT_MATCH_IP,    \/* IPv4\/IPv6 address (IP) *\/$/;"	e	enum:__anon86
PAT_MATCH_LEN	./include/types/pattern.h	/^	PAT_MATCH_LEN,   \/* string length (str -> int) *\/$/;"	e	enum:__anon86
PAT_MATCH_NUM	./include/types/pattern.h	/^	PAT_MATCH_NUM$/;"	e	enum:__anon86
PAT_MATCH_REG	./include/types/pattern.h	/^	PAT_MATCH_REG,   \/* regex (str -> reg) *\/$/;"	e	enum:__anon86
PAT_MATCH_STR	./include/types/pattern.h	/^	PAT_MATCH_STR,   \/* exact string match (str) *\/$/;"	e	enum:__anon86
PAT_MATCH_SUB	./include/types/pattern.h	/^	PAT_MATCH_SUB,   \/* substring (str) *\/$/;"	e	enum:__anon86
PAT_MF_IGNORE_CASE	./include/types/pattern.h	/^	PAT_MF_IGNORE_CASE = 1 << 0,       \/* ignore case *\/$/;"	e	enum:__anon84
PAT_MF_NO_DNS	./include/types/pattern.h	/^	PAT_MF_NO_DNS      = 1 << 1,       \/* dont perform any DNS requests *\/$/;"	e	enum:__anon84
PAT_NOMATCH	./include/types/pattern.h	/^	PAT_NOMATCH = 0,         \/* sample didn't match any pattern *\/$/;"	e	enum:pat_match_res
PAT_REF_ACL	./include/types/pattern.h	/^#define PAT_REF_ACL /;"	d
PAT_REF_MAP	./include/types/pattern.h	/^#define PAT_REF_MAP /;"	d
PAT_REF_SMP	./include/types/pattern.h	/^#define PAT_REF_SMP /;"	d
PAT_SF_TREE	./include/types/pattern.h	/^	PAT_SF_TREE        = 1 << 0,       \/* some patterns are arranged in a tree *\/$/;"	e	enum:__anon85
PCREDIR	./Makefile	/^PCREDIR	        := $(shell pcre-config --prefix 2>\/dev\/null || echo \/usr\/local)$/;"	m
PCRE_INC	./Makefile	/^PCRE_INC        := $(PCREDIR)\/include$/;"	m
PCRE_LIB	./Makefile	/^PCRE_LIB        := $(PCREDIR)\/lib$/;"	m
PCRE_STUDY_JIT_COMPILE	./include/common/regex.h	/^#define PCRE_STUDY_JIT_COMPILE /;"	d
PEERS_F_DONOTSTOP	./src/peers.c	/^#define	PEERS_F_DONOTSTOP	/;"	d	file:
PEERS_F_RESYNC_ASSIGN	./src/peers.c	/^#define	PEERS_F_RESYNC_ASSIGN	/;"	d	file:
PEERS_F_RESYNC_LOCAL	./src/peers.c	/^#define	PEERS_F_RESYNC_LOCAL	/;"	d	file:
PEERS_F_RESYNC_PROCESS	./src/peers.c	/^#define	PEERS_F_RESYNC_PROCESS	/;"	d	file:
PEERS_F_RESYNC_REMOTE	./src/peers.c	/^#define	PEERS_F_RESYNC_REMOTE	/;"	d	file:
PEERS_RESYNC_FINISHED	./src/peers.c	/^#define	PEERS_RESYNC_FINISHED	/;"	d	file:
PEERS_RESYNC_FROMLOCAL	./src/peers.c	/^#define	PEERS_RESYNC_FROMLOCAL	/;"	d	file:
PEERS_RESYNC_FROMREMOTE	./src/peers.c	/^#define	PEERS_RESYNC_FROMREMOTE	/;"	d	file:
PEERS_RESYNC_STATEMASK	./src/peers.c	/^#define	PEERS_RESYNC_STATEMASK	/;"	d	file:
PEER_F_LEARN_ASSIGN	./src/peers.c	/^#define	PEER_F_LEARN_ASSIGN	/;"	d	file:
PEER_F_LEARN_NOTUP2DATE	./src/peers.c	/^#define	PEER_F_LEARN_NOTUP2DATE	/;"	d	file:
PEER_F_TEACH_COMPLETE	./src/peers.c	/^#define	PEER_F_TEACH_COMPLETE	/;"	d	file:
PEER_F_TEACH_FINISHED	./src/peers.c	/^#define	PEER_F_TEACH_FINISHED	/;"	d	file:
PEER_F_TEACH_PROCESS	./src/peers.c	/^#define	PEER_F_TEACH_PROCESS	/;"	d	file:
PEER_LEARN_RESET	./src/peers.c	/^#define	PEER_LEARN_RESET	/;"	d	file:
PEER_MSG_CLASS_CONTROL	./src/peers.c	/^	PEER_MSG_CLASS_CONTROL = 0,$/;"	e	enum:__anon139	file:
PEER_MSG_CLASS_ERROR	./src/peers.c	/^	PEER_MSG_CLASS_ERROR,$/;"	e	enum:__anon139	file:
PEER_MSG_CLASS_RESERVED	./src/peers.c	/^	PEER_MSG_CLASS_RESERVED = 255,$/;"	e	enum:__anon139	file:
PEER_MSG_CLASS_STICKTABLE	./src/peers.c	/^	PEER_MSG_CLASS_STICKTABLE = 10,$/;"	e	enum:__anon139	file:
PEER_MSG_CTRL_RESYNCCONFIRM	./src/peers.c	/^	PEER_MSG_CTRL_RESYNCCONFIRM,$/;"	e	enum:__anon140	file:
PEER_MSG_CTRL_RESYNCFINISHED	./src/peers.c	/^	PEER_MSG_CTRL_RESYNCFINISHED,$/;"	e	enum:__anon140	file:
PEER_MSG_CTRL_RESYNCPARTIAL	./src/peers.c	/^	PEER_MSG_CTRL_RESYNCPARTIAL,$/;"	e	enum:__anon140	file:
PEER_MSG_CTRL_RESYNCREQ	./src/peers.c	/^	PEER_MSG_CTRL_RESYNCREQ = 0,$/;"	e	enum:__anon140	file:
PEER_MSG_ERR_PROTOCOL	./src/peers.c	/^	PEER_MSG_ERR_PROTOCOL = 0,$/;"	e	enum:__anon141	file:
PEER_MSG_ERR_SIZELIMIT	./src/peers.c	/^	PEER_MSG_ERR_SIZELIMIT,$/;"	e	enum:__anon141	file:
PEER_MSG_STKT_ACK	./src/peers.c	/^	PEER_MSG_STKT_ACK,$/;"	e	enum:__anon142	file:
PEER_MSG_STKT_DEFINE	./src/peers.c	/^	PEER_MSG_STKT_DEFINE,$/;"	e	enum:__anon142	file:
PEER_MSG_STKT_INCUPDATE	./src/peers.c	/^	PEER_MSG_STKT_INCUPDATE,$/;"	e	enum:__anon142	file:
PEER_MSG_STKT_SWITCH	./src/peers.c	/^	PEER_MSG_STKT_SWITCH,$/;"	e	enum:__anon142	file:
PEER_MSG_STKT_UPDATE	./src/peers.c	/^	PEER_MSG_STKT_UPDATE = 128,$/;"	e	enum:__anon142	file:
PEER_SESSION_PROTO_NAME	./src/peers.c	/^#define PEER_SESSION_PROTO_NAME /;"	d	file:
PEER_SESS_SC_CONNECTCODE	./src/peers.c	/^#define	PEER_SESS_SC_CONNECTCODE	/;"	d	file:
PEER_SESS_SC_CONNECTEDCODE	./src/peers.c	/^#define	PEER_SESS_SC_CONNECTEDCODE	/;"	d	file:
PEER_SESS_SC_ERRHOST	./src/peers.c	/^#define	PEER_SESS_SC_ERRHOST	/;"	d	file:
PEER_SESS_SC_ERRPEER	./src/peers.c	/^#define	PEER_SESS_SC_ERRPEER	/;"	d	file:
PEER_SESS_SC_ERRPROTO	./src/peers.c	/^#define	PEER_SESS_SC_ERRPROTO	/;"	d	file:
PEER_SESS_SC_ERRVERSION	./src/peers.c	/^#define	PEER_SESS_SC_ERRVERSION	/;"	d	file:
PEER_SESS_SC_SUCCESSCODE	./src/peers.c	/^#define	PEER_SESS_SC_SUCCESSCODE	/;"	d	file:
PEER_SESS_SC_TRYAGAIN	./src/peers.c	/^#define	PEER_SESS_SC_TRYAGAIN	/;"	d	file:
PEER_SESS_ST_ACCEPT	./src/peers.c	/^	PEER_SESS_ST_ACCEPT = 0,     \/* Initial state for session create by an accept, must be zero! *\/$/;"	e	enum:__anon143	file:
PEER_SESS_ST_CONNECT	./src/peers.c	/^	PEER_SESS_ST_CONNECT,        \/* Initial state for session create on a connect, push presentation into buffer *\/$/;"	e	enum:__anon143	file:
PEER_SESS_ST_END	./src/peers.c	/^	PEER_SESS_ST_END,            \/* Killed session *\/$/;"	e	enum:__anon143	file:
PEER_SESS_ST_ERRPROTO	./src/peers.c	/^	PEER_SESS_ST_ERRPROTO,       \/* Send error proto message before exit *\/$/;"	e	enum:__anon143	file:
PEER_SESS_ST_ERRSIZE	./src/peers.c	/^	PEER_SESS_ST_ERRSIZE,        \/* Send error size message before exit *\/$/;"	e	enum:__anon143	file:
PEER_SESS_ST_EXIT	./src/peers.c	/^	PEER_SESS_ST_EXIT,           \/* Exit with status code *\/$/;"	e	enum:__anon143	file:
PEER_SESS_ST_GETHOST	./src/peers.c	/^	PEER_SESS_ST_GETHOST,        \/* Validate host ID correspond to local host id *\/$/;"	e	enum:__anon143	file:
PEER_SESS_ST_GETPEER	./src/peers.c	/^	PEER_SESS_ST_GETPEER,        \/* Validate peer ID correspond to a known remote peer id *\/$/;"	e	enum:__anon143	file:
PEER_SESS_ST_GETSTATUS	./src/peers.c	/^	PEER_SESS_ST_GETSTATUS,      \/* Wait for the welcome message *\/$/;"	e	enum:__anon143	file:
PEER_SESS_ST_GETVERSION	./src/peers.c	/^	PEER_SESS_ST_GETVERSION,     \/* Validate supported protocol version *\/$/;"	e	enum:__anon143	file:
PEER_SESS_ST_SENDSUCCESS	./src/peers.c	/^	PEER_SESS_ST_SENDSUCCESS,    \/* Send ret code 200 (success) and wait for message *\/$/;"	e	enum:__anon143	file:
PEER_SESS_ST_WAITMSG	./src/peers.c	/^	PEER_SESS_ST_WAITMSG,        \/* Wait for data messages *\/$/;"	e	enum:__anon143	file:
PEER_TEACH_RESET	./src/peers.c	/^#define	PEER_TEACH_RESET	/;"	d	file:
PERSIST_TYPE_FORCE	./include/types/proto_http.h	/^	PERSIST_TYPE_FORCE,             \/* force-persist *\/$/;"	e	enum:__anon96
PERSIST_TYPE_IGNORE	./include/types/proto_http.h	/^	PERSIST_TYPE_IGNORE,            \/* ignore-persist *\/$/;"	e	enum:__anon96
PERSIST_TYPE_NONE	./include/types/proto_http.h	/^	PERSIST_TYPE_NONE = 0,          \/* no persistence *\/$/;"	e	enum:__anon96
PE_ARG_INVC	./include/common/errors.h	/^	PE_ARG_INVC,      \/* invalid char in argument (pointer not provided) *\/$/;"	e	enum:__anon3
PE_ARG_INVC_PTR	./include/common/errors.h	/^	PE_ARG_INVC_PTR,  \/* invalid char in argument (pointer provided) *\/$/;"	e	enum:__anon3
PE_ARG_MISSING	./include/common/errors.h	/^	PE_ARG_MISSING,   \/* mandatory argument not provided *\/$/;"	e	enum:__anon3
PE_ARG_NOT_FOUND	./include/common/errors.h	/^	PE_ARG_NOT_FOUND, \/* argument references something not found *\/$/;"	e	enum:__anon3
PE_ARG_NOT_USED	./include/common/errors.h	/^	PE_ARG_NOT_USED,  \/* argument provided cannot be used *\/$/;"	e	enum:__anon3
PE_ENUM_OOR	./include/common/errors.h	/^	PE_ENUM_OOR,      \/* enum data out of allowed range *\/$/;"	e	enum:__anon3
PE_EXIST	./include/common/errors.h	/^	PE_EXIST,         \/* trying to create something which already exists *\/$/;"	e	enum:__anon3
PE_NONE	./include/common/errors.h	/^	PE_NONE = 0,      \/* no error *\/$/;"	e	enum:__anon3
POWEROF2	./include/common/standard.h	/^#define POWEROF2(/;"	d
PP2_ADDR_LEN_INET	./include/types/connection.h	/^#define PP2_ADDR_LEN_INET /;"	d
PP2_ADDR_LEN_INET6	./include/types/connection.h	/^#define PP2_ADDR_LEN_INET6 /;"	d
PP2_ADDR_LEN_UNIX	./include/types/connection.h	/^#define PP2_ADDR_LEN_UNIX /;"	d
PP2_ADDR_LEN_UNSPEC	./include/types/connection.h	/^#define PP2_ADDR_LEN_UNSPEC /;"	d
PP2_CLIENT_CERT_CONN	./include/types/connection.h	/^#define PP2_CLIENT_CERT_CONN /;"	d
PP2_CLIENT_CERT_SESS	./include/types/connection.h	/^#define PP2_CLIENT_CERT_SESS /;"	d
PP2_CLIENT_SSL	./include/types/connection.h	/^#define PP2_CLIENT_SSL /;"	d
PP2_CMD_LOCAL	./include/types/connection.h	/^#define PP2_CMD_LOCAL /;"	d
PP2_CMD_MASK	./include/types/connection.h	/^#define PP2_CMD_MASK /;"	d
PP2_CMD_PROXY	./include/types/connection.h	/^#define PP2_CMD_PROXY /;"	d
PP2_FAM_INET	./include/types/connection.h	/^#define PP2_FAM_INET /;"	d
PP2_FAM_INET6	./include/types/connection.h	/^#define PP2_FAM_INET6 /;"	d
PP2_FAM_MASK	./include/types/connection.h	/^#define PP2_FAM_MASK /;"	d
PP2_FAM_UNIX	./include/types/connection.h	/^#define PP2_FAM_UNIX /;"	d
PP2_FAM_UNSPEC	./include/types/connection.h	/^#define PP2_FAM_UNSPEC /;"	d
PP2_HDR_LEN_INET	./include/types/connection.h	/^#define PP2_HDR_LEN_INET /;"	d
PP2_HDR_LEN_INET6	./include/types/connection.h	/^#define PP2_HDR_LEN_INET6 /;"	d
PP2_HDR_LEN_UNIX	./include/types/connection.h	/^#define PP2_HDR_LEN_UNIX /;"	d
PP2_HDR_LEN_UNSPEC	./include/types/connection.h	/^#define PP2_HDR_LEN_UNSPEC /;"	d
PP2_HEADER_LEN	./include/types/connection.h	/^#define PP2_HEADER_LEN /;"	d
PP2_SIGNATURE	./include/types/connection.h	/^#define PP2_SIGNATURE /;"	d
PP2_SIGNATURE_LEN	./include/types/connection.h	/^#define PP2_SIGNATURE_LEN /;"	d
PP2_TRANS_DGRAM	./include/types/connection.h	/^#define PP2_TRANS_DGRAM /;"	d
PP2_TRANS_MASK	./include/types/connection.h	/^#define PP2_TRANS_MASK /;"	d
PP2_TRANS_STREAM	./include/types/connection.h	/^#define PP2_TRANS_STREAM /;"	d
PP2_TRANS_UNSPEC	./include/types/connection.h	/^#define PP2_TRANS_UNSPEC /;"	d
PP2_TYPE_NETNS	./include/types/connection.h	/^#define PP2_TYPE_NETNS /;"	d
PP2_TYPE_SSL	./include/types/connection.h	/^#define PP2_TYPE_SSL /;"	d
PP2_TYPE_SSL_CN	./include/types/connection.h	/^#define PP2_TYPE_SSL_CN /;"	d
PP2_TYPE_SSL_VERSION	./include/types/connection.h	/^#define PP2_TYPE_SSL_VERSION /;"	d
PP2_VERSION	./include/types/connection.h	/^#define PP2_VERSION /;"	d
PP2_VERSION_MASK	./include/types/connection.h	/^#define PP2_VERSION_MASK /;"	d
PREFIX	./Makefile	/^PREFIX = \/usr\/local$/;"	m
PREFIX	./contrib/systemd/Makefile	/^PREFIX = \/usr\/local$/;"	m
PRIME32_1	./src/xxhash.c	/^#define PRIME32_1 /;"	d	file:
PRIME32_2	./src/xxhash.c	/^#define PRIME32_2 /;"	d	file:
PRIME32_3	./src/xxhash.c	/^#define PRIME32_3 /;"	d	file:
PRIME32_4	./src/xxhash.c	/^#define PRIME32_4 /;"	d	file:
PRIME32_5	./src/xxhash.c	/^#define PRIME32_5 /;"	d	file:
PRIME64_1	./src/xxhash.c	/^#define PRIME64_1 /;"	d	file:
PRIME64_2	./src/xxhash.c	/^#define PRIME64_2 /;"	d	file:
PRIME64_3	./src/xxhash.c	/^#define PRIME64_3 /;"	d	file:
PRIME64_4	./src/xxhash.c	/^#define PRIME64_4 /;"	d	file:
PRIME64_5	./src/xxhash.c	/^#define PRIME64_5 /;"	d	file:
PRODUCT_BRANCH	./include/common/version.h	/^#define PRODUCT_BRANCH /;"	d
PRODUCT_NAME	./include/common/version.h	/^#define PRODUCT_NAME /;"	d
PRODUCT_URL	./include/common/version.h	/^#define PRODUCT_URL /;"	d
PRODUCT_URL_DOC	./include/common/version.h	/^#define PRODUCT_URL_DOC /;"	d
PRODUCT_URL_UPD	./include/common/version.h	/^#define PRODUCT_URL_UPD /;"	d
PROTO_NAME_LEN	./include/types/protocol.h	/^#define PROTO_NAME_LEN /;"	d
PR_CAP_BE	./include/types/proxy.h	/^#define PR_CAP_BE /;"	d
PR_CAP_FE	./include/types/proxy.h	/^#define PR_CAP_FE /;"	d
PR_CAP_LISTEN	./include/types/proxy.h	/^#define PR_CAP_LISTEN /;"	d
PR_CAP_NONE	./include/types/proxy.h	/^#define PR_CAP_NONE /;"	d
PR_CAP_RS	./include/types/proxy.h	/^#define PR_CAP_RS /;"	d
PR_CK_ANY	./include/types/proxy.h	/^#define PR_CK_ANY /;"	d
PR_CK_HTTPONLY	./include/types/proxy.h	/^#define PR_CK_HTTPONLY /;"	d
PR_CK_IND	./include/types/proxy.h	/^#define PR_CK_IND /;"	d
PR_CK_INS	./include/types/proxy.h	/^#define PR_CK_INS /;"	d
PR_CK_NOC	./include/types/proxy.h	/^#define PR_CK_NOC /;"	d
PR_CK_PFX	./include/types/proxy.h	/^#define PR_CK_PFX /;"	d
PR_CK_POST	./include/types/proxy.h	/^#define PR_CK_POST /;"	d
PR_CK_PSV	./include/types/proxy.h	/^#define PR_CK_PSV /;"	d
PR_CK_RW	./include/types/proxy.h	/^#define PR_CK_RW /;"	d
PR_CK_SECURE	./include/types/proxy.h	/^#define PR_CK_SECURE /;"	d
PR_FBM_MISMATCH_ID	./include/types/proxy.h	/^#define PR_FBM_MISMATCH_ID /;"	d
PR_FBM_MISMATCH_NAME	./include/types/proxy.h	/^#define PR_FBM_MISMATCH_NAME /;"	d
PR_FBM_MISMATCH_PROXYTYPE	./include/types/proxy.h	/^#define PR_FBM_MISMATCH_PROXYTYPE /;"	d
PR_MODE_HEALTH	./include/types/proxy.h	/^	PR_MODE_HEALTH,$/;"	e	enum:pr_mode
PR_MODE_HTTP	./include/types/proxy.h	/^	PR_MODE_HTTP,$/;"	e	enum:pr_mode
PR_MODE_TCP	./include/types/proxy.h	/^	PR_MODE_TCP = 0,$/;"	e	enum:pr_mode
PR_O2_CHK_ANY	./include/types/proxy.h	/^#define PR_O2_CHK_ANY /;"	d
PR_O2_CHK_NONE	./include/types/proxy.h	/^#define PR_O2_CHK_NONE /;"	d
PR_O2_CHK_SNDST	./include/types/proxy.h	/^#define PR_O2_CHK_SNDST /;"	d
PR_O2_CLFLOG	./include/types/proxy.h	/^#define PR_O2_CLFLOG	/;"	d
PR_O2_EXP_INV	./include/types/proxy.h	/^#define PR_O2_EXP_INV /;"	d
PR_O2_EXP_NONE	./include/types/proxy.h	/^#define PR_O2_EXP_NONE /;"	d
PR_O2_EXP_RSTR	./include/types/proxy.h	/^#define PR_O2_EXP_RSTR /;"	d
PR_O2_EXP_RSTS	./include/types/proxy.h	/^#define PR_O2_EXP_RSTS /;"	d
PR_O2_EXP_STR	./include/types/proxy.h	/^#define PR_O2_EXP_STR /;"	d
PR_O2_EXP_STS	./include/types/proxy.h	/^#define PR_O2_EXP_STS /;"	d
PR_O2_EXP_TYPE	./include/types/proxy.h	/^#define PR_O2_EXP_TYPE /;"	d
PR_O2_EXT_CHK	./include/types/proxy.h	/^#define PR_O2_EXT_CHK /;"	d
PR_O2_FAKE_KA	./include/types/proxy.h	/^#define PR_O2_FAKE_KA /;"	d
PR_O2_HTTP_CHK	./include/types/proxy.h	/^#define PR_O2_HTTP_CHK /;"	d
PR_O2_INDEPSTR	./include/types/proxy.h	/^#define PR_O2_INDEPSTR	/;"	d
PR_O2_LB_AGENT_CHK	./include/types/proxy.h	/^#define PR_O2_LB_AGENT_CHK /;"	d
PR_O2_LDAP_CHK	./include/types/proxy.h	/^#define PR_O2_LDAP_CHK /;"	d
PR_O2_LOGERRORS	./include/types/proxy.h	/^#define PR_O2_LOGERRORS	/;"	d
PR_O2_LOGHCHKS	./include/types/proxy.h	/^#define PR_O2_LOGHCHKS	/;"	d
PR_O2_MYSQL_CHK	./include/types/proxy.h	/^#define PR_O2_MYSQL_CHK /;"	d
PR_O2_NODELAY	./include/types/proxy.h	/^#define PR_O2_NODELAY /;"	d
PR_O2_NOLOGNORM	./include/types/proxy.h	/^#define PR_O2_NOLOGNORM	/;"	d
PR_O2_PGSQL_CHK	./include/types/proxy.h	/^#define PR_O2_PGSQL_CHK /;"	d
PR_O2_RDPC_PRST	./include/types/proxy.h	/^#define PR_O2_RDPC_PRST	/;"	d
PR_O2_REDIS_CHK	./include/types/proxy.h	/^#define PR_O2_REDIS_CHK /;"	d
PR_O2_REQBUG_OK	./include/types/proxy.h	/^#define PR_O2_REQBUG_OK	/;"	d
PR_O2_RSPBUG_OK	./include/types/proxy.h	/^#define PR_O2_RSPBUG_OK	/;"	d
PR_O2_SMARTACC	./include/types/proxy.h	/^#define PR_O2_SMARTACC /;"	d
PR_O2_SMARTCON	./include/types/proxy.h	/^#define PR_O2_SMARTCON /;"	d
PR_O2_SMTP_CHK	./include/types/proxy.h	/^#define PR_O2_SMTP_CHK /;"	d
PR_O2_SOCKSTAT	./include/types/proxy.h	/^#define PR_O2_SOCKSTAT	/;"	d
PR_O2_SPLIC_ANY	./include/types/proxy.h	/^#define PR_O2_SPLIC_ANY	/;"	d
PR_O2_SPLIC_AUT	./include/types/proxy.h	/^#define PR_O2_SPLIC_AUT	/;"	d
PR_O2_SPLIC_REQ	./include/types/proxy.h	/^#define PR_O2_SPLIC_REQ	/;"	d
PR_O2_SPLIC_RTR	./include/types/proxy.h	/^#define PR_O2_SPLIC_RTR	/;"	d
PR_O2_SRC_ADDR	./include/types/proxy.h	/^#define PR_O2_SRC_ADDR	/;"	d
PR_O2_SSL3_CHK	./include/types/proxy.h	/^#define PR_O2_SSL3_CHK /;"	d
PR_O2_TCPCHK_CHK	./include/types/proxy.h	/^#define PR_O2_TCPCHK_CHK /;"	d
PR_O2_USE_PXHDR	./include/types/proxy.h	/^#define PR_O2_USE_PXHDR /;"	d
PR_O_ABRT_CLOSE	./include/types/proxy.h	/^#define PR_O_ABRT_CLOSE /;"	d
PR_O_CHK_CACHE	./include/types/proxy.h	/^#define PR_O_CHK_CACHE /;"	d
PR_O_CONTSTATS	./include/types/proxy.h	/^#define PR_O_CONTSTATS	/;"	d
PR_O_DISABLE404	./include/types/proxy.h	/^#define PR_O_DISABLE404 /;"	d
PR_O_DISPATCH	./include/types/proxy.h	/^#define PR_O_DISPATCH /;"	d
PR_O_FF_ALWAYS	./include/types/proxy.h	/^#define PR_O_FF_ALWAYS /;"	d
PR_O_FORCED_ID	./include/types/proxy.h	/^#define PR_O_FORCED_ID /;"	d
PR_O_FWDFOR	./include/types/proxy.h	/^#define PR_O_FWDFOR /;"	d
PR_O_HTTP_FCL	./include/types/proxy.h	/^#define PR_O_HTTP_FCL /;"	d
PR_O_HTTP_KAL	./include/types/proxy.h	/^#define PR_O_HTTP_KAL /;"	d
PR_O_HTTP_MODE	./include/types/proxy.h	/^#define PR_O_HTTP_MODE /;"	d
PR_O_HTTP_PCL	./include/types/proxy.h	/^#define PR_O_HTTP_PCL /;"	d
PR_O_HTTP_PROXY	./include/types/proxy.h	/^#define PR_O_HTTP_PROXY /;"	d
PR_O_HTTP_SCL	./include/types/proxy.h	/^#define PR_O_HTTP_SCL /;"	d
PR_O_HTTP_TUN	./include/types/proxy.h	/^#define PR_O_HTTP_TUN /;"	d
PR_O_IGNORE_PRB	./include/types/proxy.h	/^#define PR_O_IGNORE_PRB /;"	d
PR_O_LOGASAP	./include/types/proxy.h	/^#define PR_O_LOGASAP /;"	d
PR_O_NULLNOLOG	./include/types/proxy.h	/^#define PR_O_NULLNOLOG /;"	d
PR_O_ORGTO	./include/types/proxy.h	/^#define PR_O_ORGTO /;"	d
PR_O_PERSIST	./include/types/proxy.h	/^#define PR_O_PERSIST /;"	d
PR_O_PREF_LAST	./include/types/proxy.h	/^#define PR_O_PREF_LAST /;"	d
PR_O_REDISP	./include/types/proxy.h	/^#define PR_O_REDISP /;"	d
PR_O_REUSE_AGGR	./include/types/proxy.h	/^#define PR_O_REUSE_AGGR /;"	d
PR_O_REUSE_ALWS	./include/types/proxy.h	/^#define PR_O_REUSE_ALWS /;"	d
PR_O_REUSE_MASK	./include/types/proxy.h	/^#define PR_O_REUSE_MASK /;"	d
PR_O_REUSE_NEVR	./include/types/proxy.h	/^#define PR_O_REUSE_NEVR /;"	d
PR_O_REUSE_SAFE	./include/types/proxy.h	/^#define PR_O_REUSE_SAFE /;"	d
PR_O_TCPCHK_SSL	./include/types/proxy.h	/^#define PR_O_TCPCHK_SSL /;"	d
PR_O_TCP_CLI_KA	./include/types/proxy.h	/^#define PR_O_TCP_CLI_KA /;"	d
PR_O_TCP_NOLING	./include/types/proxy.h	/^#define PR_O_TCP_NOLING /;"	d
PR_O_TCP_SRV_KA	./include/types/proxy.h	/^#define PR_O_TCP_SRV_KA /;"	d
PR_O_TRANSP	./include/types/proxy.h	/^#define PR_O_TRANSP /;"	d
PR_O_USE_ALL_BK	./include/types/proxy.h	/^#define PR_O_USE_ALL_BK /;"	d
PR_O_WREQ_BODY	./include/types/proxy.h	/^#define PR_O_WREQ_BODY /;"	d
PR_SRV_STATE_FILE	./include/types/proxy.h	/^enum PR_SRV_STATE_FILE {$/;"	g
PR_SRV_STATE_FILE_GLOBAL	./include/types/proxy.h	/^	PR_SRV_STATE_FILE_GLOBAL,$/;"	e	enum:PR_SRV_STATE_FILE
PR_SRV_STATE_FILE_LOCAL	./include/types/proxy.h	/^	PR_SRV_STATE_FILE_LOCAL,$/;"	e	enum:PR_SRV_STATE_FILE
PR_SRV_STATE_FILE_NONE	./include/types/proxy.h	/^	PR_SRV_STATE_FILE_NONE,$/;"	e	enum:PR_SRV_STATE_FILE
PR_SRV_STATE_FILE_UNSPEC	./include/types/proxy.h	/^	PR_SRV_STATE_FILE_UNSPEC = 0,$/;"	e	enum:PR_SRV_STATE_FILE
PR_STERROR	./include/types/proxy.h	/^	PR_STERROR,             \/* proxy experienced an unrecoverable error *\/$/;"	e	enum:pr_state
PR_STFULL	./include/types/proxy.h	/^	PR_STFULL,              \/* frontend is full (maxconn reached) *\/$/;"	e	enum:pr_state
PR_STNEW	./include/types/proxy.h	/^	PR_STNEW = 0,           \/* proxy has not been initialized yet *\/$/;"	e	enum:pr_state
PR_STPAUSED	./include/types/proxy.h	/^	PR_STPAUSED,            \/* frontend is paused (during hot restart) *\/$/;"	e	enum:pr_state
PR_STREADY	./include/types/proxy.h	/^	PR_STREADY,             \/* proxy has been initialized and is ready *\/$/;"	e	enum:pr_state
PR_STSTOPPED	./include/types/proxy.h	/^	PR_STSTOPPED,           \/* proxy is stopped (end of a restart) *\/$/;"	e	enum:pr_state
PTR_INT_TYPE	./ebtree/ebpttree.h	/^#define PTR_INT_TYPE	/;"	d
QBITS	./contrib/halog/halog.c	/^#define QBITS /;"	d	file:
QSTR_SIZE	./include/common/standard.h	/^#define QSTR_SIZE /;"	d
QUEUE_LEN_FIELD	./contrib/halog/halog.c	/^#define QUEUE_LEN_FIELD /;"	d	file:
RB_BLACK	./include/common/rbtree.h	/^#define	RB_BLACK	/;"	d
RB_RED	./include/common/rbtree.h	/^#define	RB_RED	/;"	d
RB_ROOT	./include/common/rbtree.h	/^#define RB_ROOT	/;"	d
REDIRECT_FLAG_APPEND_SLASH	./include/types/proto_http.h	/^	REDIRECT_FLAG_APPEND_SLASH = 2,	\/* append a slash if missing at the end *\/$/;"	e	enum:__anon94
REDIRECT_FLAG_DROP_QS	./include/types/proto_http.h	/^	REDIRECT_FLAG_DROP_QS = 1,	\/* drop query string *\/$/;"	e	enum:__anon94
REDIRECT_FLAG_NONE	./include/types/proto_http.h	/^	REDIRECT_FLAG_NONE = 0,$/;"	e	enum:__anon94
REDIRECT_TYPE_LOCATION	./include/types/proto_http.h	/^	REDIRECT_TYPE_LOCATION,         \/* location redirect *\/$/;"	e	enum:__anon95
REDIRECT_TYPE_NONE	./include/types/proto_http.h	/^	REDIRECT_TYPE_NONE = 0,         \/* no redirection *\/$/;"	e	enum:__anon95
REDIRECT_TYPE_PREFIX	./include/types/proto_http.h	/^	REDIRECT_TYPE_PREFIX,           \/* prefix redirect *\/$/;"	e	enum:__anon95
REDIRECT_TYPE_SCHEME	./include/types/proto_http.h	/^	REDIRECT_TYPE_SCHEME,           \/* scheme redirect (eg: switch from http to https) *\/$/;"	e	enum:__anon95
REEXEC_FLAG	./src/haproxy-systemd-wrapper.c	/^#define REEXEC_FLAG /;"	d	file:
REGEX	./Makefile	/^REGEX = libc$/;"	m
REGPRM1	./include/common/compiler.h	/^#define REGPRM1	/;"	d
REGPRM1	./include/common/compiler.h	/^#define REGPRM1$/;"	d
REGPRM2	./include/common/compiler.h	/^#define REGPRM2	/;"	d
REGPRM2	./include/common/compiler.h	/^#define REGPRM2 /;"	d
REGPRM3	./include/common/compiler.h	/^#define REGPRM3	/;"	d
REGPRM3	./include/common/compiler.h	/^#define REGPRM3 /;"	d
REQURI_LEN	./include/common/defaults.h	/^#define REQURI_LEN /;"	d
RESERVED_BUFS	./include/common/defaults.h	/^#define RESERVED_BUFS /;"	d
RESET_SAFE_LJMP	./src/hlua.c	/^#define RESET_SAFE_LJMP(/;"	d	file:
RSLV_STATUS_ERROR	./include/types/dns.h	/^	RSLV_STATUS_ERROR,		\/* error *\/$/;"	e	enum:__anon66
RSLV_STATUS_INVALID	./include/types/dns.h	/^	RSLV_STATUS_INVALID,		\/* invalid responses *\/$/;"	e	enum:__anon66
RSLV_STATUS_NONE	./include/types/dns.h	/^	RSLV_STATUS_NONE	= 0,	\/* no resolution occured yet *\/$/;"	e	enum:__anon66
RSLV_STATUS_NX	./include/types/dns.h	/^	RSLV_STATUS_NX,			\/* NXDOMAIN *\/$/;"	e	enum:__anon66
RSLV_STATUS_OTHER	./include/types/dns.h	/^	RSLV_STATUS_OTHER,		\/* other errors *\/$/;"	e	enum:__anon66
RSLV_STATUS_REFUSED	./include/types/dns.h	/^	RSLV_STATUS_REFUSED,		\/* server refused our query *\/$/;"	e	enum:__anon66
RSLV_STATUS_TIMEOUT	./include/types/dns.h	/^	RSLV_STATUS_TIMEOUT,		\/* no response from DNS servers *\/$/;"	e	enum:__anon66
RSLV_STATUS_VALID	./include/types/dns.h	/^	RSLV_STATUS_VALID,		\/* no error *\/$/;"	e	enum:__anon66
RSLV_STEP_NONE	./include/types/dns.h	/^	RSLV_STEP_NONE		= 0,	\/* nothing happening currently *\/$/;"	e	enum:__anon67
RSLV_STEP_RUNNING	./include/types/dns.h	/^	RSLV_STEP_RUNNING,		\/* resolution is running *\/$/;"	e	enum:__anon67
S32	./src/xxhash.c	/^typedef   signed int       S32;$/;"	t	file:
S32	./src/xxhash.c	/^typedef  int32_t S32;$/;"	t	file:
SBINDIR	./Makefile	/^SBINDIR = $(PREFIX)\/sbin$/;"	m
SBINDIR	./contrib/systemd/Makefile	/^SBINDIR = $(PREFIX)\/sbin$/;"	m
SCHEDULER_RESOLUTION	./include/common/config.h	/^#define SCHEDULER_RESOLUTION /;"	d
SCH_HTTP	./include/common/standard.h	/^	SCH_HTTP,$/;"	e	enum:http_scheme
SCH_HTTPS	./include/common/standard.h	/^	SCH_HTTPS,$/;"	e	enum:http_scheme
SCOPE_REQ	./include/types/vars.h	/^	SCOPE_REQ,$/;"	e	enum:vars_scope
SCOPE_RES	./include/types/vars.h	/^	SCOPE_RES,$/;"	e	enum:vars_scope
SCOPE_SESS	./include/types/vars.h	/^	SCOPE_SESS = 0,$/;"	e	enum:vars_scope
SCOPE_TXN	./include/types/vars.h	/^	SCOPE_TXN,$/;"	e	enum:vars_scope
SD_DEBUG	./src/haproxy-systemd-wrapper.c	/^#define SD_DEBUG /;"	d	file:
SD_NOTICE	./src/haproxy-systemd-wrapper.c	/^#define SD_NOTICE /;"	d	file:
SEC	./include/common/standard.h	/^#define SEC /;"	d
SEND_ERR	./src/hlua.c	/^#define SEND_ERR(/;"	d	file:
SEP	./contrib/halog/halog.c	/^#define SEP(/;"	d	file:
SERVER_FIELD	./contrib/halog/halog.c	/^#define SERVER_FIELD /;"	d	file:
SETNOW	./include/common/time.h	/^#define SETNOW(/;"	d
SET_SAFE_LJMP	./src/hlua.c	/^#define SET_SAFE_LJMP(/;"	d	file:
SF_ADDR_SET	./include/types/stream.h	/^#define SF_ADDR_SET	/;"	d
SF_ASSIGNED	./include/types/stream.h	/^#define SF_ASSIGNED	/;"	d
SF_BE_ASSIGNED	./include/types/stream.h	/^#define SF_BE_ASSIGNED	/;"	d
SF_COMP_READY	./include/types/stream.h	/^#define SF_COMP_READY /;"	d
SF_CONN_TAR	./include/types/stream.h	/^#define SF_CONN_TAR	/;"	d
SF_CURR_SESS	./include/types/stream.h	/^#define SF_CURR_SESS	/;"	d
SF_DIRECT	./include/types/stream.h	/^#define SF_DIRECT	/;"	d
SF_ERR_CLICL	./include/types/stream.h	/^#define SF_ERR_CLICL /;"	d
SF_ERR_CLITO	./include/types/stream.h	/^#define SF_ERR_CLITO /;"	d
SF_ERR_DOWN	./include/types/stream.h	/^#define SF_ERR_DOWN /;"	d
SF_ERR_INTERNAL	./include/types/stream.h	/^#define SF_ERR_INTERNAL /;"	d
SF_ERR_KILLED	./include/types/stream.h	/^#define SF_ERR_KILLED /;"	d
SF_ERR_LOCAL	./include/types/stream.h	/^#define SF_ERR_LOCAL /;"	d
SF_ERR_MASK	./include/types/stream.h	/^#define SF_ERR_MASK /;"	d
SF_ERR_NONE	./include/types/stream.h	/^#define SF_ERR_NONE /;"	d
SF_ERR_PRXCOND	./include/types/stream.h	/^#define SF_ERR_PRXCOND /;"	d
SF_ERR_RESOURCE	./include/types/stream.h	/^#define SF_ERR_RESOURCE /;"	d
SF_ERR_SHIFT	./include/types/stream.h	/^#define SF_ERR_SHIFT /;"	d
SF_ERR_SRVCL	./include/types/stream.h	/^#define SF_ERR_SRVCL /;"	d
SF_ERR_SRVTO	./include/types/stream.h	/^#define SF_ERR_SRVTO /;"	d
SF_ERR_UP	./include/types/stream.h	/^#define SF_ERR_UP /;"	d
SF_FINST_C	./include/types/stream.h	/^#define SF_FINST_C	/;"	d
SF_FINST_D	./include/types/stream.h	/^#define SF_FINST_D	/;"	d
SF_FINST_H	./include/types/stream.h	/^#define SF_FINST_H	/;"	d
SF_FINST_L	./include/types/stream.h	/^#define SF_FINST_L	/;"	d
SF_FINST_MASK	./include/types/stream.h	/^#define SF_FINST_MASK	/;"	d
SF_FINST_Q	./include/types/stream.h	/^#define SF_FINST_Q	/;"	d
SF_FINST_R	./include/types/stream.h	/^#define SF_FINST_R	/;"	d
SF_FINST_SHIFT	./include/types/stream.h	/^#define	SF_FINST_SHIFT	/;"	d
SF_FINST_T	./include/types/stream.h	/^#define SF_FINST_T	/;"	d
SF_FORCE_PRST	./include/types/stream.h	/^#define SF_FORCE_PRST	/;"	d
SF_IGNORE_PRST	./include/types/stream.h	/^#define SF_IGNORE_PRST	/;"	d
SF_INITIALIZED	./include/types/stream.h	/^#define SF_INITIALIZED	/;"	d
SF_MONITOR	./include/types/stream.h	/^#define SF_MONITOR	/;"	d
SF_REDIRECTABLE	./include/types/stream.h	/^#define SF_REDIRECTABLE	/;"	d
SF_REDISP	./include/types/stream.h	/^#define SF_REDISP	/;"	d
SF_SRV_REUSED	./include/types/stream.h	/^#define SF_SRV_REUSED /;"	d
SF_TUNNEL	./include/types/stream.h	/^#define SF_TUNNEL	/;"	d
SHCTX_APPNAME	./include/proto/shctx.h	/^#define SHCTX_APPNAME /;"	d
SHCTX_E_ALLOC_CACHE	./include/proto/shctx.h	/^#define SHCTX_E_ALLOC_CACHE /;"	d
SHCTX_E_INIT_LOCK	./include/proto/shctx.h	/^#define SHCTX_E_INIT_LOCK /;"	d
SHCTX_H	./include/proto/shctx.h	/^#define SHCTX_H$/;"	d
SHSESS_BLOCK_MIN_SIZE	./include/proto/shctx.h	/^#define SHSESS_BLOCK_MIN_SIZE /;"	d
SHSESS_MAX_DATA_LEN	./include/proto/shctx.h	/^#define SHSESS_MAX_DATA_LEN /;"	d
SHTABLE_F_TEACH_STAGE1	./src/peers.c	/^#define SHTABLE_F_TEACH_STAGE1	/;"	d	file:
SHTABLE_F_TEACH_STAGE2	./src/peers.c	/^#define SHTABLE_F_TEACH_STAGE2	/;"	d	file:
SHUT_RD	./include/common/compat.h	/^#define SHUT_RD	/;"	d
SHUT_WR	./include/common/compat.h	/^#define SHUT_WR	/;"	d
SIG_F_ONE_SHOOT	./include/types/signal.h	/^#define SIG_F_ONE_SHOOT /;"	d
SIG_F_TYPE_FCT	./include/types/signal.h	/^#define SIG_F_TYPE_FCT /;"	d
SIG_F_TYPE_TASK	./include/types/signal.h	/^#define SIG_F_TYPE_TASK /;"	d
SILENT_DEFINE	./Makefile	/^SILENT_DEFINE =$/;"	m
SI_ET_CONN_ABRT	./include/types/stream_interface.h	/^	SI_ET_CONN_ABRT  = 0x0020,  \/* connection aborted by external cause (eg: abort) *\/$/;"	e	enum:__anon131
SI_ET_CONN_ERR	./include/types/stream_interface.h	/^	SI_ET_CONN_ERR   = 0x0010,  \/* connection error (eg: no server available) *\/$/;"	e	enum:__anon131
SI_ET_CONN_OTHER	./include/types/stream_interface.h	/^	SI_ET_CONN_OTHER = 0x0080,  \/* connection aborted for other reason (eg: 500) *\/$/;"	e	enum:__anon131
SI_ET_CONN_RES	./include/types/stream_interface.h	/^	SI_ET_CONN_RES   = 0x0040,  \/* connection aborted due to lack of resources *\/$/;"	e	enum:__anon131
SI_ET_CONN_TO	./include/types/stream_interface.h	/^	SI_ET_CONN_TO    = 0x0008,  \/* connection timeout *\/$/;"	e	enum:__anon131
SI_ET_DATA_ABRT	./include/types/stream_interface.h	/^	SI_ET_DATA_ABRT  = 0x0400,  \/* data phase aborted by external cause *\/$/;"	e	enum:__anon131
SI_ET_DATA_ERR	./include/types/stream_interface.h	/^	SI_ET_DATA_ERR   = 0x0200,  \/* error during data phase *\/$/;"	e	enum:__anon131
SI_ET_DATA_TO	./include/types/stream_interface.h	/^	SI_ET_DATA_TO    = 0x0100,  \/* timeout during data phase *\/$/;"	e	enum:__anon131
SI_ET_NONE	./include/types/stream_interface.h	/^	SI_ET_NONE       = 0x0000,  \/* no error yet, leave it to zero *\/$/;"	e	enum:__anon131
SI_ET_QUEUE_ABRT	./include/types/stream_interface.h	/^	SI_ET_QUEUE_ABRT = 0x0004,  \/* aborted in queue by external cause *\/$/;"	e	enum:__anon131
SI_ET_QUEUE_ERR	./include/types/stream_interface.h	/^	SI_ET_QUEUE_ERR  = 0x0002,  \/* queue error (eg: full) *\/$/;"	e	enum:__anon131
SI_ET_QUEUE_TO	./include/types/stream_interface.h	/^	SI_ET_QUEUE_TO   = 0x0001,  \/* queue timeout *\/$/;"	e	enum:__anon131
SI_FL_DONT_WAKE	./include/types/stream_interface.h	/^	SI_FL_DONT_WAKE  = 0x0020,  \/* resync in progress, don't wake up *\/$/;"	e	enum:__anon132
SI_FL_ERR	./include/types/stream_interface.h	/^	SI_FL_ERR        = 0x0002,  \/* a non-recoverable error has occurred *\/$/;"	e	enum:__anon132
SI_FL_EXP	./include/types/stream_interface.h	/^	SI_FL_EXP        = 0x0001,  \/* timeout has expired *\/$/;"	e	enum:__anon132
SI_FL_INDEP_STR	./include/types/stream_interface.h	/^	SI_FL_INDEP_STR  = 0x0040,  \/* independent streams = don't update rex on write *\/$/;"	e	enum:__anon132
SI_FL_ISBACK	./include/types/stream_interface.h	/^	SI_FL_ISBACK     = 0x0010,  \/* 0 for front-side SI, 1 for back-side *\/$/;"	e	enum:__anon132
SI_FL_NOHALF	./include/types/stream_interface.h	/^	SI_FL_NOHALF     = 0x0100,  \/* no half close, close both sides at once *\/$/;"	e	enum:__anon132
SI_FL_NOLINGER	./include/types/stream_interface.h	/^	SI_FL_NOLINGER   = 0x0080,  \/* may close without lingering. One-shot. *\/$/;"	e	enum:__anon132
SI_FL_NONE	./include/types/stream_interface.h	/^	SI_FL_NONE       = 0x0000,  \/* nothing *\/$/;"	e	enum:__anon132
SI_FL_SRC_ADDR	./include/types/stream_interface.h	/^	SI_FL_SRC_ADDR   = 0x1000,  \/* get the source ip\/port with getsockname *\/$/;"	e	enum:__anon132
SI_FL_WAIT_DATA	./include/types/stream_interface.h	/^	SI_FL_WAIT_DATA  = 0x0008,  \/* waiting for more data to send *\/$/;"	e	enum:__anon132
SI_FL_WAIT_ROOM	./include/types/stream_interface.h	/^	SI_FL_WAIT_ROOM  = 0x0004,  \/* waiting for space to store incoming data *\/$/;"	e	enum:__anon132
SI_FL_WANT_GET	./include/types/stream_interface.h	/^	SI_FL_WANT_GET   = 0x4000,  \/* an applet would like to get some data from the buffer *\/$/;"	e	enum:__anon132
SI_FL_WANT_PUT	./include/types/stream_interface.h	/^	SI_FL_WANT_PUT   = 0x2000,  \/* an applet would like to put some data into the buffer *\/$/;"	e	enum:__anon132
SI_ST_ASS	./include/types/stream_interface.h	/^	SI_ST_ASS,               \/* server just assigned to this interface *\/$/;"	e	enum:si_state
SI_ST_CER	./include/types/stream_interface.h	/^	SI_ST_CER,               \/* [transient] previous connection attempt failed (resource released) *\/$/;"	e	enum:si_state
SI_ST_CLO	./include/types/stream_interface.h	/^	SI_ST_CLO,               \/* stream intf closed, might not existing anymore. Buffers shut. *\/$/;"	e	enum:si_state
SI_ST_CON	./include/types/stream_interface.h	/^	SI_ST_CON,               \/* initiated connection request (resource exists) *\/$/;"	e	enum:si_state
SI_ST_DIS	./include/types/stream_interface.h	/^	SI_ST_DIS,               \/* [transient] disconnected from other side, but cleanup not done yet *\/$/;"	e	enum:si_state
SI_ST_EST	./include/types/stream_interface.h	/^	SI_ST_EST,               \/* connection established (resource exists) *\/$/;"	e	enum:si_state
SI_ST_INI	./include/types/stream_interface.h	/^	SI_ST_INI = 0,           \/* interface not sollicitated yet *\/$/;"	e	enum:si_state
SI_ST_QUE	./include/types/stream_interface.h	/^	SI_ST_QUE,               \/* interface waiting in queue *\/$/;"	e	enum:si_state
SI_ST_REQ	./include/types/stream_interface.h	/^	SI_ST_REQ,               \/* [transient] connection initiation desired and not started yet *\/$/;"	e	enum:si_state
SI_ST_TAR	./include/types/stream_interface.h	/^	SI_ST_TAR,               \/* interface in turn-around state after failed connect attempt *\/$/;"	e	enum:si_state
SKIP_CHAR	./contrib/halog/halog.c	/^#define SKIP_CHAR(/;"	d	file:
SLZ_INC	./Makefile	/^SLZ_INC =$/;"	m
SLZ_LIB	./Makefile	/^SLZ_LIB =$/;"	m
SMALL_OPTS	./Makefile	/^SMALL_OPTS =$/;"	m
SMP_CKP_BE_HRQ_BDY	./include/types/sample.h	/^	SMP_CKP_BE_HRQ_BDY,  \/* BE HTTP request body *\/$/;"	e	enum:__anon117
SMP_CKP_BE_HRQ_HDR	./include/types/sample.h	/^	SMP_CKP_BE_HRQ_HDR,  \/* BE HTTP request headers (rules, headers, monitor, stats, redirect) *\/$/;"	e	enum:__anon117
SMP_CKP_BE_HRS_BDY	./include/types/sample.h	/^	SMP_CKP_BE_HRS_BDY,  \/* BE HTTP response body (stick-store rules are there) *\/$/;"	e	enum:__anon117
SMP_CKP_BE_HRS_HDR	./include/types/sample.h	/^	SMP_CKP_BE_HRS_HDR,  \/* BE HTTP response headers (rules, headers) *\/$/;"	e	enum:__anon117
SMP_CKP_BE_REQ_CNT	./include/types/sample.h	/^	SMP_CKP_BE_REQ_CNT,  \/* BE request content rules ("tcp request content") *\/$/;"	e	enum:__anon117
SMP_CKP_BE_RES_CNT	./include/types/sample.h	/^	SMP_CKP_BE_RES_CNT,  \/* BE response content rules ("tcp response content") *\/$/;"	e	enum:__anon117
SMP_CKP_BE_SET_SRV	./include/types/sample.h	/^	SMP_CKP_BE_SET_SRV,  \/* BE server switching rules ("use_server", "balance", "force-persist", "stick", ...) *\/$/;"	e	enum:__anon117
SMP_CKP_BE_SRV_CON	./include/types/sample.h	/^	SMP_CKP_BE_SRV_CON,  \/* BE server connect (eg: "source") *\/$/;"	e	enum:__anon117
SMP_CKP_BE_STO_RUL	./include/types/sample.h	/^	SMP_CKP_BE_STO_RUL,  \/* BE stick-store rules *\/$/;"	e	enum:__anon117
SMP_CKP_ENTRIES	./include/types/sample.h	/^	SMP_CKP_ENTRIES \/* nothing after this *\/$/;"	e	enum:__anon117
SMP_CKP_FE_CON_ACC	./include/types/sample.h	/^	SMP_CKP_FE_CON_ACC,  \/* FE connection accept rules ("tcp request connection") *\/$/;"	e	enum:__anon117
SMP_CKP_FE_HRQ_BDY	./include/types/sample.h	/^	SMP_CKP_FE_HRQ_BDY,  \/* FE HTTP request body *\/$/;"	e	enum:__anon117
SMP_CKP_FE_HRQ_HDR	./include/types/sample.h	/^	SMP_CKP_FE_HRQ_HDR,  \/* FE HTTP request headers (rules, headers, monitor, stats, redirect) *\/$/;"	e	enum:__anon117
SMP_CKP_FE_HRS_BDY	./include/types/sample.h	/^	SMP_CKP_FE_HRS_BDY,  \/* FE HTTP response body *\/$/;"	e	enum:__anon117
SMP_CKP_FE_HRS_HDR	./include/types/sample.h	/^	SMP_CKP_FE_HRS_HDR,  \/* FE HTTP response headers (rules, headers) *\/$/;"	e	enum:__anon117
SMP_CKP_FE_LOG_END	./include/types/sample.h	/^	SMP_CKP_FE_LOG_END,  \/* FE log at the end of the txn\/stream *\/$/;"	e	enum:__anon117
SMP_CKP_FE_REQ_CNT	./include/types/sample.h	/^	SMP_CKP_FE_REQ_CNT,  \/* FE request content rules ("tcp request content") *\/$/;"	e	enum:__anon117
SMP_CKP_FE_RES_CNT	./include/types/sample.h	/^	SMP_CKP_FE_RES_CNT,  \/* FE response content rules ("tcp response content") *\/$/;"	e	enum:__anon117
SMP_CKP_FE_SES_ACC	./include/types/sample.h	/^	SMP_CKP_FE_SES_ACC,  \/* FE stream accept rules (to come soon) *\/$/;"	e	enum:__anon117
SMP_CKP_FE_SET_BCK	./include/types/sample.h	/^	SMP_CKP_FE_SET_BCK,  \/* FE backend switching rules ("use_backend") *\/$/;"	e	enum:__anon117
SMP_F_CONST	./include/types/sample.h	/^	SMP_F_CONST      = 1 << 7, \/* This sample use constant memory. May diplicate it before changes *\/$/;"	e	enum:__anon121
SMP_F_MAY_CHANGE	./include/types/sample.h	/^	SMP_F_MAY_CHANGE = 1 << 1, \/* sample is unstable and might change (eg: request length) *\/$/;"	e	enum:__anon121
SMP_F_NOT_LAST	./include/types/sample.h	/^	SMP_F_NOT_LAST   = 1 << 0, \/* other occurrences might exist for this sample *\/$/;"	e	enum:__anon121
SMP_F_VOLATILE	./include/types/sample.h	/^	SMP_F_VOLATILE   = (1<<2)|(1<<3)|(1<<4)|(1<<5)|(1<<6), \/* any volatility condition *\/$/;"	e	enum:__anon121
SMP_F_VOL_1ST	./include/types/sample.h	/^	SMP_F_VOL_1ST    = 1 << 3, \/* result sensitive to changes in first line (eg: URI) *\/$/;"	e	enum:__anon121
SMP_F_VOL_HDR	./include/types/sample.h	/^	SMP_F_VOL_HDR    = 1 << 4, \/* result sensitive to changes in headers *\/$/;"	e	enum:__anon121
SMP_F_VOL_SESS	./include/types/sample.h	/^	SMP_F_VOL_SESS   = 1 << 6, \/* result sensitive to new session (eg: src IP) *\/$/;"	e	enum:__anon121
SMP_F_VOL_TEST	./include/types/sample.h	/^	SMP_F_VOL_TEST   = 1 << 2, \/* result must not survive longer than the test (eg: time) *\/$/;"	e	enum:__anon121
SMP_F_VOL_TXN	./include/types/sample.h	/^	SMP_F_VOL_TXN    = 1 << 5, \/* result sensitive to new transaction (eg: HTTP version) *\/$/;"	e	enum:__anon121
SMP_OPT_DIR	./include/types/sample.h	/^	SMP_OPT_DIR     = (SMP_OPT_DIR_REQ|SMP_OPT_DIR_RES), \/* mask to get direction *\/$/;"	e	enum:__anon120
SMP_OPT_DIR_REQ	./include/types/sample.h	/^	SMP_OPT_DIR_REQ = 0,    \/* direction = request *\/$/;"	e	enum:__anon120
SMP_OPT_DIR_RES	./include/types/sample.h	/^	SMP_OPT_DIR_RES = 1,    \/* direction = response *\/$/;"	e	enum:__anon120
SMP_OPT_FINAL	./include/types/sample.h	/^	SMP_OPT_FINAL   = 2,    \/* final fetch, contents won't change anymore *\/$/;"	e	enum:__anon120
SMP_OPT_ITERATE	./include/types/sample.h	/^	SMP_OPT_ITERATE = 4,    \/* fetches may be iterated if supported (for ACLs) *\/$/;"	e	enum:__anon120
SMP_SRC_BKEND	./include/types/sample.h	/^	SMP_SRC_BKEND,  \/* fetch uses information about the backend *\/$/;"	e	enum:__anon116
SMP_SRC_ENTRIES	./include/types/sample.h	/^	SMP_SRC_ENTRIES \/* nothing after this *\/$/;"	e	enum:__anon116
SMP_SRC_FTEND	./include/types/sample.h	/^	SMP_SRC_FTEND,  \/* frontend which accepted the connection *\/$/;"	e	enum:__anon116
SMP_SRC_HRQBO	./include/types/sample.h	/^	SMP_SRC_HRQBO,  \/* fetch uses information about HTTP request body *\/$/;"	e	enum:__anon116
SMP_SRC_HRQHP	./include/types/sample.h	/^	SMP_SRC_HRQHP,  \/* fetch uses persistent information about HTTP request headers (eg: meth) *\/$/;"	e	enum:__anon116
SMP_SRC_HRQHV	./include/types/sample.h	/^	SMP_SRC_HRQHV,  \/* fetch uses volatile information about HTTP request headers (eg: value) *\/$/;"	e	enum:__anon116
SMP_SRC_HRSBO	./include/types/sample.h	/^	SMP_SRC_HRSBO,  \/* fetch uses information about HTTP response body *\/$/;"	e	enum:__anon116
SMP_SRC_HRSHP	./include/types/sample.h	/^	SMP_SRC_HRSHP,  \/* fetch uses persistent information about HTTP response headers (eg: status) *\/$/;"	e	enum:__anon116
SMP_SRC_HRSHV	./include/types/sample.h	/^	SMP_SRC_HRSHV,  \/* fetch uses volatile information about HTTP response headers (eg: value) *\/$/;"	e	enum:__anon116
SMP_SRC_INTRN	./include/types/sample.h	/^	SMP_SRC_INTRN,  \/* internal context-less information *\/$/;"	e	enum:__anon116
SMP_SRC_L4CLI	./include/types/sample.h	/^	SMP_SRC_L4CLI,  \/* L4 information about the client *\/$/;"	e	enum:__anon116
SMP_SRC_L4SRV	./include/types/sample.h	/^	SMP_SRC_L4SRV,  \/* fetch uses information about the server L4 connection *\/$/;"	e	enum:__anon116
SMP_SRC_L5CLI	./include/types/sample.h	/^	SMP_SRC_L5CLI,  \/* fetch uses client information from embryonic session *\/$/;"	e	enum:__anon116
SMP_SRC_L5SRV	./include/types/sample.h	/^	SMP_SRC_L5SRV,  \/* fetch uses information about the server L5 connection *\/$/;"	e	enum:__anon116
SMP_SRC_L6REQ	./include/types/sample.h	/^	SMP_SRC_L6REQ,  \/* fetch uses raw information from the request buffer *\/$/;"	e	enum:__anon116
SMP_SRC_L6RES	./include/types/sample.h	/^	SMP_SRC_L6RES,  \/* fetch uses raw information from the response buffer *\/$/;"	e	enum:__anon116
SMP_SRC_LISTN	./include/types/sample.h	/^	SMP_SRC_LISTN,  \/* listener which accepted the connection *\/$/;"	e	enum:__anon116
SMP_SRC_RQFIN	./include/types/sample.h	/^	SMP_SRC_RQFIN,  \/* final information about request buffer (eg: tot bytes) *\/$/;"	e	enum:__anon116
SMP_SRC_RSFIN	./include/types/sample.h	/^	SMP_SRC_RSFIN,  \/* final information about response buffer (eg: tot bytes) *\/$/;"	e	enum:__anon116
SMP_SRC_SERVR	./include/types/sample.h	/^	SMP_SRC_SERVR,  \/* fetch uses information about the selected server *\/$/;"	e	enum:__anon116
SMP_SRC_SSFIN	./include/types/sample.h	/^	SMP_SRC_SSFIN,  \/* final information about the stream (eg: #requests, final flags) *\/$/;"	e	enum:__anon116
SMP_SRC_TRACK	./include/types/sample.h	/^	SMP_SRC_TRACK,  \/* fetch involves track counters *\/$/;"	e	enum:__anon116
SMP_SRC_TXFIN	./include/types/sample.h	/^	SMP_SRC_TXFIN,  \/* final information about the transaction (eg: #comp rate) *\/$/;"	e	enum:__anon116
SMP_TYPES	./include/types/sample.h	/^	SMP_TYPES        \/* number of types, must always be last *\/$/;"	e	enum:__anon115
SMP_T_ADDR	./include/types/sample.h	/^	SMP_T_ADDR,      \/* ipv4 or ipv6, only used for input type compatibility *\/$/;"	e	enum:__anon115
SMP_T_ANY	./include/types/sample.h	/^	SMP_T_ANY = 0,   \/* any type *\/$/;"	e	enum:__anon115
SMP_T_BIN	./include/types/sample.h	/^	SMP_T_BIN,       \/* buffer type *\/$/;"	e	enum:__anon115
SMP_T_BOOL	./include/types/sample.h	/^	SMP_T_BOOL,      \/* boolean *\/$/;"	e	enum:__anon115
SMP_T_IPV4	./include/types/sample.h	/^	SMP_T_IPV4,      \/* ipv4 type *\/$/;"	e	enum:__anon115
SMP_T_IPV6	./include/types/sample.h	/^	SMP_T_IPV6,      \/* ipv6 type *\/$/;"	e	enum:__anon115
SMP_T_METH	./include/types/sample.h	/^	SMP_T_METH,      \/* contain method *\/$/;"	e	enum:__anon115
SMP_T_SINT	./include/types/sample.h	/^	SMP_T_SINT,      \/* signed 64bits integer type *\/$/;"	e	enum:__anon115
SMP_T_STR	./include/types/sample.h	/^	SMP_T_STR,       \/* char string type *\/$/;"	e	enum:__anon115
SMP_USE_BKEND	./include/types/sample.h	/^	SMP_USE_BKEND = 1 << SMP_SRC_BKEND,  \/* fetch uses information about the backend *\/$/;"	e	enum:__anon118
SMP_USE_FTEND	./include/types/sample.h	/^	SMP_USE_FTEND = 1 << SMP_SRC_FTEND,  \/* frontend which accepted the connection *\/$/;"	e	enum:__anon118
SMP_USE_HRQBO	./include/types/sample.h	/^	SMP_USE_HRQBO = 1 << SMP_SRC_HRQBO,  \/* fetch uses information about HTTP request body *\/$/;"	e	enum:__anon118
SMP_USE_HRQHP	./include/types/sample.h	/^	SMP_USE_HRQHP = 1 << SMP_SRC_HRQHP,  \/* fetch uses persistent information about HTTP request headers (eg: meth) *\/$/;"	e	enum:__anon118
SMP_USE_HRQHV	./include/types/sample.h	/^	SMP_USE_HRQHV = 1 << SMP_SRC_HRQHV,  \/* fetch uses volatile information about HTTP request headers (eg: value) *\/$/;"	e	enum:__anon118
SMP_USE_HRSBO	./include/types/sample.h	/^	SMP_USE_HRSBO = 1 << SMP_SRC_HRSBO,  \/* fetch uses information about HTTP response body *\/$/;"	e	enum:__anon118
SMP_USE_HRSHP	./include/types/sample.h	/^	SMP_USE_HRSHP = 1 << SMP_SRC_HRSHP,  \/* fetch uses persistent information about HTTP response headers (eg: status) *\/$/;"	e	enum:__anon118
SMP_USE_HRSHV	./include/types/sample.h	/^	SMP_USE_HRSHV = 1 << SMP_SRC_HRSHV,  \/* fetch uses volatile information about HTTP response headers (eg: value) *\/$/;"	e	enum:__anon118
SMP_USE_HTTP_ANY	./include/types/sample.h	/^	SMP_USE_HTTP_ANY = SMP_USE_HRQHV | SMP_USE_HRQHP | SMP_USE_HRQBO |$/;"	e	enum:__anon118
SMP_USE_INTRN	./include/types/sample.h	/^	SMP_USE_INTRN = 1 << SMP_SRC_INTRN,  \/* internal context-less information *\/$/;"	e	enum:__anon118
SMP_USE_L4CLI	./include/types/sample.h	/^	SMP_USE_L4CLI = 1 << SMP_SRC_L4CLI,  \/* L4 information about the client *\/$/;"	e	enum:__anon118
SMP_USE_L4SRV	./include/types/sample.h	/^	SMP_USE_L4SRV = 1 << SMP_SRC_L4SRV,  \/* fetch uses information about the server L4 connection *\/$/;"	e	enum:__anon118
SMP_USE_L5CLI	./include/types/sample.h	/^	SMP_USE_L5CLI = 1 << SMP_SRC_L5CLI,  \/* fetch uses client information from embryonic session *\/$/;"	e	enum:__anon118
SMP_USE_L5SRV	./include/types/sample.h	/^	SMP_USE_L5SRV = 1 << SMP_SRC_L5SRV,  \/* fetch uses information about the server L5 connection *\/$/;"	e	enum:__anon118
SMP_USE_L6REQ	./include/types/sample.h	/^	SMP_USE_L6REQ = 1 << SMP_SRC_L6REQ,  \/* fetch uses raw information from the request buffer *\/$/;"	e	enum:__anon118
SMP_USE_L6RES	./include/types/sample.h	/^	SMP_USE_L6RES = 1 << SMP_SRC_L6RES,  \/* fetch uses raw information from the response buffer *\/$/;"	e	enum:__anon118
SMP_USE_LISTN	./include/types/sample.h	/^	SMP_USE_LISTN = 1 << SMP_SRC_LISTN,  \/* listener which accepted the connection *\/$/;"	e	enum:__anon118
SMP_USE_RQFIN	./include/types/sample.h	/^	SMP_USE_RQFIN = 1 << SMP_SRC_RQFIN,  \/* final information about request buffer (eg: tot bytes) *\/$/;"	e	enum:__anon118
SMP_USE_RSFIN	./include/types/sample.h	/^	SMP_USE_RSFIN = 1 << SMP_SRC_RSFIN,  \/* final information about response buffer (eg: tot bytes) *\/$/;"	e	enum:__anon118
SMP_USE_SERVR	./include/types/sample.h	/^	SMP_USE_SERVR = 1 << SMP_SRC_SERVR,  \/* fetch uses information about the selected server *\/$/;"	e	enum:__anon118
SMP_USE_SSFIN	./include/types/sample.h	/^	SMP_USE_SSFIN = 1 << SMP_SRC_SSFIN,  \/* final information about the stream (eg: #requests, final flags) *\/$/;"	e	enum:__anon118
SMP_USE_TRACK	./include/types/sample.h	/^	SMP_USE_TRACK = 1 << SMP_SRC_TRACK,  \/* fetch involves track counters *\/$/;"	e	enum:__anon118
SMP_USE_TXFIN	./include/types/sample.h	/^	SMP_USE_TXFIN = 1 << SMP_SRC_TXFIN,  \/* final information about the transaction (eg: #comp rate) *\/$/;"	e	enum:__anon118
SMP_VAL_BE_HRQ_BDY	./include/types/sample.h	/^	SMP_VAL_BE_HRQ_BDY = 1 << SMP_CKP_BE_HRQ_BDY,  \/* BE HTTP request body *\/$/;"	e	enum:__anon119
SMP_VAL_BE_HRQ_HDR	./include/types/sample.h	/^	SMP_VAL_BE_HRQ_HDR = 1 << SMP_CKP_BE_HRQ_HDR,  \/* BE HTTP request headers (rules, headers, monitor, stats, redirect) *\/$/;"	e	enum:__anon119
SMP_VAL_BE_HRS_BDY	./include/types/sample.h	/^	SMP_VAL_BE_HRS_BDY = 1 << SMP_CKP_BE_HRS_BDY,  \/* BE HTTP response body (stick-store rules are there) *\/$/;"	e	enum:__anon119
SMP_VAL_BE_HRS_HDR	./include/types/sample.h	/^	SMP_VAL_BE_HRS_HDR = 1 << SMP_CKP_BE_HRS_HDR,  \/* BE HTTP response headers (rules, headers) *\/$/;"	e	enum:__anon119
SMP_VAL_BE_REQ_CNT	./include/types/sample.h	/^	SMP_VAL_BE_REQ_CNT = 1 << SMP_CKP_BE_REQ_CNT,  \/* BE request content rules ("tcp request content") *\/$/;"	e	enum:__anon119
SMP_VAL_BE_RES_CNT	./include/types/sample.h	/^	SMP_VAL_BE_RES_CNT = 1 << SMP_CKP_BE_RES_CNT,  \/* BE response content rules ("tcp response content") *\/$/;"	e	enum:__anon119
SMP_VAL_BE_SET_SRV	./include/types/sample.h	/^	SMP_VAL_BE_SET_SRV = 1 << SMP_CKP_BE_SET_SRV,  \/* BE server switching rules ("use_server", "balance", "force-persist", "stick", ...) *\/$/;"	e	enum:__anon119
SMP_VAL_BE_SRV_CON	./include/types/sample.h	/^	SMP_VAL_BE_SRV_CON = 1 << SMP_CKP_BE_SRV_CON,  \/* BE server connect (eg: "source") *\/$/;"	e	enum:__anon119
SMP_VAL_BE_STO_RUL	./include/types/sample.h	/^	SMP_VAL_BE_STO_RUL = 1 << SMP_CKP_BE_STO_RUL,  \/* BE stick-store rules *\/$/;"	e	enum:__anon119
SMP_VAL_FE_CON_ACC	./include/types/sample.h	/^	SMP_VAL_FE_CON_ACC = 1 << SMP_CKP_FE_CON_ACC,  \/* FE connection accept rules ("tcp request connection") *\/$/;"	e	enum:__anon119
SMP_VAL_FE_HRQ_BDY	./include/types/sample.h	/^	SMP_VAL_FE_HRQ_BDY = 1 << SMP_CKP_FE_HRQ_BDY,  \/* FE HTTP request body *\/$/;"	e	enum:__anon119
SMP_VAL_FE_HRQ_HDR	./include/types/sample.h	/^	SMP_VAL_FE_HRQ_HDR = 1 << SMP_CKP_FE_HRQ_HDR,  \/* FE HTTP request headers (rules, headers, monitor, stats, redirect) *\/$/;"	e	enum:__anon119
SMP_VAL_FE_HRS_BDY	./include/types/sample.h	/^	SMP_VAL_FE_HRS_BDY = 1 << SMP_CKP_FE_HRS_BDY,  \/* FE HTTP response body *\/$/;"	e	enum:__anon119
SMP_VAL_FE_HRS_HDR	./include/types/sample.h	/^	SMP_VAL_FE_HRS_HDR = 1 << SMP_CKP_FE_HRS_HDR,  \/* FE HTTP response headers (rules, headers) *\/$/;"	e	enum:__anon119
SMP_VAL_FE_LOG_END	./include/types/sample.h	/^	SMP_VAL_FE_LOG_END = 1 << SMP_CKP_FE_LOG_END,  \/* FE log at the end of the txn\/stream *\/$/;"	e	enum:__anon119
SMP_VAL_FE_REQ_CNT	./include/types/sample.h	/^	SMP_VAL_FE_REQ_CNT = 1 << SMP_CKP_FE_REQ_CNT,  \/* FE request content rules ("tcp request content") *\/$/;"	e	enum:__anon119
SMP_VAL_FE_RES_CNT	./include/types/sample.h	/^	SMP_VAL_FE_RES_CNT = 1 << SMP_CKP_FE_RES_CNT,  \/* FE response content rules ("tcp response content") *\/$/;"	e	enum:__anon119
SMP_VAL_FE_SES_ACC	./include/types/sample.h	/^	SMP_VAL_FE_SES_ACC = 1 << SMP_CKP_FE_SES_ACC,  \/* FE stream accept rules (to come soon) *\/$/;"	e	enum:__anon119
SMP_VAL_FE_SET_BCK	./include/types/sample.h	/^	SMP_VAL_FE_SET_BCK = 1 << SMP_CKP_FE_SET_BCK,  \/* FE backend switching rules ("use_backend") *\/$/;"	e	enum:__anon119
SMP_VAL_REQUEST	./include/types/sample.h	/^	SMP_VAL_REQUEST    = SMP_VAL_FE_CON_ACC | SMP_VAL_FE_SES_ACC | SMP_VAL_FE_REQ_CNT |$/;"	e	enum:__anon119
SMP_VAL_RESPONSE	./include/types/sample.h	/^	SMP_VAL_RESPONSE   = SMP_VAL_BE_SRV_CON | SMP_VAL_BE_RES_CNT | SMP_VAL_BE_HRS_HDR |$/;"	e	enum:__anon119
SMP_VAL___________	./include/types/sample.h	/^	SMP_VAL___________ = 0,        \/* Just used as a visual marker *\/$/;"	e	enum:__anon119
SOCKET_INFO_MAX_LEN	./src/hlua.c	/^#define SOCKET_INFO_MAX_LEN /;"	d	file:
SOCK_NONBLOCK	./include/common/accept4.h	/^#define SOCK_NONBLOCK /;"	d
SOL_IP	./include/common/compat.h	/^#define SOL_IP /;"	d
SOURCE_FIELD	./contrib/halog/halog.c	/^#define SOURCE_FIELD /;"	d	file:
SO_REUSEPORT	./include/common/compat.h	/^#define SO_REUSEPORT /;"	d
SPEC_CFLAGS	./Makefile	/^SPEC_CFLAGS = -fno-strict-aliasing -Wdeclaration-after-statement$/;"	m
SPHINXBUILD	./doc/lua-api/Makefile	/^SPHINXBUILD   = sphinx-build$/;"	m
SPHINXOPTS	./doc/lua-api/Makefile	/^SPHINXOPTS    =$/;"	m
SPLICE_FULL_HINT	./src/raw_sock.c	/^#define SPLICE_FULL_HINT	/;"	d	file:
SPLICE_F_MORE	./include/common/splice.h	/^#define SPLICE_F_MORE /;"	d
SPLICE_F_MOVE	./include/common/splice.h	/^#define SPLICE_F_MOVE /;"	d
SPLICE_F_NONBLOCK	./include/common/splice.h	/^#define SPLICE_F_NONBLOCK /;"	d
SRV_ADMF_CMAINT	./include/types/server.h	/^	SRV_ADMF_CMAINT    = 0x04,        \/* the server is in maintenance because of the configuration *\/$/;"	e	enum:srv_admin
SRV_ADMF_DRAIN	./include/types/server.h	/^	SRV_ADMF_DRAIN     = 0x18,        \/* mask to check if any drain flag is present *\/$/;"	e	enum:srv_admin
SRV_ADMF_FDRAIN	./include/types/server.h	/^	SRV_ADMF_FDRAIN    = 0x08,        \/* the server was explicitly forced into drain state *\/$/;"	e	enum:srv_admin
SRV_ADMF_FMAINT	./include/types/server.h	/^	SRV_ADMF_FMAINT    = 0x01,        \/* the server was explicitly forced into maintenance *\/$/;"	e	enum:srv_admin
SRV_ADMF_IDRAIN	./include/types/server.h	/^	SRV_ADMF_IDRAIN    = 0x10,        \/* the server has inherited the drain status from a tracked server *\/$/;"	e	enum:srv_admin
SRV_ADMF_IMAINT	./include/types/server.h	/^	SRV_ADMF_IMAINT    = 0x02,        \/* the server has inherited the maintenance status from a tracked server *\/$/;"	e	enum:srv_admin
SRV_ADMF_MAINT	./include/types/server.h	/^	SRV_ADMF_MAINT     = 0x03,        \/* mask to check if any maintenance flag is present *\/$/;"	e	enum:srv_admin
SRV_CHK_INTER_THRES	./include/common/defaults.h	/^#define SRV_CHK_INTER_THRES /;"	d
SRV_EWGHT_MAX	./include/types/server.h	/^#define SRV_EWGHT_MAX /;"	d
SRV_EWGHT_RANGE	./include/types/server.h	/^#define SRV_EWGHT_RANGE /;"	d
SRV_F_BACKUP	./include/types/server.h	/^#define SRV_F_BACKUP /;"	d
SRV_F_FORCED_ID	./include/types/server.h	/^#define SRV_F_FORCED_ID /;"	d
SRV_F_MAPPORTS	./include/types/server.h	/^#define SRV_F_MAPPORTS /;"	d
SRV_F_NON_STICK	./include/types/server.h	/^#define SRV_F_NON_STICK /;"	d
SRV_F_USE_NS_FROM_PP	./include/types/server.h	/^#define SRV_F_USE_NS_FROM_PP /;"	d
SRV_PP_V1	./include/types/server.h	/^#define SRV_PP_V1 /;"	d
SRV_PP_V2	./include/types/server.h	/^#define SRV_PP_V2 /;"	d
SRV_PP_V2_SSL	./include/types/server.h	/^#define SRV_PP_V2_SSL /;"	d
SRV_PP_V2_SSL_CN	./include/types/server.h	/^#define SRV_PP_V2_SSL_CN /;"	d
SRV_SSL_O_NONE	./include/types/server.h	/^#define SRV_SSL_O_NONE /;"	d
SRV_SSL_O_NO_REUSE	./include/types/server.h	/^#define SRV_SSL_O_NO_REUSE /;"	d
SRV_SSL_O_NO_SSLV3	./include/types/server.h	/^#define SRV_SSL_O_NO_SSLV3 /;"	d
SRV_SSL_O_NO_TLSV10	./include/types/server.h	/^#define SRV_SSL_O_NO_TLSV10 /;"	d
SRV_SSL_O_NO_TLSV11	./include/types/server.h	/^#define SRV_SSL_O_NO_TLSV11 /;"	d
SRV_SSL_O_NO_TLSV12	./include/types/server.h	/^#define SRV_SSL_O_NO_TLSV12 /;"	d
SRV_SSL_O_NO_TLS_TICKETS	./include/types/server.h	/^#define SRV_SSL_O_NO_TLS_TICKETS /;"	d
SRV_SSL_O_NO_VMASK	./include/types/server.h	/^#define SRV_SSL_O_NO_VMASK /;"	d
SRV_SSL_O_USE_SSLV3	./include/types/server.h	/^#define SRV_SSL_O_USE_SSLV3 /;"	d
SRV_SSL_O_USE_TLSV10	./include/types/server.h	/^#define SRV_SSL_O_USE_TLSV10 /;"	d
SRV_SSL_O_USE_TLSV11	./include/types/server.h	/^#define SRV_SSL_O_USE_TLSV11 /;"	d
SRV_SSL_O_USE_TLSV12	./include/types/server.h	/^#define SRV_SSL_O_USE_TLSV12 /;"	d
SRV_SSL_O_USE_VMASK	./include/types/server.h	/^#define SRV_SSL_O_USE_VMASK /;"	d
SRV_STATE_FILE_FIELD_NAMES	./include/types/server.h	/^#define SRV_STATE_FILE_FIELD_NAMES /;"	d
SRV_STATE_FILE_MAX_FIELDS	./include/types/server.h	/^#define SRV_STATE_FILE_MAX_FIELDS /;"	d
SRV_STATE_FILE_NB_FIELDS_VERSION_1	./include/types/server.h	/^#define SRV_STATE_FILE_NB_FIELDS_VERSION_1 /;"	d
SRV_STATE_FILE_VERSION	./include/types/server.h	/^#define SRV_STATE_FILE_VERSION /;"	d
SRV_STATE_FILE_VERSION_MAX	./include/types/server.h	/^#define SRV_STATE_FILE_VERSION_MAX /;"	d
SRV_STATE_FILE_VERSION_MIN	./include/types/server.h	/^#define SRV_STATE_FILE_VERSION_MIN /;"	d
SRV_STATE_LINE_MAXLEN	./include/types/server.h	/^#define SRV_STATE_LINE_MAXLEN /;"	d
SRV_STATS_COLOUR_COUNT	./src/dumpstats.c	/^	SRV_STATS_COLOUR_COUNT, \/* Must be last *\/$/;"	e	enum:srv_stats_colour	file:
SRV_STATS_COLOUR_DOWN	./src/dumpstats.c	/^	SRV_STATS_COLOUR_DOWN = 0,$/;"	e	enum:srv_stats_colour	file:
SRV_STATS_COLOUR_DRAINING	./src/dumpstats.c	/^	SRV_STATS_COLOUR_DRAINING,$/;"	e	enum:srv_stats_colour	file:
SRV_STATS_COLOUR_GOING_DOWN	./src/dumpstats.c	/^	SRV_STATS_COLOUR_GOING_DOWN,$/;"	e	enum:srv_stats_colour	file:
SRV_STATS_COLOUR_GOING_UP	./src/dumpstats.c	/^	SRV_STATS_COLOUR_GOING_UP,$/;"	e	enum:srv_stats_colour	file:
SRV_STATS_COLOUR_NOLB	./src/dumpstats.c	/^	SRV_STATS_COLOUR_NOLB,$/;"	e	enum:srv_stats_colour	file:
SRV_STATS_COLOUR_NO_CHECK	./src/dumpstats.c	/^	SRV_STATS_COLOUR_NO_CHECK,$/;"	e	enum:srv_stats_colour	file:
SRV_STATS_COLOUR_UP	./src/dumpstats.c	/^	SRV_STATS_COLOUR_UP,$/;"	e	enum:srv_stats_colour	file:
SRV_STATS_STATE_COUNT	./src/dumpstats.c	/^	SRV_STATS_STATE_COUNT, \/* Must be last *\/$/;"	e	enum:srv_stats_state	file:
SRV_STATS_STATE_DOWN	./src/dumpstats.c	/^	SRV_STATS_STATE_DOWN = 0,$/;"	e	enum:srv_stats_state	file:
SRV_STATS_STATE_DOWN_AGENT	./src/dumpstats.c	/^	SRV_STATS_STATE_DOWN_AGENT,$/;"	e	enum:srv_stats_state	file:
SRV_STATS_STATE_DRAIN	./src/dumpstats.c	/^	SRV_STATS_STATE_DRAIN,$/;"	e	enum:srv_stats_state	file:
SRV_STATS_STATE_DRAIN_AGENT	./src/dumpstats.c	/^	SRV_STATS_STATE_DRAIN_AGENT,$/;"	e	enum:srv_stats_state	file:
SRV_STATS_STATE_DRAIN_GOING_DOWN	./src/dumpstats.c	/^	SRV_STATS_STATE_DRAIN_GOING_DOWN,$/;"	e	enum:srv_stats_state	file:
SRV_STATS_STATE_GOING_UP	./src/dumpstats.c	/^	SRV_STATS_STATE_GOING_UP,$/;"	e	enum:srv_stats_state	file:
SRV_STATS_STATE_NOLB	./src/dumpstats.c	/^	SRV_STATS_STATE_NOLB,$/;"	e	enum:srv_stats_state	file:
SRV_STATS_STATE_NOLB_GOING_DOWN	./src/dumpstats.c	/^	SRV_STATS_STATE_NOLB_GOING_DOWN,$/;"	e	enum:srv_stats_state	file:
SRV_STATS_STATE_NO_CHECK	./src/dumpstats.c	/^	SRV_STATS_STATE_NO_CHECK,$/;"	e	enum:srv_stats_state	file:
SRV_STATS_STATE_UP	./src/dumpstats.c	/^	SRV_STATS_STATE_UP,$/;"	e	enum:srv_stats_state	file:
SRV_STATS_STATE_UP_GOING_DOWN	./src/dumpstats.c	/^	SRV_STATS_STATE_UP_GOING_DOWN,$/;"	e	enum:srv_stats_state	file:
SRV_STATUS_FULL	./include/types/server.h	/^#define SRV_STATUS_FULL /;"	d
SRV_STATUS_INTERNAL	./include/types/server.h	/^#define SRV_STATUS_INTERNAL /;"	d
SRV_STATUS_NOSRV	./include/types/server.h	/^#define SRV_STATUS_NOSRV /;"	d
SRV_STATUS_OK	./include/types/server.h	/^#define SRV_STATUS_OK /;"	d
SRV_STATUS_QUEUED	./include/types/server.h	/^#define SRV_STATUS_QUEUED /;"	d
SRV_ST_RUNNING	./include/types/server.h	/^	SRV_ST_RUNNING,                  \/* the server is fully up *\/$/;"	e	enum:srv_state
SRV_ST_STARTING	./include/types/server.h	/^	SRV_ST_STARTING,                 \/* the server is warming up (up but throttled) *\/$/;"	e	enum:srv_state
SRV_ST_STOPPED	./include/types/server.h	/^	SRV_ST_STOPPED = 0,              \/* the server is down. Please keep set to zero. *\/$/;"	e	enum:srv_state
SRV_ST_STOPPING	./include/types/server.h	/^	SRV_ST_STOPPING,                 \/* the server is up but soft-stopping (eg: 404) *\/$/;"	e	enum:srv_state
SRV_UWGHT_MAX	./include/types/server.h	/^#define SRV_UWGHT_MAX /;"	d
SRV_UWGHT_RANGE	./include/types/server.h	/^#define SRV_UWGHT_RANGE /;"	d
SSLCACHESIZE	./include/common/defaults.h	/^#define SSLCACHESIZE /;"	d
SSL_DEFAULT_DH_PARAM	./include/common/defaults.h	/^#define SSL_DEFAULT_DH_PARAM /;"	d
SSL_HANDSHAKE_MAX_COST	./include/common/defaults.h	/^#define SSL_HANDSHAKE_MAX_COST /;"	d
SSL_MODE_RELEASE_BUFFERS	./src/ssl_sock.c	/^#define SSL_MODE_RELEASE_BUFFERS /;"	d	file:
SSL_MODE_SMALL_BUFFERS	./src/ssl_sock.c	/^#define SSL_MODE_SMALL_BUFFERS /;"	d	file:
SSL_OP_CIPHER_SERVER_PREFERENCE	./src/ssl_sock.c	/^#define SSL_OP_CIPHER_SERVER_PREFERENCE /;"	d	file:
SSL_OP_NO_COMPRESSION	./src/ssl_sock.c	/^#define SSL_OP_NO_COMPRESSION /;"	d	file:
SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION	./src/ssl_sock.c	/^#define SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION /;"	d	file:
SSL_OP_NO_TICKET	./src/ssl_sock.c	/^#define SSL_OP_NO_TICKET /;"	d	file:
SSL_OP_NO_TLSv1_1	./src/ssl_sock.c	/^#define SSL_OP_NO_TLSv1_1 /;"	d	file:
SSL_OP_NO_TLSv1_2	./src/ssl_sock.c	/^#define SSL_OP_NO_TLSv1_2 /;"	d	file:
SSL_OP_SINGLE_DH_USE	./src/ssl_sock.c	/^#define SSL_OP_SINGLE_DH_USE /;"	d	file:
SSL_OP_SINGLE_ECDH_USE	./src/ssl_sock.c	/^#define SSL_OP_SINGLE_ECDH_USE /;"	d	file:
SSL_SERVER_VERIFY_NONE	./include/types/global.h	/^	SSL_SERVER_VERIFY_NONE = 0,$/;"	e	enum:__anon71
SSL_SERVER_VERIFY_REQUIRED	./include/types/global.h	/^	SSL_SERVER_VERIFY_REQUIRED = 1,$/;"	e	enum:__anon71
SSL_SESSION_MAX_COST	./include/common/defaults.h	/^#define SSL_SESSION_MAX_COST /;"	d
SSL_SOCK_CAEDEPTH_TO_ST	./src/ssl_sock.c	/^#define SSL_SOCK_CAEDEPTH_TO_ST(/;"	d	file:
SSL_SOCK_CA_ERROR_TO_ST	./src/ssl_sock.c	/^#define SSL_SOCK_CA_ERROR_TO_ST(/;"	d	file:
SSL_SOCK_CRTERROR_TO_ST	./src/ssl_sock.c	/^#define SSL_SOCK_CRTERROR_TO_ST(/;"	d	file:
SSL_SOCK_RECV_HEARTBEAT	./src/ssl_sock.c	/^#define SSL_SOCK_RECV_HEARTBEAT /;"	d	file:
SSL_SOCK_SEND_UNLIMITED	./src/ssl_sock.c	/^#define SSL_SOCK_SEND_UNLIMITED /;"	d	file:
SSL_SOCK_ST_FL_16K_WBFSIZE	./src/ssl_sock.c	/^#define SSL_SOCK_ST_FL_16K_WBFSIZE /;"	d	file:
SSL_SOCK_ST_FL_VERIFY_DONE	./src/ssl_sock.c	/^#define SSL_SOCK_ST_FL_VERIFY_DONE /;"	d	file:
SSL_SOCK_ST_TO_CAEDEPTH	./src/ssl_sock.c	/^#define SSL_SOCK_ST_TO_CAEDEPTH(/;"	d	file:
SSL_SOCK_ST_TO_CA_ERROR	./src/ssl_sock.c	/^#define SSL_SOCK_ST_TO_CA_ERROR(/;"	d	file:
SSL_SOCK_ST_TO_CRTERROR	./src/ssl_sock.c	/^#define SSL_SOCK_ST_TO_CRTERROR(/;"	d	file:
SSL_SOCK_VERIFY_DEFAULT	./src/ssl_sock.c	/^	SSL_SOCK_VERIFY_DEFAULT  = 0,$/;"	e	enum:__anon145	file:
SSL_SOCK_VERIFY_NONE	./src/ssl_sock.c	/^	SSL_SOCK_VERIFY_NONE     = 3,$/;"	e	enum:__anon145	file:
SSL_SOCK_VERIFY_OPTIONAL	./src/ssl_sock.c	/^	SSL_SOCK_VERIFY_OPTIONAL = 2,$/;"	e	enum:__anon145	file:
SSL_SOCK_VERIFY_REQUIRED	./src/ssl_sock.c	/^	SSL_SOCK_VERIFY_REQUIRED = 1,$/;"	e	enum:__anon145	file:
SSL_renegotiate_pending	./src/ssl_sock.c	/^#define SSL_renegotiate_pending(/;"	d	file:
STATS_DEFAULT_REALM	./include/common/uri_auth.h	/^#define STATS_DEFAULT_REALM /;"	d
STATS_DEFAULT_URI	./include/common/uri_auth.h	/^#define STATS_DEFAULT_URI /;"	d
STATS_IID	./contrib/netsnmp-perl/haproxy.pl	/^use constant STATS_IID => 27;$/;"	c
STATS_PXNAME	./contrib/netsnmp-perl/haproxy.pl	/^use constant STATS_PXNAME => 0;$/;"	c
STATS_SID	./contrib/netsnmp-perl/haproxy.pl	/^use constant STATS_SID => 28;$/;"	c
STATS_SVNAME	./contrib/netsnmp-perl/haproxy.pl	/^use constant STATS_SVNAME => 1;$/;"	c
STATS_TYPE	./contrib/netsnmp-perl/haproxy.pl	/^use constant STATS_TYPE => 32;$/;"	c
STATS_TYPE_BE	./include/proto/dumpstats.h	/^#define STATS_TYPE_BE /;"	d
STATS_TYPE_FE	./include/proto/dumpstats.h	/^#define STATS_TYPE_FE /;"	d
STATS_TYPE_SO	./include/proto/dumpstats.h	/^#define STATS_TYPE_SO /;"	d
STATS_TYPE_SV	./include/proto/dumpstats.h	/^#define STATS_TYPE_SV /;"	d
STATS_VERSION_STRING	./include/common/defaults.h	/^#define STATS_VERSION_STRING /;"	d
STATUS_FIELD	./contrib/halog/halog.c	/^#define STATUS_FIELD /;"	d	file:
STAT_ADMIN	./include/proto/dumpstats.h	/^#define STAT_ADMIN /;"	d
STAT_BOUND	./include/proto/dumpstats.h	/^#define STAT_BOUND /;"	d
STAT_CHUNKED	./include/proto/dumpstats.h	/^#define STAT_CHUNKED /;"	d
STAT_CLI_END	./src/dumpstats.c	/^	STAT_CLI_END,        \/* final state, let's close *\/$/;"	e	enum:__anon134	file:
STAT_CLI_GETREQ	./src/dumpstats.c	/^	STAT_CLI_GETREQ,     \/* wait for a request *\/$/;"	e	enum:__anon134	file:
STAT_CLI_INIT	./src/dumpstats.c	/^	STAT_CLI_INIT = 0,   \/* initial state, must leave to zero ! *\/$/;"	e	enum:__anon134	file:
STAT_CLI_OUTPUT	./src/dumpstats.c	/^	STAT_CLI_OUTPUT,     \/* all states after this one are responses *\/$/;"	e	enum:__anon134	file:
STAT_CLI_O_BACKEND	./src/dumpstats.c	/^	STAT_CLI_O_BACKEND,  \/* dump backend list *\/$/;"	e	enum:__anon134	file:
STAT_CLI_O_CLR	./src/dumpstats.c	/^	STAT_CLI_O_CLR,      \/* clear tables *\/$/;"	e	enum:__anon134	file:
STAT_CLI_O_ERR	./src/dumpstats.c	/^	STAT_CLI_O_ERR,      \/* dump errors *\/$/;"	e	enum:__anon134	file:
STAT_CLI_O_INFO	./src/dumpstats.c	/^	STAT_CLI_O_INFO,     \/* dump info *\/$/;"	e	enum:__anon134	file:
STAT_CLI_O_MLOOK	./src/dumpstats.c	/^	STAT_CLI_O_MLOOK,    \/* lookup a map entry *\/$/;"	e	enum:__anon134	file:
STAT_CLI_O_PAT	./src/dumpstats.c	/^	STAT_CLI_O_PAT,      \/* list all entries of a pattern *\/$/;"	e	enum:__anon134	file:
STAT_CLI_O_PATS	./src/dumpstats.c	/^	STAT_CLI_O_PATS,     \/* list all pattern reference avalaible *\/$/;"	e	enum:__anon134	file:
STAT_CLI_O_POOLS	./src/dumpstats.c	/^	STAT_CLI_O_POOLS,    \/* dump memory pools *\/$/;"	e	enum:__anon134	file:
STAT_CLI_O_RESOLVERS	./src/dumpstats.c	/^	STAT_CLI_O_RESOLVERS,\/* dump a resolver's section nameservers counters *\/$/;"	e	enum:__anon134	file:
STAT_CLI_O_SERVERS_STATE	./src/dumpstats.c	/^	STAT_CLI_O_SERVERS_STATE, \/* dump server state and changing information *\/$/;"	e	enum:__anon134	file:
STAT_CLI_O_SESS	./src/dumpstats.c	/^	STAT_CLI_O_SESS,     \/* dump streams *\/$/;"	e	enum:__anon134	file:
STAT_CLI_O_SET	./src/dumpstats.c	/^	STAT_CLI_O_SET,      \/* set entries in tables *\/$/;"	e	enum:__anon134	file:
STAT_CLI_O_STAT	./src/dumpstats.c	/^	STAT_CLI_O_STAT,     \/* dump stats *\/$/;"	e	enum:__anon134	file:
STAT_CLI_O_TAB	./src/dumpstats.c	/^	STAT_CLI_O_TAB,      \/* dump tables *\/$/;"	e	enum:__anon134	file:
STAT_CLI_O_TLSK	./src/dumpstats.c	/^	STAT_CLI_O_TLSK,     \/* list all TLS ticket keys references *\/$/;"	e	enum:__anon134	file:
STAT_CLI_PRINT	./src/dumpstats.c	/^	STAT_CLI_PRINT,      \/* display message in cli->msg *\/$/;"	e	enum:__anon134	file:
STAT_CLI_PRINT_FREE	./src/dumpstats.c	/^	STAT_CLI_PRINT_FREE, \/* display message in cli->msg. After the display, free the pointer *\/$/;"	e	enum:__anon134	file:
STAT_CLI_PROMPT	./src/dumpstats.c	/^	STAT_CLI_PROMPT,     \/* display the prompt (first output, same code) *\/$/;"	e	enum:__anon134	file:
STAT_FMT_HTML	./include/proto/dumpstats.h	/^#define STAT_FMT_HTML /;"	d
STAT_HIDE_DOWN	./include/proto/dumpstats.h	/^#define STAT_HIDE_DOWN /;"	d
STAT_HTTP_DONE	./include/proto/dumpstats.h	/^	STAT_HTTP_DONE = 0,  \/* finished *\/$/;"	e	enum:__anon8
STAT_HTTP_DUMP	./include/proto/dumpstats.h	/^	STAT_HTTP_DUMP,      \/* dumping stats *\/$/;"	e	enum:__anon8
STAT_HTTP_HEAD	./include/proto/dumpstats.h	/^	STAT_HTTP_HEAD,      \/* send headers before dump *\/$/;"	e	enum:__anon8
STAT_HTTP_LAST	./include/proto/dumpstats.h	/^	STAT_HTTP_LAST,      \/* sending last chunk of response *\/$/;"	e	enum:__anon8
STAT_HTTP_POST	./include/proto/dumpstats.h	/^	STAT_HTTP_POST,      \/* waiting post data *\/$/;"	e	enum:__anon8
STAT_NO_REFRESH	./include/proto/dumpstats.h	/^#define STAT_NO_REFRESH /;"	d
STAT_PX_ST_BE	./src/dumpstats.c	/^	STAT_PX_ST_BE,$/;"	e	enum:__anon137	file:
STAT_PX_ST_END	./src/dumpstats.c	/^	STAT_PX_ST_END,$/;"	e	enum:__anon137	file:
STAT_PX_ST_FE	./src/dumpstats.c	/^	STAT_PX_ST_FE,$/;"	e	enum:__anon137	file:
STAT_PX_ST_FIN	./src/dumpstats.c	/^	STAT_PX_ST_FIN,$/;"	e	enum:__anon137	file:
STAT_PX_ST_INIT	./src/dumpstats.c	/^	STAT_PX_ST_INIT = 0,$/;"	e	enum:__anon137	file:
STAT_PX_ST_LI	./src/dumpstats.c	/^	STAT_PX_ST_LI,$/;"	e	enum:__anon137	file:
STAT_PX_ST_SV	./src/dumpstats.c	/^	STAT_PX_ST_SV,$/;"	e	enum:__anon137	file:
STAT_PX_ST_TH	./src/dumpstats.c	/^	STAT_PX_ST_TH,$/;"	e	enum:__anon137	file:
STAT_SCOPE_INPUT_NAME	./include/proto/dumpstats.h	/^#define STAT_SCOPE_INPUT_NAME /;"	d
STAT_SCOPE_PATTERN	./include/proto/dumpstats.h	/^#define STAT_SCOPE_PATTERN /;"	d
STAT_SCOPE_TXT_MAXLEN	./include/proto/dumpstats.h	/^#define STAT_SCOPE_TXT_MAXLEN /;"	d
STAT_STATUS_DENY	./include/types/proto_http.h	/^	STAT_STATUS_DENY,	\/* action denied *\/$/;"	e	enum:__anon98
STAT_STATUS_DONE	./include/types/proto_http.h	/^	STAT_STATUS_DONE,	\/* the action is successful *\/$/;"	e	enum:__anon98
STAT_STATUS_ERRP	./include/types/proto_http.h	/^	STAT_STATUS_ERRP,	\/* an error occured due to invalid values in parameters *\/$/;"	e	enum:__anon98
STAT_STATUS_EXCD	./include/types/proto_http.h	/^	STAT_STATUS_EXCD,	\/* an error occured because the buffer couldn't store all data *\/$/;"	e	enum:__anon98
STAT_STATUS_INIT	./include/types/proto_http.h	/^	STAT_STATUS_INIT = 0,$/;"	e	enum:__anon98
STAT_STATUS_NONE	./include/types/proto_http.h	/^	STAT_STATUS_NONE,	\/* nothing happened (no action chosen or servers state didn't change) *\/$/;"	e	enum:__anon98
STAT_STATUS_PART	./include/types/proto_http.h	/^	STAT_STATUS_PART,	\/* the action is partially successful *\/$/;"	e	enum:__anon98
STAT_STATUS_SIZE	./include/types/proto_http.h	/^	STAT_STATUS_SIZE$/;"	e	enum:__anon98
STAT_STATUS_UNKN	./include/types/proto_http.h	/^	STAT_STATUS_UNKN,	\/* an unknown error occured, shouldn't happen *\/$/;"	e	enum:__anon98
STAT_ST_END	./src/dumpstats.c	/^	STAT_ST_END,$/;"	e	enum:__anon136	file:
STAT_ST_FIN	./src/dumpstats.c	/^	STAT_ST_FIN,$/;"	e	enum:__anon136	file:
STAT_ST_HEAD	./src/dumpstats.c	/^	STAT_ST_HEAD,$/;"	e	enum:__anon136	file:
STAT_ST_INFO	./src/dumpstats.c	/^	STAT_ST_INFO,$/;"	e	enum:__anon136	file:
STAT_ST_INIT	./src/dumpstats.c	/^	STAT_ST_INIT = 0,$/;"	e	enum:__anon136	file:
STAT_ST_LIST	./src/dumpstats.c	/^	STAT_ST_LIST,$/;"	e	enum:__anon136	file:
STD_OP_EQ	./include/common/standard.h	/^	STD_OP_EQ = 2, STD_OP_NE = 3,$/;"	e	enum:__anon4
STD_OP_GE	./include/common/standard.h	/^	STD_OP_GE = 4, STD_OP_LT = 5,$/;"	e	enum:__anon4
STD_OP_GT	./include/common/standard.h	/^	STD_OP_LE = 0, STD_OP_GT = 1,$/;"	e	enum:__anon4
STD_OP_LE	./include/common/standard.h	/^	STD_OP_LE = 0, STD_OP_GT = 1,$/;"	e	enum:__anon4
STD_OP_LT	./include/common/standard.h	/^	STD_OP_GE = 4, STD_OP_LT = 5,$/;"	e	enum:__anon4
STD_OP_NE	./include/common/standard.h	/^	STD_OP_EQ = 2, STD_OP_NE = 3,$/;"	e	enum:__anon4
STD_T_FRQP	./include/types/stick_table.h	/^	STD_T_FRQP,               \/* data is of type freq_ctr_period *\/$/;"	e	enum:__anon125
STD_T_SINT	./include/types/stick_table.h	/^	STD_T_SINT = 0,           \/* data is of type signed int *\/$/;"	e	enum:__anon125
STD_T_UINT	./include/types/stick_table.h	/^	STD_T_UINT,               \/* data is of type unsigned int *\/$/;"	e	enum:__anon125
STD_T_ULL	./include/types/stick_table.h	/^	STD_T_ULL,                \/* data is of type unsigned long long *\/$/;"	e	enum:__anon125
STKCTR_TRACK_BACKEND	./include/types/stick_table.h	/^#define STKCTR_TRACK_BACKEND /;"	d
STKCTR_TRACK_CONTENT	./include/types/stick_table.h	/^#define STKCTR_TRACK_CONTENT /;"	d
STKTABLE_DATA_TYPES	./include/types/stick_table.h	/^	STKTABLE_DATA_TYPES = STKTABLE_STATIC_DATA_TYPES + STKTABLE_EXTRA_DATA_TYPES$/;"	e	enum:__anon124
STKTABLE_DT_BYTES_IN_CNT	./include/types/stick_table.h	/^	STKTABLE_DT_BYTES_IN_CNT, \/* cumulated bytes count from client to servers *\/$/;"	e	enum:__anon124
STKTABLE_DT_BYTES_IN_RATE	./include/types/stick_table.h	/^	STKTABLE_DT_BYTES_IN_RATE,\/* bytes rate from client to servers *\/$/;"	e	enum:__anon124
STKTABLE_DT_BYTES_OUT_CNT	./include/types/stick_table.h	/^	STKTABLE_DT_BYTES_OUT_CNT,\/* cumulated bytes count from servers to client *\/$/;"	e	enum:__anon124
STKTABLE_DT_BYTES_OUT_RATE	./include/types/stick_table.h	/^	STKTABLE_DT_BYTES_OUT_RATE,\/* bytes rate from servers to client *\/$/;"	e	enum:__anon124
STKTABLE_DT_CONN_CNT	./include/types/stick_table.h	/^	STKTABLE_DT_CONN_CNT,     \/* cumulated number of connections *\/$/;"	e	enum:__anon124
STKTABLE_DT_CONN_CUR	./include/types/stick_table.h	/^	STKTABLE_DT_CONN_CUR,     \/* concurrent number of connections *\/$/;"	e	enum:__anon124
STKTABLE_DT_CONN_RATE	./include/types/stick_table.h	/^	STKTABLE_DT_CONN_RATE,    \/* incoming connection rate *\/$/;"	e	enum:__anon124
STKTABLE_DT_GPC0	./include/types/stick_table.h	/^	STKTABLE_DT_GPC0,         \/* General Purpose Counter 0 (unsigned 32-bit integer) *\/$/;"	e	enum:__anon124
STKTABLE_DT_GPC0_RATE	./include/types/stick_table.h	/^	STKTABLE_DT_GPC0_RATE,    \/* General Purpose Counter 0's event rate *\/$/;"	e	enum:__anon124
STKTABLE_DT_GPT0	./include/types/stick_table.h	/^	STKTABLE_DT_GPT0,         \/* General Purpose Flag 0. *\/$/;"	e	enum:__anon124
STKTABLE_DT_HTTP_ERR_CNT	./include/types/stick_table.h	/^	STKTABLE_DT_HTTP_ERR_CNT, \/* cumulated number of HTTP requests errors (4xx) *\/$/;"	e	enum:__anon124
STKTABLE_DT_HTTP_ERR_RATE	./include/types/stick_table.h	/^	STKTABLE_DT_HTTP_ERR_RATE,\/* HTTP request error rate *\/$/;"	e	enum:__anon124
STKTABLE_DT_HTTP_REQ_CNT	./include/types/stick_table.h	/^	STKTABLE_DT_HTTP_REQ_CNT, \/* cumulated number of incoming HTTP requests *\/$/;"	e	enum:__anon124
STKTABLE_DT_HTTP_REQ_RATE	./include/types/stick_table.h	/^	STKTABLE_DT_HTTP_REQ_RATE,\/* incoming HTTP request rate *\/$/;"	e	enum:__anon124
STKTABLE_DT_SERVER_ID	./include/types/stick_table.h	/^	STKTABLE_DT_SERVER_ID,    \/* the server ID to use with this stream if > 0 *\/$/;"	e	enum:__anon124
STKTABLE_DT_SESS_CNT	./include/types/stick_table.h	/^	STKTABLE_DT_SESS_CNT,     \/* cumulated number of sessions (accepted connections) *\/$/;"	e	enum:__anon124
STKTABLE_DT_SESS_RATE	./include/types/stick_table.h	/^	STKTABLE_DT_SESS_RATE,    \/* accepted sessions rate *\/$/;"	e	enum:__anon124
STKTABLE_EXTRA_DATA_TYPES	./include/common/defaults.h	/^#define STKTABLE_EXTRA_DATA_TYPES /;"	d
STKTABLE_STATIC_DATA_TYPES	./include/types/stick_table.h	/^	STKTABLE_STATIC_DATA_TYPES,\/* number of types above *\/$/;"	e	enum:__anon124
STK_F_CUSTOM_KEYSIZE	./include/types/stick_table.h	/^#define STK_F_CUSTOM_KEYSIZE /;"	d
STK_IS_MATCH	./include/types/proxy.h	/^#define STK_IS_MATCH	/;"	d
STK_IS_STORE	./include/types/proxy.h	/^#define STK_IS_STORE	/;"	d
STK_ON_RSP	./include/types/proxy.h	/^#define STK_ON_RSP	/;"	d
STREAM_MAX_COST	./include/common/defaults.h	/^#define STREAM_MAX_COST /;"	d
ST_ADM_ACTION_ADOWN	./src/dumpstats.c	/^	ST_ADM_ACTION_ADOWN,$/;"	e	enum:__anon135	file:
ST_ADM_ACTION_ARUNN	./src/dumpstats.c	/^	ST_ADM_ACTION_ARUNN,$/;"	e	enum:__anon135	file:
ST_ADM_ACTION_DAGENT	./src/dumpstats.c	/^	ST_ADM_ACTION_DAGENT,$/;"	e	enum:__anon135	file:
ST_ADM_ACTION_DHLTH	./src/dumpstats.c	/^	ST_ADM_ACTION_DHLTH,$/;"	e	enum:__anon135	file:
ST_ADM_ACTION_DISABLE	./src/dumpstats.c	/^	ST_ADM_ACTION_DISABLE,$/;"	e	enum:__anon135	file:
ST_ADM_ACTION_DRAIN	./src/dumpstats.c	/^	ST_ADM_ACTION_DRAIN,$/;"	e	enum:__anon135	file:
ST_ADM_ACTION_EAGENT	./src/dumpstats.c	/^	ST_ADM_ACTION_EAGENT,$/;"	e	enum:__anon135	file:
ST_ADM_ACTION_EHLTH	./src/dumpstats.c	/^	ST_ADM_ACTION_EHLTH,$/;"	e	enum:__anon135	file:
ST_ADM_ACTION_ENABLE	./src/dumpstats.c	/^	ST_ADM_ACTION_ENABLE,$/;"	e	enum:__anon135	file:
ST_ADM_ACTION_HDOWN	./src/dumpstats.c	/^	ST_ADM_ACTION_HDOWN,$/;"	e	enum:__anon135	file:
ST_ADM_ACTION_HNOLB	./src/dumpstats.c	/^	ST_ADM_ACTION_HNOLB,$/;"	e	enum:__anon135	file:
ST_ADM_ACTION_HRUNN	./src/dumpstats.c	/^	ST_ADM_ACTION_HRUNN,$/;"	e	enum:__anon135	file:
ST_ADM_ACTION_MAINT	./src/dumpstats.c	/^	ST_ADM_ACTION_MAINT,$/;"	e	enum:__anon135	file:
ST_ADM_ACTION_NONE	./src/dumpstats.c	/^	ST_ADM_ACTION_NONE = 0,$/;"	e	enum:__anon135	file:
ST_ADM_ACTION_READY	./src/dumpstats.c	/^	ST_ADM_ACTION_READY,$/;"	e	enum:__anon135	file:
ST_ADM_ACTION_SHUTDOWN	./src/dumpstats.c	/^	ST_ADM_ACTION_SHUTDOWN,$/;"	e	enum:__anon135	file:
ST_ADM_ACTION_START	./src/dumpstats.c	/^	ST_ADM_ACTION_START,$/;"	e	enum:__anon135	file:
ST_ADM_ACTION_STOP	./src/dumpstats.c	/^	ST_ADM_ACTION_STOP,$/;"	e	enum:__anon135	file:
ST_CONVDONE	./include/common/uri_auth.h	/^#define	ST_CONVDONE	/;"	d
ST_HIDEVER	./include/common/uri_auth.h	/^#define	ST_HIDEVER	/;"	d
ST_SHDESC	./include/common/uri_auth.h	/^#define	ST_SHDESC	/;"	d
ST_SHLGNDS	./include/common/uri_auth.h	/^#define	ST_SHLGNDS	/;"	d
ST_SHNODE	./include/common/uri_auth.h	/^#define	ST_SHNODE	/;"	d
SUBVERS	./Makefile	/^SUBVERS := $(shell (grep -v '\\$$Format' SUBVERS 2>\/dev\/null || touch SUBVERS) | head -n 1)$/;"	m
SUBVERS	./Makefile	/^SUBVERS := $(shell comms=`git log --format=oneline --no-merges v$(VERSION).. 2>\/dev\/null | wc -l | tr -dc '0-9'`; commit=`(git log -1 --pretty=%h --abbrev=6) 2>\/dev\/null`; [ $$comms -gt 0 ] && echo "-$$commit-$$comms")$/;"	m
SYSLOG_PORT	./include/types/log.h	/^#define SYSLOG_PORT /;"	d
SYS_ACCEPT4	./include/common/syscall.h	/^#define SYS_ACCEPT4 /;"	d
SuperFastHash	./tests/test_hashes.c	/^uint32_t SuperFastHash (const char * data, int len) {$/;"	f
SuperFastHash	./tests/uri_hash.c	/^uint32_t SuperFastHash (const char * data, int len) {$/;"	f
SuperFastHash2	./tests/test_hashes.c	/^uint32_t SuperFastHash2 (const char * data, int len) {$/;"	f
SuperFastHash2	./tests/uri_hash.c	/^uint32_t SuperFastHash2 (const char * data, int len) {$/;"	f
T	./include/types/hlua.h	/^	lua_State *T; \/* The LUA stack. *\/$/;"	m	struct:hlua
TARGET	./Makefile	/^TARGET =$/;"	m
TARGET_CFLAGS	./Makefile	/^  TARGET_CFLAGS   = -D_MSGQSUPPORT$/;"	m
TARGET_CFLAGS	./Makefile	/^  TARGET_CFLAGS   = -Dss_family=__ss_family$/;"	m
TARGET_CFLAGS	./Makefile	/^  TARGET_CFLAGS  = $(if $(filter 1.5.%, $(shell uname -r)), -DUSE_IPV6 -DAF_INET6=23 -DINET6_ADDRSTRLEN=46, )$/;"	m
TARGET_CFLAGS	./Makefile	/^  TARGET_CFLAGS  = -fomit-frame-pointer -DFD_SETSIZE=65536 -D_REENTRANT$/;"	m
TARGET_LDFLAGS	./Makefile	/^  TARGET_LDFLAGS = -lnsl -lsocket$/;"	m
TASK_REASON_SHIFT	./include/types/task.h	/^#define TASK_REASON_SHIFT /;"	d
TASK_RUNNING	./include/types/task.h	/^#define TASK_RUNNING /;"	d
TASK_SLEEPING	./include/types/task.h	/^#define TASK_SLEEPING /;"	d
TASK_WOKEN_ANY	./include/types/task.h	/^#define TASK_WOKEN_ANY /;"	d
TASK_WOKEN_INIT	./include/types/task.h	/^#define TASK_WOKEN_INIT /;"	d
TASK_WOKEN_IO	./include/types/task.h	/^#define TASK_WOKEN_IO /;"	d
TASK_WOKEN_MSG	./include/types/task.h	/^#define TASK_WOKEN_MSG /;"	d
TASK_WOKEN_OTHER	./include/types/task.h	/^#define TASK_WOKEN_OTHER /;"	d
TASK_WOKEN_RES	./include/types/task.h	/^#define TASK_WOKEN_RES /;"	d
TASK_WOKEN_SIGNAL	./include/types/task.h	/^#define TASK_WOKEN_SIGNAL /;"	d
TASK_WOKEN_TIMER	./include/types/task.h	/^#define TASK_WOKEN_TIMER /;"	d
TCP	./examples/check	/^sub TCP$/;"	s
TCPCHK_ACT_COMMENT	./include/types/checks.h	/^	TCPCHK_ACT_COMMENT,                     \/* no action, simply a comment used for logs *\/$/;"	e	enum:__anon45
TCPCHK_ACT_CONNECT	./include/types/checks.h	/^	TCPCHK_ACT_CONNECT,                     \/* connect action, to probe a new port *\/$/;"	e	enum:__anon45
TCPCHK_ACT_EXPECT	./include/types/checks.h	/^	TCPCHK_ACT_EXPECT,                      \/* expect action, either regular or binary string *\/$/;"	e	enum:__anon45
TCPCHK_ACT_SEND	./include/types/checks.h	/^	TCPCHK_ACT_SEND        = 0,             \/* send action, regular string format *\/$/;"	e	enum:__anon45
TCPCHK_OPT_NONE	./include/types/checks.h	/^#define TCPCHK_OPT_NONE /;"	d
TCPCHK_OPT_SEND_PROXY	./include/types/checks.h	/^#define TCPCHK_OPT_SEND_PROXY /;"	d
TCPCHK_OPT_SSL	./include/types/checks.h	/^#define TCPCHK_OPT_SSL /;"	d
TCP_FASTOPEN	./include/common/compat.h	/^#define TCP_FASTOPEN /;"	d
TCP_NODELAY	./include/common/compat.h	/^#define TCP_NODELAY /;"	d
TERM_CODES_FIELD	./contrib/halog/halog.c	/^#define TERM_CODES_FIELD /;"	d	file:
TICKS_TO_MS	./include/common/ticks.h	/^#define TICKS_TO_MS(/;"	d
TICK_ETERNITY	./include/common/ticks.h	/^#define TICK_ETERNITY /;"	d
TIMER_LOOK_BACK	./include/proto/task.h	/^#define TIMER_LOOK_BACK /;"	d
TIME_ETERNITY	./include/common/time.h	/^#define TIME_ETERNITY /;"	d
TIME_FIELD	./contrib/halog/halog.c	/^#define TIME_FIELD /;"	d	file:
TIME_STATS_SAMPLES	./include/common/defaults.h	/^#define TIME_STATS_SAMPLES /;"	d
TIME_UNIT_DAY	./include/common/standard.h	/^#define TIME_UNIT_DAY /;"	d
TIME_UNIT_HOUR	./include/common/standard.h	/^#define TIME_UNIT_HOUR /;"	d
TIME_UNIT_MASK	./include/common/standard.h	/^#define TIME_UNIT_MASK /;"	d
TIME_UNIT_MIN	./include/common/standard.h	/^#define TIME_UNIT_MIN /;"	d
TIME_UNIT_MS	./include/common/standard.h	/^#define TIME_UNIT_MS /;"	d
TIME_UNIT_S	./include/common/standard.h	/^#define TIME_UNIT_S /;"	d
TIME_UNIT_US	./include/common/standard.h	/^#define TIME_UNIT_US /;"	d
TLS_TICKETS_NO	./include/common/defaults.h	/^#define TLS_TICKETS_NO /;"	d
TLV_HEADER_SIZE	./include/types/connection.h	/^#define TLV_HEADER_SIZE /;"	d
TRACE	./Makefile	/^TRACE =$/;"	m
TRACE	./include/common/debug.h	/^#define TRACE(/;"	d
TRACE_COPTS	./Makefile	/^TRACE_COPTS := $(filter-out -O0 -O1 -O2 -pg -finstrument-functions,$(COPTS)) -O3 -fomit-frame-pointer$/;"	m
TV_ETERNITY	./include/common/time.h	/^#define TV_ETERNITY /;"	d
TV_ETERNITY_MS	./include/common/time.h	/^#define TV_ETERNITY_MS /;"	d
TX_CACHEABLE	./include/types/proto_http.h	/^#define TX_CACHEABLE	/;"	d
TX_CACHE_COOK	./include/types/proto_http.h	/^#define TX_CACHE_COOK	/;"	d
TX_CACHE_SHIFT	./include/types/proto_http.h	/^#define TX_CACHE_SHIFT	/;"	d
TX_CK_DOWN	./include/types/proto_http.h	/^#define TX_CK_DOWN	/;"	d
TX_CK_EXPIRED	./include/types/proto_http.h	/^#define TX_CK_EXPIRED	/;"	d
TX_CK_INVALID	./include/types/proto_http.h	/^#define TX_CK_INVALID	/;"	d
TX_CK_MASK	./include/types/proto_http.h	/^#define TX_CK_MASK	/;"	d
TX_CK_NONE	./include/types/proto_http.h	/^#define TX_CK_NONE	/;"	d
TX_CK_OLD	./include/types/proto_http.h	/^#define TX_CK_OLD	/;"	d
TX_CK_SHIFT	./include/types/proto_http.h	/^#define TX_CK_SHIFT	/;"	d
TX_CK_UNUSED	./include/types/proto_http.h	/^#define TX_CK_UNUSED	/;"	d
TX_CK_VALID	./include/types/proto_http.h	/^#define TX_CK_VALID	/;"	d
TX_CLALLOW	./include/types/proto_http.h	/^#define TX_CLALLOW	/;"	d
TX_CLDENY	./include/types/proto_http.h	/^#define TX_CLDENY	/;"	d
TX_CLTARPIT	./include/types/proto_http.h	/^#define TX_CLTARPIT	/;"	d
TX_CON_CLO_SET	./include/types/proto_http.h	/^#define TX_CON_CLO_SET /;"	d
TX_CON_KAL_SET	./include/types/proto_http.h	/^#define TX_CON_KAL_SET /;"	d
TX_CON_WANT_CLO	./include/types/proto_http.h	/^#define TX_CON_WANT_CLO /;"	d
TX_CON_WANT_KAL	./include/types/proto_http.h	/^#define TX_CON_WANT_KAL /;"	d
TX_CON_WANT_MSK	./include/types/proto_http.h	/^#define TX_CON_WANT_MSK /;"	d
TX_CON_WANT_SCL	./include/types/proto_http.h	/^#define TX_CON_WANT_SCL /;"	d
TX_CON_WANT_TUN	./include/types/proto_http.h	/^#define TX_CON_WANT_TUN /;"	d
TX_HDR_CONN_CLO	./include/types/proto_http.h	/^#define TX_HDR_CONN_CLO	/;"	d
TX_HDR_CONN_KAL	./include/types/proto_http.h	/^#define TX_HDR_CONN_KAL	/;"	d
TX_HDR_CONN_PRS	./include/types/proto_http.h	/^#define TX_HDR_CONN_PRS	/;"	d
TX_HDR_CONN_UPG	./include/types/proto_http.h	/^#define TX_HDR_CONN_UPG /;"	d
TX_NOT_FIRST	./include/types/proto_http.h	/^#define TX_NOT_FIRST	/;"	d
TX_PREFER_LAST	./include/types/proto_http.h	/^#define TX_PREFER_LAST /;"	d
TX_SCK_DELETED	./include/types/proto_http.h	/^#define TX_SCK_DELETED	/;"	d
TX_SCK_FOUND	./include/types/proto_http.h	/^#define TX_SCK_FOUND /;"	d
TX_SCK_INSERTED	./include/types/proto_http.h	/^#define TX_SCK_INSERTED	/;"	d
TX_SCK_MASK	./include/types/proto_http.h	/^#define TX_SCK_MASK	/;"	d
TX_SCK_NONE	./include/types/proto_http.h	/^#define TX_SCK_NONE	/;"	d
TX_SCK_PRESENT	./include/types/proto_http.h	/^#define TX_SCK_PRESENT /;"	d
TX_SCK_REPLACED	./include/types/proto_http.h	/^#define TX_SCK_REPLACED	/;"	d
TX_SCK_SHIFT	./include/types/proto_http.h	/^#define TX_SCK_SHIFT	/;"	d
TX_SCK_UPDATED	./include/types/proto_http.h	/^#define TX_SCK_UPDATED	/;"	d
TX_SVALLOW	./include/types/proto_http.h	/^#define TX_SVALLOW	/;"	d
TX_SVDENY	./include/types/proto_http.h	/^#define TX_SVDENY	/;"	d
TX_USE_PX_CONN	./include/types/proto_http.h	/^#define TX_USE_PX_CONN	/;"	d
TX_WAIT_NEXT_RQ	./include/types/proto_http.h	/^#define TX_WAIT_NEXT_RQ	/;"	d
Tref	./include/types/hlua.h	/^	int Tref; \/* The reference of the stack in coroutine case.$/;"	m	struct:hlua
U16	./src/xxhash.c	/^typedef uint16_t U16;$/;"	t	file:
U16	./src/xxhash.c	/^typedef unsigned short     U16;$/;"	t	file:
U2A	./include/common/standard.h	/^static inline const char *U2A(unsigned long n)$/;"	f
U2H	./include/common/standard.h	/^static inline const char *U2H(unsigned long long n)$/;"	f
U32	./src/xxhash.c	/^typedef uint32_t U32;$/;"	t	file:
U32	./src/xxhash.c	/^typedef unsigned int       U32;$/;"	t	file:
U32_S	./src/xxhash.c	/^} _PACKED U32_S;$/;"	t	typeref:struct:_U32_S	file:
U64	./src/xxhash.c	/^typedef uint64_t U64;$/;"	t	file:
U64	./src/xxhash.c	/^typedef unsigned long long U64;$/;"	t	file:
U64_S	./src/xxhash.c	/^} _PACKED U64_S;$/;"	t	typeref:struct:_U64_S	file:
UBOUND	./include/common/standard.h	/^#define UBOUND(/;"	d
ULLONG_MAX	./include/common/standard.h	/^# define ULLONG_MAX	/;"	d
UNIQUEID_LEN	./include/types/log.h	/^#define UNIQUEID_LEN /;"	d
UNIX_MAX_PATH	./include/types/global.h	/^#define UNIX_MAX_PATH /;"	d
UPDATE_ANALYSERS	./src/stream.c	/^#define UPDATE_ANALYSERS(/;"	d	file:
URL_FIELD	./contrib/halog/halog.c	/^#define URL_FIELD /;"	d	file:
USE_ACCEPT4	./Makefile	/^  USE_ACCEPT4     = implicit$/;"	m
USE_CPU_AFFINITY	./Makefile	/^  USE_CPU_AFFINITY= implicit$/;"	m
USE_CRYPT_H	./Makefile	/^  USE_CRYPT_H     = implicit$/;"	m
USE_DL	./Makefile	/^  USE_DL          = implicit$/;"	m
USE_EPOLL	./Makefile	/^  USE_EPOLL       = implicit$/;"	m
USE_FUTEX	./Makefile	/^  USE_FUTEX       = implicit$/;"	m
USE_GETADDRINFO	./Makefile	/^  USE_GETADDRINFO = implicit$/;"	m
USE_GETSOCKNAME	./Makefile	/^  USE_GETSOCKNAME = implicit$/;"	m
USE_KQUEUE	./Makefile	/^  USE_KQUEUE     = implicit$/;"	m
USE_LIBCRYPT	./Makefile	/^  USE_LIBCRYPT    = implicit$/;"	m
USE_LIBCRYPT	./Makefile	/^  USE_LIBCRYPT   = implicit$/;"	m
USE_LINUX_SPLICE	./Makefile	/^  USE_LINUX_SPLICE= implicit$/;"	m
USE_LINUX_TPROXY	./Makefile	/^  USE_LINUX_TPROXY= implicit$/;"	m
USE_MY_EPOLL	./Makefile	/^  USE_MY_EPOLL    = implicit$/;"	m
USE_NETFILTER	./Makefile	/^  USE_NETFILTER   = implicit$/;"	m
USE_PCRE	./Makefile	/^USE_PCRE = 1$/;"	m
USE_POLL	./Makefile	/^  USE_POLL        = implicit$/;"	m
USE_POLL	./Makefile	/^  USE_POLL       = implicit$/;"	m
USE_POLL	./Makefile	/^  USE_POLL   = implicit$/;"	m
USE_POLL	./Makefile	/^USE_POLL   = default$/;"	m
USE_STATIC_PCRE	./Makefile	/^USE_STATIC_PCRE = 1$/;"	m
USE_TPROXY	./Makefile	/^  USE_TPROXY      = implicit$/;"	m
USE_TPROXY	./Makefile	/^  USE_TPROXY     = implicit$/;"	m
USE_TPROXY	./Makefile	/^  USE_TPROXY = implicit$/;"	m
USE_TPROXY	./Makefile	/^USE_TPROXY = 1$/;"	m
UTF8_CODE_BADSEQ	./include/common/standard.h	/^#define UTF8_CODE_BADSEQ /;"	d
UTF8_CODE_INVRANGE	./include/common/standard.h	/^#define UTF8_CODE_INVRANGE /;"	d
UTF8_CODE_OK	./include/common/standard.h	/^#define UTF8_CODE_OK /;"	d
UTF8_CODE_OVERLONG	./include/common/standard.h	/^#define UTF8_CODE_OVERLONG /;"	d
VAR_ARRAY	./include/common/compiler.h	/^#define VAR_ARRAY	/;"	d
VAR_ARRAY	./include/common/compiler.h	/^#define VAR_ARRAY$/;"	d
VERBOSE_CFLAGS	./Makefile	/^VERBOSE_CFLAGS = $(CFLAGS) $(TARGET_CFLAGS) $(SMALL_OPTS) $(DEFINE)$/;"	m
VERDATE	./Makefile	/^VERDATE := $(shell (grep -v '^\\$$Format' VERDATE 2>\/dev\/null || touch VERDATE) | head -n 1 | cut -f1 -d' ' | tr '-' '\/')$/;"	m
VERDATE	./Makefile	/^VERDATE := $(shell git log -1 --pretty=format:%ci | cut -f1 -d' ' | tr '-' '\/')$/;"	m
VERSION	./Makefile	/^VERSION := $(shell [ -d .git\/. ] && ref=`(git describe --tags --match 'v*' --abbrev=0) 2>\/dev\/null` && ref=$${ref%-g*} && echo "$${ref\\#v}")$/;"	m
VERSION	./Makefile	/^VERSION := $(shell cat VERSION 2>\/dev\/null || touch VERSION)$/;"	m
WARN_BLOCK_DEPRECATED	./include/types/global.h	/^#define WARN_BLOCK_DEPRECATED /;"	d
WARN_CLITO_DEPRECATED	./include/types/global.h	/^#define WARN_CLITO_DEPRECATED /;"	d
WARN_CONTO_DEPRECATED	./include/types/global.h	/^#define WARN_CONTO_DEPRECATED /;"	d
WARN_REDISPATCH_DEPRECATED	./include/types/global.h	/^#define WARN_REDISPATCH_DEPRECATED /;"	d
WARN_SRVTO_DEPRECATED	./include/types/global.h	/^#define WARN_SRVTO_DEPRECATED /;"	d
WILL_LJMP	./src/hlua.c	/^#define WILL_LJMP(/;"	d	file:
WRAPPER_OBJS	./Makefile	/^WRAPPER_OBJS = src\/haproxy-systemd-wrapper.o$/;"	m
Warning	./src/log.c	/^void Warning(const char *fmt, ...)$/;"	f
X509V3_EXT_SIZE	./src/ssl_sock.c	/^#define X509V3_EXT_SIZE /;"	d	file:
XXH32	./src/xxhash.c	/^unsigned int XXH32 (const void* input, size_t len, unsigned seed)$/;"	f
XXH32_createState	./src/xxhash.c	/^XXH32_state_t* XXH32_createState(void)$/;"	f
XXH32_digest	./src/xxhash.c	/^U32 XXH32_digest (const XXH32_state_t* state_in)$/;"	f
XXH32_digest_endian	./src/xxhash.c	/^FORCE_INLINE U32 XXH32_digest_endian (const XXH32_state_t* state_in, XXH_endianess endian)$/;"	f
XXH32_endian_align	./src/xxhash.c	/^FORCE_INLINE U32 XXH32_endian_align(const void* input, size_t len, U32 seed, XXH_endianess endian, XXH_alignment align)$/;"	f
XXH32_freeState	./src/xxhash.c	/^XXH_errorcode XXH32_freeState(XXH32_state_t* statePtr)$/;"	f
XXH32_reset	./src/xxhash.c	/^XXH_errorcode XXH32_reset(XXH32_state_t* state_in, U32 seed)$/;"	f
XXH32_state_t	./include/import/xxhash.h	/^typedef struct { long long ll[ 6]; } XXH32_state_t;$/;"	t	typeref:struct:__anon6
XXH32_update	./src/xxhash.c	/^XXH_errorcode XXH32_update (XXH32_state_t* state_in, const void* input, size_t len)$/;"	f
XXH32_update_endian	./src/xxhash.c	/^FORCE_INLINE XXH_errorcode XXH32_update_endian (XXH32_state_t* state_in, const void* input, size_t len, XXH_endianess endian)$/;"	f
XXH64	./src/xxhash.c	/^unsigned long long XXH64 (const void* input, size_t len, unsigned long long seed)$/;"	f
XXH64_createState	./src/xxhash.c	/^XXH64_state_t* XXH64_createState(void)$/;"	f
XXH64_digest	./src/xxhash.c	/^unsigned long long XXH64_digest (const XXH64_state_t* state_in)$/;"	f
XXH64_digest_endian	./src/xxhash.c	/^FORCE_INLINE U64 XXH64_digest_endian (const XXH64_state_t* state_in, XXH_endianess endian)$/;"	f
XXH64_endian_align	./src/xxhash.c	/^FORCE_INLINE U64 XXH64_endian_align(const void* input, size_t len, U64 seed, XXH_endianess endian, XXH_alignment align)$/;"	f
XXH64_freeState	./src/xxhash.c	/^XXH_errorcode XXH64_freeState(XXH64_state_t* statePtr)$/;"	f
XXH64_reset	./src/xxhash.c	/^XXH_errorcode XXH64_reset(XXH64_state_t* state_in, unsigned long long seed)$/;"	f
XXH64_state_t	./include/import/xxhash.h	/^typedef struct { long long ll[11]; } XXH64_state_t;$/;"	t	typeref:struct:__anon7
XXH64_update	./src/xxhash.c	/^XXH_errorcode XXH64_update (XXH64_state_t* state_in, const void* input, size_t len)$/;"	f
XXH64_update_endian	./src/xxhash.c	/^FORCE_INLINE XXH_errorcode XXH64_update_endian (XXH64_state_t* state_in, const void* input, size_t len, XXH_endianess endian)$/;"	f
XXH_CPU_LITTLE_ENDIAN	./src/xxhash.c	/^#   define XXH_CPU_LITTLE_ENDIAN /;"	d	file:
XXH_ERROR	./include/import/xxhash.h	/^typedef enum { XXH_OK=0, XXH_ERROR } XXH_errorcode;$/;"	e	enum:__anon5
XXH_FORCE_NATIVE_FORMAT	./src/xxhash.c	/^#define XXH_FORCE_NATIVE_FORMAT /;"	d	file:
XXH_OK	./include/import/xxhash.h	/^typedef enum { XXH_OK=0, XXH_ERROR } XXH_errorcode;$/;"	e	enum:__anon5
XXH_STATIC_ASSERT	./src/xxhash.c	/^#define XXH_STATIC_ASSERT(/;"	d	file:
XXH_USE_UNALIGNED_ACCESS	./src/xxhash.c	/^#  define XXH_USE_UNALIGNED_ACCESS /;"	d	file:
XXH_aligned	./src/xxhash.c	/^typedef enum { XXH_aligned, XXH_unaligned } XXH_alignment;$/;"	e	enum:__anon147	file:
XXH_alignment	./src/xxhash.c	/^typedef enum { XXH_aligned, XXH_unaligned } XXH_alignment;$/;"	t	typeref:enum:__anon147	file:
XXH_bigEndian	./src/xxhash.c	/^typedef enum { XXH_bigEndian=0, XXH_littleEndian=1 } XXH_endianess;$/;"	e	enum:__anon146	file:
XXH_endianess	./src/xxhash.c	/^typedef enum { XXH_bigEndian=0, XXH_littleEndian=1 } XXH_endianess;$/;"	t	typeref:enum:__anon146	file:
XXH_errorcode	./include/import/xxhash.h	/^typedef enum { XXH_OK=0, XXH_ERROR } XXH_errorcode;$/;"	t	typeref:enum:__anon5
XXH_free	./src/xxhash.c	/^static void  XXH_free  (void* p)  { free(p); }$/;"	f	file:
XXH_get32bits	./src/xxhash.c	/^#define XXH_get32bits(/;"	d	file:
XXH_get64bits	./src/xxhash.c	/^#define XXH_get64bits(/;"	d	file:
XXH_istate32_t	./src/xxhash.c	/^} XXH_istate32_t;$/;"	t	typeref:struct:__anon148	file:
XXH_istate64_t	./src/xxhash.c	/^} XXH_istate64_t;$/;"	t	typeref:struct:__anon149	file:
XXH_littleEndian	./src/xxhash.c	/^typedef enum { XXH_bigEndian=0, XXH_littleEndian=1 } XXH_endianess;$/;"	e	enum:__anon146	file:
XXH_malloc	./src/xxhash.c	/^static void* XXH_malloc(size_t s) { return malloc(s); }$/;"	f	file:
XXH_memcpy	./src/xxhash.c	/^static void* XXH_memcpy(void* dest, const void* src, size_t size)$/;"	f	file:
XXH_readLE32	./src/xxhash.c	/^FORCE_INLINE U32 XXH_readLE32(const void* ptr, XXH_endianess endian)$/;"	f
XXH_readLE32_align	./src/xxhash.c	/^FORCE_INLINE U32 XXH_readLE32_align(const void* ptr, XXH_endianess endian, XXH_alignment align)$/;"	f
XXH_readLE64	./src/xxhash.c	/^FORCE_INLINE U64 XXH_readLE64(const void* ptr, XXH_endianess endian)$/;"	f
XXH_readLE64_align	./src/xxhash.c	/^FORCE_INLINE U64 XXH_readLE64_align(const void* ptr, XXH_endianess endian, XXH_alignment align)$/;"	f
XXH_rotl32	./src/xxhash.c	/^#  define XXH_rotl32(/;"	d	file:
XXH_rotl64	./src/xxhash.c	/^#  define XXH_rotl64(/;"	d	file:
XXH_swap32	./src/xxhash.c	/^#  define XXH_swap32 /;"	d	file:
XXH_swap32	./src/xxhash.c	/^static inline U32 XXH_swap32 (U32 x)$/;"	f	file:
XXH_swap64	./src/xxhash.c	/^#  define XXH_swap64 /;"	d	file:
XXH_swap64	./src/xxhash.c	/^static inline U64 XXH_swap64 (U64 x)$/;"	f	file:
XXH_unaligned	./src/xxhash.c	/^typedef enum { XXH_aligned, XXH_unaligned } XXH_alignment;$/;"	e	enum:__anon147	file:
ZLIB_INC	./Makefile	/^ZLIB_INC =$/;"	m
ZLIB_LIB	./Makefile	/^ZLIB_LIB =$/;"	m
_51DEGREES_CONV_CACHE_KEY	./src/51d.c	/^#define _51DEGREES_CONV_CACHE_KEY /;"	d	file:
_51DEGREES_FETCH_CACHE_KEY	./src/51d.c	/^#define _51DEGREES_FETCH_CACHE_KEY /;"	d	file:
_51d_cache_size	./src/51d.c	/^static int _51d_cache_size(char **args, int section_type, struct proxy *curpx,$/;"	f	file:
_51d_conv	./src/51d.c	/^static int _51d_conv(const struct arg *args, struct sample *smp, void *private)$/;"	f	file:
_51d_conv_check	./src/51d.c	/^static int _51d_conv_check(struct arg *arg, struct sample_conv *conv,$/;"	f	file:
_51d_data_file	./src/51d.c	/^static int _51d_data_file(char **args, int section_type, struct proxy *curpx,$/;"	f	file:
_51d_fetch	./src/51d.c	/^static int _51d_fetch(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
_51d_fetch_check	./src/51d.c	/^static int _51d_fetch_check(struct arg *arg, char **err_msg)$/;"	f	file:
_51d_init_http_headers	./src/51d.c	/^void _51d_init_http_headers()$/;"	f
_51d_insert_cache_entry	./src/51d.c	/^static void _51d_insert_cache_entry(struct sample *smp, struct lru64 *lru)$/;"	f	file:
_51d_lru_seed	./src/51d.c	/^static unsigned long long _51d_lru_seed;$/;"	v	file:
_51d_lru_tree	./src/51d.c	/^static struct lru64_head *_51d_lru_tree = NULL;$/;"	v	typeref:struct:lru64_head	file:
_51d_process_match	./src/51d.c	/^static void _51d_process_match(const struct arg *args, struct sample *smp, fiftyoneDegreesWorkset* ws)$/;"	f	file:
_51d_property_name_list	./src/51d.c	/^static int _51d_property_name_list(char **args, int section_type, struct proxy *curpx,$/;"	f	file:
_51d_property_names	./src/51d.c	/^struct _51d_property_names {$/;"	s	file:
_51d_property_separator	./src/51d.c	/^static int _51d_property_separator(char **args, int section_type, struct proxy *curpx,$/;"	f	file:
_51d_req_hash	./src/51d.c	/^unsigned long long _51d_req_hash(const struct arg *args, fiftyoneDegreesWorkset* ws)$/;"	f
_51d_retrieve_cache_entry	./src/51d.c	/^static void _51d_retrieve_cache_entry(struct sample *smp, struct lru64 *lru)$/;"	f	file:
_51d_set_device_offsets	./src/51d.c	/^static void _51d_set_device_offsets(struct sample *smp)$/;"	f	file:
_51d_set_headers	./src/51d.c	/^static void _51d_set_headers(struct sample *smp, fiftyoneDegreesWorkset *ws)$/;"	f	file:
_51dcfg_kws	./src/51d.c	/^static struct cfg_kw_list _51dcfg_kws = {{ }, {$/;"	v	typeref:struct:cfg_kw_list	file:
_51degrees	./include/types/global.h	/^	} _51degrees;$/;"	m	struct:global	typeref:struct:global::__anon76
_COMMON_ACCEPT4_H	./include/common/accept4.h	/^#define _COMMON_ACCEPT4_H$/;"	d
_COMMON_BASE64_H	./include/common/base64.h	/^#define _COMMON_BASE64_H$/;"	d
_COMMON_BUFFER_H	./include/common/buffer.h	/^#define _COMMON_BUFFER_H$/;"	d
_COMMON_CFGPARSE_H	./include/common/cfgparse.h	/^#define _COMMON_CFGPARSE_H$/;"	d
_COMMON_COMPAT_H	./include/common/compat.h	/^#define _COMMON_COMPAT_H$/;"	d
_COMMON_COMPILER_H	./include/common/compiler.h	/^#define _COMMON_COMPILER_H$/;"	d
_COMMON_CONFIG_H	./include/common/config.h	/^#define _COMMON_CONFIG_H$/;"	d
_COMMON_DEBUG_H	./include/common/debug.h	/^#define _COMMON_DEBUG_H$/;"	d
_COMMON_DEFAULTS_H	./include/common/defaults.h	/^#define _COMMON_DEFAULTS_H$/;"	d
_COMMON_EPOLL_H	./include/common/epoll.h	/^#define _COMMON_EPOLL_H$/;"	d
_COMMON_ERRORS_H	./include/common/errors.h	/^#define _COMMON_ERRORS_H$/;"	d
_COMMON_HASH_H_	./include/common/hash.h	/^#define _COMMON_HASH_H_$/;"	d
_COMMON_MEMORY_H	./include/common/memory.h	/^#define _COMMON_MEMORY_H$/;"	d
_COMMON_MINI_CLIST_H	./include/common/mini-clist.h	/^#define _COMMON_MINI_CLIST_H$/;"	d
_COMMON_REGEX_H	./include/common/regex.h	/^#define _COMMON_REGEX_H$/;"	d
_COMMON_SPLICE_H	./include/common/splice.h	/^#define _COMMON_SPLICE_H$/;"	d
_COMMON_STANDARD_H	./include/common/standard.h	/^#define _COMMON_STANDARD_H$/;"	d
_COMMON_SYSCALL_H	./include/common/syscall.h	/^#define _COMMON_SYSCALL_H$/;"	d
_COMMON_TEMPLATE_H	./include/common/template.h	/^#define _COMMON_TEMPLATE_H$/;"	d
_COMMON_TICKS_H	./include/common/ticks.h	/^#define _COMMON_TICKS_H$/;"	d
_COMMON_TIME_H	./include/common/time.h	/^#define _COMMON_TIME_H$/;"	d
_COMMON_TOOLS_H	./include/common/tools.h	/^#define _COMMON_TOOLS_H$/;"	d
_COMMON_URI_AUTH_H	./include/common/uri_auth.h	/^#define _COMMON_URI_AUTH_H$/;"	d
_COMMON_VERSION_H	./include/common/version.h	/^#define _COMMON_VERSION_H$/;"	d
_EB32TREE_H	./ebtree/eb32tree.h	/^#define _EB32TREE_H$/;"	d
_EB64TREE_H	./ebtree/eb64tree.h	/^#define _EB64TREE_H$/;"	d
_EBIMTREE_H	./ebtree/ebimtree.h	/^#define _EBIMTREE_H$/;"	d
_EBISTREE_H	./ebtree/ebistree.h	/^#define _EBISTREE_H$/;"	d
_EBMBTREE_H	./ebtree/ebmbtree.h	/^#define _EBMBTREE_H$/;"	d
_EBPTTREE_H	./ebtree/ebpttree.h	/^#define _EBPTTREE_H$/;"	d
_EBSTTREE_H	./ebtree/ebsttree.h	/^#define _EBSTTREE_H$/;"	d
_EBTREE_H	./ebtree/ebtree.h	/^#define _EBTREE_H$/;"	d
_GNU_SOURCE	./src/auth.c	/^#define _GNU_SOURCE$/;"	d	file:
_GNU_SOURCE	./src/cfgparse.c	/^#define _GNU_SOURCE$/;"	d	file:
_GNU_SOURCE	./src/haproxy.c	/^#define _GNU_SOURCE$/;"	d	file:
_GNU_SOURCE	./src/listener.c	/^#define _GNU_SOURCE$/;"	d	file:
_GNU_SOURCE	./src/namespace.c	/^#define _GNU_SOURCE$/;"	d	file:
_GNU_SOURCE	./src/raw_sock.c	/^#define _GNU_SOURCE$/;"	d	file:
_GNU_SOURCE	./src/ssl_sock.c	/^#define _GNU_SOURCE$/;"	d	file:
_IMPORT_51D_H	./include/import/51d.h	/^#define _IMPORT_51D_H$/;"	d
_IMPORT_DA_H	./include/import/da.h	/^#define _IMPORT_DA_H$/;"	d
_LINUX_RBTREE_H	./include/common/rbtree.h	/^#define	_LINUX_RBTREE_H$/;"	d
_NAMESPACE_H	./include/common/namespace.h	/^#define _NAMESPACE_H$/;"	d
_PACKED	./src/xxhash.c	/^#  define _PACKED /;"	d	file:
_PACKED	./src/xxhash.c	/^#  define _PACKED$/;"	d	file:
_PROTO_ACL_H	./include/proto/acl.h	/^#define _PROTO_ACL_H$/;"	d
_PROTO_ACTION_H	./include/proto/action.h	/^#define _PROTO_ACTION_H$/;"	d
_PROTO_APPLET_H	./include/proto/applet.h	/^#define _PROTO_APPLET_H$/;"	d
_PROTO_ARG_H	./include/proto/arg.h	/^#define _PROTO_ARG_H$/;"	d
_PROTO_AUTH_H	./include/proto/auth.h	/^#define _PROTO_AUTH_H$/;"	d
_PROTO_BACKEND_H	./include/proto/backend.h	/^#define _PROTO_BACKEND_H$/;"	d
_PROTO_CHANNEL_H	./include/proto/channel.h	/^#define _PROTO_CHANNEL_H$/;"	d
_PROTO_CHECKS_H	./include/proto/checks.h	/^#define _PROTO_CHECKS_H$/;"	d
_PROTO_COMP_H	./include/proto/compression.h	/^#define _PROTO_COMP_H$/;"	d
_PROTO_CONNECTION_H	./include/proto/connection.h	/^#define _PROTO_CONNECTION_H$/;"	d
_PROTO_DNS_H	./include/proto/dns.h	/^#define _PROTO_DNS_H$/;"	d
_PROTO_DUMPSTATS_H	./include/proto/dumpstats.h	/^#define _PROTO_DUMPSTATS_H$/;"	d
_PROTO_FD_H	./include/proto/fd.h	/^#define _PROTO_FD_H$/;"	d
_PROTO_FREQ_CTR_H	./include/proto/freq_ctr.h	/^#define _PROTO_FREQ_CTR_H$/;"	d
_PROTO_FRONTEND_H	./include/proto/frontend.h	/^#define _PROTO_FRONTEND_H$/;"	d
_PROTO_HDR_IDX_H	./include/proto/hdr_idx.h	/^#define _PROTO_HDR_IDX_H$/;"	d
_PROTO_HLUA_H	./include/proto/hlua.h	/^#define _PROTO_HLUA_H$/;"	d
_PROTO_LB_CHASH_H	./include/proto/lb_chash.h	/^#define _PROTO_LB_CHASH_H$/;"	d
_PROTO_LB_FAS_H	./include/proto/lb_fas.h	/^#define _PROTO_LB_FAS_H$/;"	d
_PROTO_LB_FWLC_H	./include/proto/lb_fwlc.h	/^#define _PROTO_LB_FWLC_H$/;"	d
_PROTO_LB_FWRR_H	./include/proto/lb_fwrr.h	/^#define _PROTO_LB_FWRR_H$/;"	d
_PROTO_LB_MAP_H	./include/proto/lb_map.h	/^#define _PROTO_LB_MAP_H$/;"	d
_PROTO_LISTENER_H	./include/proto/listener.h	/^#define _PROTO_LISTENER_H$/;"	d
_PROTO_LOG_H	./include/proto/log.h	/^#define _PROTO_LOG_H$/;"	d
_PROTO_MAP_H	./include/proto/map.h	/^#define _PROTO_MAP_H$/;"	d
_PROTO_OBJ_TYPE_H	./include/proto/obj_type.h	/^#define _PROTO_OBJ_TYPE_H$/;"	d
_PROTO_PATTERN_H	./include/proto/pattern.h	/^#define _PROTO_PATTERN_H$/;"	d
_PROTO_PEERS_H	./include/proto/peers.h	/^#define _PROTO_PEERS_H$/;"	d
_PROTO_PIPE_H	./include/proto/pipe.h	/^#define _PROTO_PIPE_H$/;"	d
_PROTO_PORT_RANGE_H	./include/proto/port_range.h	/^#define _PROTO_PORT_RANGE_H$/;"	d
_PROTO_PROTOCOL_H	./include/proto/protocol.h	/^#define _PROTO_PROTOCOL_H$/;"	d
_PROTO_PROTO_HTTP_H	./include/proto/proto_http.h	/^#define _PROTO_PROTO_HTTP_H$/;"	d
_PROTO_PROTO_PAYLOAD_H	./include/proto/payload.h	/^#define _PROTO_PROTO_PAYLOAD_H$/;"	d
_PROTO_PROTO_TCP_H	./include/proto/proto_tcp.h	/^#define _PROTO_PROTO_TCP_H$/;"	d
_PROTO_PROTO_UDP_H	./include/proto/proto_udp.h	/^#define _PROTO_PROTO_UDP_H$/;"	d
_PROTO_PROTO_UXST_H	./include/proto/proto_uxst.h	/^#define _PROTO_PROTO_UXST_H$/;"	d
_PROTO_PROXY_H	./include/proto/proxy.h	/^#define _PROTO_PROXY_H$/;"	d
_PROTO_QUEUE_H	./include/proto/queue.h	/^#define _PROTO_QUEUE_H$/;"	d
_PROTO_RAW_SOCK_H	./include/proto/raw_sock.h	/^#define _PROTO_RAW_SOCK_H$/;"	d
_PROTO_SAMPLE_H	./include/proto/sample.h	/^#define _PROTO_SAMPLE_H$/;"	d
_PROTO_SERVER_H	./include/proto/server.h	/^#define _PROTO_SERVER_H$/;"	d
_PROTO_SESSION_H	./include/proto/session.h	/^#define _PROTO_SESSION_H$/;"	d
_PROTO_SSL_SOCK_H	./include/proto/ssl_sock.h	/^#define _PROTO_SSL_SOCK_H$/;"	d
_PROTO_STICK_TABLE_H	./include/proto/stick_table.h	/^#define _PROTO_STICK_TABLE_H$/;"	d
_PROTO_STREAM_H	./include/proto/stream.h	/^#define _PROTO_STREAM_H$/;"	d
_PROTO_STREAM_INTERFACE_H	./include/proto/stream_interface.h	/^#define _PROTO_STREAM_INTERFACE_H$/;"	d
_PROTO_TASK_H	./include/proto/task.h	/^#define _PROTO_TASK_H$/;"	d
_PROTO_TEMPLATE_H	./include/proto/template.h	/^#define _PROTO_TEMPLATE_H$/;"	d
_PROTO_VARS_H	./include/proto/vars.h	/^#define _PROTO_VARS_H$/;"	d
_TYPES_ACL_H	./include/types/acl.h	/^#define _TYPES_ACL_H$/;"	d
_TYPES_ACTION_H	./include/types/action.h	/^#define _TYPES_ACTION_H$/;"	d
_TYPES_APPLET_H	./include/types/applet.h	/^#define _TYPES_APPLET_H$/;"	d
_TYPES_ARG_H	./include/types/arg.h	/^#define _TYPES_ARG_H$/;"	d
_TYPES_AUTH_H	./include/types/auth.h	/^#define _TYPES_AUTH_H$/;"	d
_TYPES_BACKEND_H	./include/types/backend.h	/^#define _TYPES_BACKEND_H$/;"	d
_TYPES_CAPTURE_H	./include/types/capture.h	/^#define _TYPES_CAPTURE_H$/;"	d
_TYPES_CHANNEL_H	./include/types/channel.h	/^#define _TYPES_CHANNEL_H$/;"	d
_TYPES_CHECKS_H	./include/types/checks.h	/^#define _TYPES_CHECKS_H$/;"	d
_TYPES_CHUNK_H	./include/common/chunk.h	/^#define _TYPES_CHUNK_H$/;"	d
_TYPES_COMP_H	./include/types/compression.h	/^#define _TYPES_COMP_H$/;"	d
_TYPES_CONNECTION_H	./include/types/connection.h	/^#define _TYPES_CONNECTION_H$/;"	d
_TYPES_COUNTERS_H	./include/types/counters.h	/^#define _TYPES_COUNTERS_H$/;"	d
_TYPES_DNS_H	./include/types/dns.h	/^#define _TYPES_DNS_H$/;"	d
_TYPES_FD_H	./include/types/fd.h	/^#define _TYPES_FD_H$/;"	d
_TYPES_FREQ_CTR_H	./include/types/freq_ctr.h	/^#define _TYPES_FREQ_CTR_H$/;"	d
_TYPES_GLOBAL_H	./include/types/global.h	/^#define _TYPES_GLOBAL_H$/;"	d
_TYPES_HDR_IDX_H	./include/types/hdr_idx.h	/^#define _TYPES_HDR_IDX_H$/;"	d
_TYPES_HLUA_H	./include/types/hlua.h	/^#define _TYPES_HLUA_H$/;"	d
_TYPES_LB_CHASH_H	./include/types/lb_chash.h	/^#define _TYPES_LB_CHASH_H$/;"	d
_TYPES_LB_FAS_H	./include/types/lb_fas.h	/^#define _TYPES_LB_FAS_H$/;"	d
_TYPES_LB_FWLC_H	./include/types/lb_fwlc.h	/^#define _TYPES_LB_FWLC_H$/;"	d
_TYPES_LB_FWRR_H	./include/types/lb_fwrr.h	/^#define _TYPES_LB_FWRR_H$/;"	d
_TYPES_LB_MAP_H	./include/types/lb_map.h	/^#define _TYPES_LB_MAP_H$/;"	d
_TYPES_LISTENER_H	./include/types/listener.h	/^#define _TYPES_LISTENER_H$/;"	d
_TYPES_LOG_H	./include/types/log.h	/^#define _TYPES_LOG_H$/;"	d
_TYPES_MAILERS_H	./include/types/mailers.h	/^#define _TYPES_MAILERS_H$/;"	d
_TYPES_MAP_H	./include/types/map.h	/^#define _TYPES_MAP_H$/;"	d
_TYPES_OBJ_TYPE_H	./include/types/obj_type.h	/^#define _TYPES_OBJ_TYPE_H$/;"	d
_TYPES_PATTERN_H	./include/types/pattern.h	/^#define _TYPES_PATTERN_H$/;"	d
_TYPES_PEERS_H	./include/types/peers.h	/^#define _TYPES_PEERS_H$/;"	d
_TYPES_PIPE_H	./include/types/pipe.h	/^#define _TYPES_PIPE_H$/;"	d
_TYPES_PORT_RANGE_H	./include/types/port_range.h	/^#define _TYPES_PORT_RANGE_H$/;"	d
_TYPES_PROTOCOL_H	./include/types/protocol.h	/^#define _TYPES_PROTOCOL_H$/;"	d
_TYPES_PROTO_HTTP_H	./include/types/proto_http.h	/^#define _TYPES_PROTO_HTTP_H$/;"	d
_TYPES_PROTO_UDP_H	./include/types/proto_udp.h	/^#define _TYPES_PROTO_UDP_H$/;"	d
_TYPES_PROXY_H	./include/types/proxy.h	/^#define _TYPES_PROXY_H$/;"	d
_TYPES_QUEUE_H	./include/types/queue.h	/^#define _TYPES_QUEUE_H$/;"	d
_TYPES_SAMPLE_H	./include/types/sample.h	/^#define _TYPES_SAMPLE_H$/;"	d
_TYPES_SERVER_H	./include/types/server.h	/^#define _TYPES_SERVER_H$/;"	d
_TYPES_SESSION_H	./include/types/session.h	/^#define _TYPES_SESSION_H$/;"	d
_TYPES_SIGNAL_H	./include/types/signal.h	/^#define _TYPES_SIGNAL_H$/;"	d
_TYPES_SSL_SOCK_H	./include/types/ssl_sock.h	/^#define _TYPES_SSL_SOCK_H$/;"	d
_TYPES_STICK_TABLE_H	./include/types/stick_table.h	/^#define _TYPES_STICK_TABLE_H$/;"	d
_TYPES_STREAM_H	./include/types/stream.h	/^#define _TYPES_STREAM_H$/;"	d
_TYPES_STREAM_INTERFACE_H	./include/types/stream_interface.h	/^#define _TYPES_STREAM_INTERFACE_H$/;"	d
_TYPES_TASK_H	./include/types/task.h	/^#define _TYPES_TASK_H$/;"	d
_TYPES_TEMPLATE_H	./include/types/template.h	/^#define _TYPES_TEMPLATE_H$/;"	d
_TYPES_VARS_H	./include/types/vars.h	/^#define _TYPES_VARS_H$/;"	d
_U32_S	./src/xxhash.c	/^typedef struct _U32_S$/;"	s	file:
_U64_S	./src/xxhash.c	/^typedef struct _U64_S$/;"	s	file:
__51d_init	./src/51d.c	/^static void __51d_init(void)$/;"	f	file:
__LJMP	./src/hlua.c	/^#define __LJMP$/;"	d	file:
__NR_accept4	./include/common/syscall.h	/^#define __NR_accept4 /;"	d
__NR_epoll_create	./include/common/epoll.h	/^#define __NR_epoll_create /;"	d
__NR_epoll_create	./include/common/syscall.h	/^#define __NR_epoll_create /;"	d
__NR_epoll_ctl	./include/common/epoll.h	/^#define __NR_epoll_ctl /;"	d
__NR_epoll_ctl	./include/common/syscall.h	/^#define __NR_epoll_ctl /;"	d
__NR_epoll_wait	./include/common/epoll.h	/^#define __NR_epoll_wait /;"	d
__NR_epoll_wait	./include/common/syscall.h	/^#define __NR_epoll_wait /;"	d
__NR_splace	./include/common/syscall.h	/^#define __NR_splace	/;"	d
__NR_splice	./include/common/splice.h	/^#define __NR_splice /;"	d
__NR_splice	./include/common/syscall.h	/^#define __NR_splice /;"	d
__acl_init	./src/acl.c	/^static void __acl_init(void)$/;"	f	file:
__b_drop	./include/common/buffer.h	/^static inline void __b_drop(struct buffer **buf)$/;"	f
__backend_init	./src/backend.c	/^static void __backend_init(void)$/;"	f	file:
__builtin_expect	./include/common/compiler.h	/^#define __builtin_expect(/;"	d
__channel_forward	./src/channel.c	/^unsigned long long __channel_forward(struct channel *chn, unsigned long long bytes)$/;"	f
__comp_fetch_init	./src/compression.c	/^static void __comp_fetch_init(void)$/;"	f	file:
__conn_data_stop_both	./include/proto/connection.h	/^static inline void __conn_data_stop_both(struct connection *c)$/;"	f
__conn_data_stop_recv	./include/proto/connection.h	/^static inline void __conn_data_stop_recv(struct connection *c)$/;"	f
__conn_data_stop_send	./include/proto/connection.h	/^static inline void __conn_data_stop_send(struct connection *c)$/;"	f
__conn_data_want_recv	./include/proto/connection.h	/^static inline void __conn_data_want_recv(struct connection *c)$/;"	f
__conn_data_want_send	./include/proto/connection.h	/^static inline void __conn_data_want_send(struct connection *c)$/;"	f
__conn_sock_stop_both	./include/proto/connection.h	/^static inline void __conn_sock_stop_both(struct connection *c)$/;"	f
__conn_sock_stop_recv	./include/proto/connection.h	/^static inline void __conn_sock_stop_recv(struct connection *c)$/;"	f
__conn_sock_stop_send	./include/proto/connection.h	/^static inline void __conn_sock_stop_send(struct connection *c)$/;"	f
__conn_sock_want_recv	./include/proto/connection.h	/^static inline void __conn_sock_want_recv(struct connection *c)$/;"	f
__conn_sock_want_send	./include/proto/connection.h	/^static inline void __conn_sock_want_send(struct connection *c)$/;"	f
__cyg_profile_func_enter	./src/trace.c	/^void __cyg_profile_func_enter(void *to,  void *from)$/;"	f
__cyg_profile_func_exit	./src/trace.c	/^void __cyg_profile_func_exit(void *to,  void *from)$/;"	f
__da_init	./src/da.c	/^static void __da_init(void)$/;"	f	file:
__dumpstats_module_init	./src/dumpstats.c	/^static void __dumpstats_module_init(void)$/;"	f	file:
__eb32_delete	./ebtree/eb32tree.h	/^static forceinline void __eb32_delete(struct eb32_node *eb32)$/;"	f
__eb32_insert	./ebtree/eb32tree.h	/^__eb32_insert(struct eb_root *root, struct eb32_node *new) {$/;"	f
__eb32_lookup	./ebtree/eb32tree.h	/^static forceinline struct eb32_node *__eb32_lookup(struct eb_root *root, u32 x)$/;"	f
__eb32i_insert	./ebtree/eb32tree.h	/^__eb32i_insert(struct eb_root *root, struct eb32_node *new) {$/;"	f
__eb32i_lookup	./ebtree/eb32tree.h	/^static forceinline struct eb32_node *__eb32i_lookup(struct eb_root *root, s32 x)$/;"	f
__eb64_delete	./ebtree/eb64tree.h	/^static forceinline void __eb64_delete(struct eb64_node *eb64)$/;"	f
__eb64_insert	./ebtree/eb64tree.h	/^__eb64_insert(struct eb_root *root, struct eb64_node *new) {$/;"	f
__eb64_lookup	./ebtree/eb64tree.h	/^static forceinline struct eb64_node *__eb64_lookup(struct eb_root *root, u64 x)$/;"	f
__eb64i_insert	./ebtree/eb64tree.h	/^__eb64i_insert(struct eb_root *root, struct eb64_node *new) {$/;"	f
__eb64i_lookup	./ebtree/eb64tree.h	/^static forceinline struct eb64_node *__eb64i_lookup(struct eb_root *root, s64 x)$/;"	f
__eb_delete	./ebtree/ebtree.h	/^static forceinline void __eb_delete(struct eb_node *node)$/;"	f
__eb_insert_dup	./ebtree/ebtree.h	/^__eb_insert_dup(struct eb_node *sub, struct eb_node *new)$/;"	f
__ebim_insert	./ebtree/ebimtree.h	/^__ebim_insert(struct eb_root *root, struct ebpt_node *new, unsigned int len)$/;"	f
__ebim_lookup	./ebtree/ebimtree.h	/^__ebim_lookup(struct eb_root *root, const void *x, unsigned int len)$/;"	f
__ebis_insert	./ebtree/ebistree.h	/^__ebis_insert(struct eb_root *root, struct ebpt_node *new)$/;"	f
__ebis_lookup	./ebtree/ebistree.h	/^static forceinline struct ebpt_node *__ebis_lookup(struct eb_root *root, const void *x)$/;"	f
__ebmb_delete	./ebtree/ebmbtree.h	/^static forceinline void __ebmb_delete(struct ebmb_node *ebmb)$/;"	f
__ebmb_insert	./ebtree/ebmbtree.h	/^__ebmb_insert(struct eb_root *root, struct ebmb_node *new, unsigned int len)$/;"	f
__ebmb_insert_prefix	./ebtree/ebmbtree.h	/^__ebmb_insert_prefix(struct eb_root *root, struct ebmb_node *new, unsigned int len)$/;"	f
__ebmb_lookup	./ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *__ebmb_lookup(struct eb_root *root, const void *x, unsigned int len)$/;"	f
__ebmb_lookup_longest	./ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *__ebmb_lookup_longest(struct eb_root *root, const void *x)$/;"	f
__ebmb_lookup_prefix	./ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *__ebmb_lookup_prefix(struct eb_root *root, const void *x, unsigned int pfx)$/;"	f
__ebpt_delete	./ebtree/ebpttree.h	/^static forceinline void __ebpt_delete(struct ebpt_node *ebpt)$/;"	f
__ebpt_insert	./ebtree/ebpttree.h	/^static forceinline struct ebpt_node *__ebpt_insert(struct eb_root *root, struct ebpt_node *new)$/;"	f
__ebpt_lookup	./ebtree/ebpttree.h	/^static forceinline struct ebpt_node *__ebpt_lookup(struct eb_root *root, void *x)$/;"	f
__ebst_insert	./ebtree/ebsttree.h	/^__ebst_insert(struct eb_root *root, struct ebmb_node *new)$/;"	f
__ebst_lookup	./ebtree/ebsttree.h	/^static forceinline struct ebmb_node *__ebst_lookup(struct eb_root *root, const void *x)$/;"	f
__fd_clo	./src/ev_epoll.c	/^REGPRM1 static void __fd_clo(int fd)$/;"	f	file:
__fd_clo	./src/ev_poll.c	/^REGPRM1 static void __fd_clo(int fd)$/;"	f	file:
__fd_clo	./src/ev_select.c	/^REGPRM1 static void __fd_clo(int fd)$/;"	f	file:
__frontend_init	./src/frontend.c	/^static void __frontend_init(void)$/;"	f	file:
__full_hash	./include/common/standard.h	/^static inline unsigned int __full_hash(unsigned int a)$/;"	f
__health_adjust	./src/checks.c	/^void __health_adjust(struct server *s, short status)$/;"	f
__http_protocol_init	./src/proto_http.c	/^static void __http_protocol_init(void)$/;"	f	file:
__http_protocol_init	./src/vars.c	/^static void __http_protocol_init(void)$/;"	f	file:
__i386_linux_vsyscall_init	./src/i386-linux-vsys.c	/^static void __i386_linux_vsyscall_init(void)$/;"	f	file:
__listener_init	./src/listener.c	/^static void __listener_init(void)$/;"	f	file:
__listener_init	./src/server.c	/^static void __listener_init(void)$/;"	f	file:
__map_init	./src/map.c	/^static void __map_init(void)$/;"	f	file:
__objt_appctx	./include/proto/obj_type.h	/^static inline struct appctx *__objt_appctx(enum obj_type *t)$/;"	f
__objt_applet	./include/proto/obj_type.h	/^static inline struct applet *__objt_applet(enum obj_type *t)$/;"	f
__objt_conn	./include/proto/obj_type.h	/^static inline struct connection *__objt_conn(enum obj_type *t)$/;"	f
__objt_listener	./include/proto/obj_type.h	/^static inline struct listener *__objt_listener(enum obj_type *t)$/;"	f
__objt_proxy	./include/proto/obj_type.h	/^static inline struct proxy *__objt_proxy(enum obj_type *t)$/;"	f
__objt_server	./include/proto/obj_type.h	/^static inline struct server *__objt_server(enum obj_type *t)$/;"	f
__payload_init	./src/payload.c	/^static void __payload_init(void)$/;"	f	file:
__pipe_module_init	./src/pipe.c	/^static void __pipe_module_init(void)$/;"	f	file:
__protocol_by_family	./src/protocol.c	/^struct protocol *__protocol_by_family[AF_MAX] = { };$/;"	v	typeref:struct:protocol
__proxy_module_init	./src/proxy.c	/^static void __proxy_module_init(void)$/;"	f	file:
__rb_erase_color	./src/rbtree.c	/^static void __rb_erase_color(struct rb_node *node, struct rb_node *parent,$/;"	f	file:
__rb_rotate_left	./src/rbtree.c	/^static void __rb_rotate_left(struct rb_node *node, struct rb_root *root)$/;"	f	file:
__rb_rotate_right	./src/rbtree.c	/^static void __rb_rotate_right(struct rb_node *node, struct rb_root *root)$/;"	f	file:
__read_uint	./include/common/standard.h	/^static inline unsigned int __read_uint(const char **s, const char *end)$/;"	f
__sample_init	./src/sample.c	/^static void __sample_init(void)$/;"	f	file:
__send_log	./src/log.c	/^void __send_log(struct proxy *p, int level, char *message, size_t size, char *sd, size_t sd_size)$/;"	f
__signal_process_queue	./src/signal.c	/^void __signal_process_queue()$/;"	f
__ssl_sock_deinit	./src/ssl_sock.c	/^static void __ssl_sock_deinit(void)$/;"	f	file:
__ssl_sock_init	./src/ssl_sock.c	/^static void __ssl_sock_init(void)$/;"	f	file:
__stick_table_init	./src/stick_table.c	/^static void __stick_table_init(void)$/;"	f	file:
__str2ui	./include/common/standard.h	/^static inline unsigned int __str2ui(const char *s)$/;"	f
__str2uic	./include/common/standard.h	/^static inline unsigned int __str2uic(const char *s)$/;"	f
__stream_init	./src/stream.c	/^static void __stream_init(void)$/;"	f	file:
__stream_offer_buffers	./src/stream.c	/^void __stream_offer_buffers(int rqlimit)$/;"	f
__strl2ui	./contrib/halog/halog.c	/^static inline unsigned int __strl2ui(const char *s, int len)$/;"	f	file:
__strl2ui	./include/common/standard.h	/^static inline unsigned int __strl2ui(const char *s, int len)$/;"	f
__strl2uic	./include/common/standard.h	/^static inline unsigned int __strl2uic(const char *s, int len)$/;"	f
__task_queue	./src/task.c	/^void __task_queue(struct task *task)$/;"	f
__task_unlink_rq	./include/proto/task.h	/^static inline struct task *__task_unlink_rq(struct task *t)$/;"	f
__task_unlink_wq	./include/proto/task.h	/^static inline struct task *__task_unlink_wq(struct task *t)$/;"	f
__task_wakeup	./src/task.c	/^struct task *__task_wakeup(struct task *t)$/;"	f
__tcp_protocol_init	./src/proto_tcp.c	/^static void __tcp_protocol_init(void)$/;"	f	file:
__tv_add	./include/common/time.h	/^REGPRM3 static inline struct timeval *__tv_add(struct timeval *tv, const struct timeval *from, const struct timeval *inc)$/;"	f
__tv_add2	./include/common/time.h	/^REGPRM2 static inline struct timeval *__tv_add2(struct timeval *tv, const struct timeval *inc)$/;"	f
__tv_add_ifset	./include/common/time.h	/^REGPRM3 static inline int __tv_add_ifset(struct timeval *tv, const struct timeval *from, const struct timeval *inc)$/;"	f
__tv_cmp	./include/common/time.h	/^REGPRM2 static inline int __tv_cmp(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_from_ms	./include/common/time.h	/^REGPRM2 static inline struct timeval * __tv_from_ms(struct timeval *tv, unsigned long ms)$/;"	f
__tv_iseq	./include/common/time.h	/^REGPRM2 static inline int __tv_iseq(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_isge	./include/common/time.h	/^REGPRM2 static inline int __tv_isge(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_isgt	./include/common/time.h	/^REGPRM2 static inline int __tv_isgt(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_isle	./include/common/time.h	/^REGPRM2 static inline int __tv_isle(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_islt	./include/common/time.h	/^REGPRM2 static inline int __tv_islt(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_ms_add	./include/common/time.h	/^REGPRM3 static inline struct timeval *__tv_ms_add(struct timeval *tv, const struct timeval *from, int ms)$/;"	f
__tv_ms_cmp	./include/common/time.h	/^REGPRM2 static inline int __tv_ms_cmp(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_ms_cmp2	./include/common/time.h	/^REGPRM2 static inline int __tv_ms_cmp2(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_ms_elapsed	./include/common/time.h	/^REGPRM2 static inline unsigned long __tv_ms_elapsed(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_ms_le2	./include/common/time.h	/^REGPRM2 static inline int __tv_ms_le2(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_ms_remain	./include/common/time.h	/^REGPRM2 static inline unsigned long __tv_ms_remain(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_ms_remain2	./include/common/time.h	/^REGPRM2 static inline unsigned long __tv_ms_remain2(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_remain	./include/common/time.h	/^REGPRM3 static inline struct timeval *__tv_remain(const struct timeval *tv1, const struct timeval *tv2, struct timeval *tv)$/;"	f
__tv_remain2	./include/common/time.h	/^REGPRM3 static inline struct timeval *__tv_remain2(const struct timeval *tv1, const struct timeval *tv2, struct timeval *tv)$/;"	f
__tv_to_ms	./include/common/time.h	/^REGPRM1 static inline unsigned long __tv_to_ms(const struct timeval *tv)$/;"	f
__usec_to_1024th	./include/common/time.h	/^REGPRM1 static inline unsigned int __usec_to_1024th(unsigned int usec)$/;"	f
__uxst_protocol_init	./src/proto_uxst.c	/^static void __uxst_protocol_init(void)$/;"	f	file:
_do_fork	./src/ev_epoll.c	/^REGPRM1 static int _do_fork(struct poller *p)$/;"	f	file:
_do_fork	./src/ev_kqueue.c	/^REGPRM1 static int _do_fork(struct poller *p)$/;"	f	file:
_do_init	./src/ev_epoll.c	/^REGPRM1 static int _do_init(struct poller *p)$/;"	f	file:
_do_init	./src/ev_kqueue.c	/^REGPRM1 static int _do_init(struct poller *p)$/;"	f	file:
_do_init	./src/ev_poll.c	/^REGPRM1 static int _do_init(struct poller *p)$/;"	f	file:
_do_init	./src/ev_select.c	/^REGPRM1 static int _do_init(struct poller *p)$/;"	f	file:
_do_poll	./src/ev_epoll.c	/^REGPRM2 static void _do_poll(struct poller *p, int exp)$/;"	f	file:
_do_poll	./src/ev_kqueue.c	/^REGPRM2 static void _do_poll(struct poller *p, int exp)$/;"	f	file:
_do_poll	./src/ev_poll.c	/^REGPRM2 static void _do_poll(struct poller *p, int exp)$/;"	f	file:
_do_poll	./src/ev_select.c	/^REGPRM2 static void _do_poll(struct poller *p, int exp)$/;"	f	file:
_do_register	./src/ev_epoll.c	/^static void _do_register(void)$/;"	f	file:
_do_register	./src/ev_kqueue.c	/^static void _do_register(void)$/;"	f	file:
_do_register	./src/ev_poll.c	/^static void _do_register(void)$/;"	f	file:
_do_register	./src/ev_select.c	/^static void _do_register(void)$/;"	f	file:
_do_term	./src/ev_epoll.c	/^REGPRM1 static void _do_term(struct poller *p)$/;"	f	file:
_do_term	./src/ev_kqueue.c	/^REGPRM1 static void _do_term(struct poller *p)$/;"	f	file:
_do_term	./src/ev_poll.c	/^REGPRM1 static void _do_term(struct poller *p)$/;"	f	file:
_do_term	./src/ev_select.c	/^REGPRM1 static void _do_term(struct poller *p)$/;"	f	file:
_do_test	./src/ev_epoll.c	/^REGPRM1 static int _do_test(struct poller *p)$/;"	f	file:
_do_test	./src/ev_kqueue.c	/^REGPRM1 static int _do_test(struct poller *p)$/;"	f	file:
_do_test	./src/ev_poll.c	/^REGPRM1 static int _do_test(struct poller *p)$/;"	f	file:
_do_test	./src/ev_select.c	/^REGPRM1 static int _do_test(struct poller *p)$/;"	f	file:
_hlua_channel_dup	./src/hlua.c	/^static inline int _hlua_channel_dup(struct channel *chn, lua_State *L)$/;"	f	file:
_hlua_map_lookup	./src/hlua.c	/^__LJMP static inline int _hlua_map_lookup(struct lua_State *L, int str)$/;"	f	file:
_shared_context_awakelocker	./src/shctx.c	/^#define _shared_context_awakelocker(/;"	d	file:
_shared_context_awakelocker	./src/shctx.c	/^static inline void _shared_context_awakelocker(unsigned int *uaddr)$/;"	f	file:
_shared_context_lock	./src/shctx.c	/^static inline void _shared_context_lock(void)$/;"	f	file:
_shared_context_unlock	./src/shctx.c	/^static inline void _shared_context_unlock(void)$/;"	f	file:
_shared_context_wait4lock	./src/shctx.c	/^static inline void _shared_context_wait4lock(unsigned int *count, unsigned int *uaddr, int value)$/;"	f	file:
_syscall1	./include/common/syscall.h	/^#define _syscall1(/;"	d
_syscall2	./include/common/syscall.h	/^#define _syscall2(/;"	d
_syscall3	./include/common/syscall.h	/^#define _syscall3(/;"	d
_syscall4	./include/common/syscall.h	/^#define _syscall4(/;"	d
_syscall5	./include/common/syscall.h	/^#define _syscall5(/;"	d
_syscall6	./include/common/syscall.h	/^#define _syscall6(/;"	d
_tv_add	./src/time.c	/^REGPRM3 struct timeval *_tv_add(struct timeval *tv, const struct timeval *from, const struct timeval *inc)$/;"	f
_tv_add_ifset	./src/time.c	/^REGPRM3 int _tv_add_ifset(struct timeval *tv, const struct timeval *from, const struct timeval *inc)$/;"	f
_tv_isgt	./src/time.c	/^REGPRM2 int _tv_isgt(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
_tv_isle	./src/time.c	/^REGPRM2 int _tv_isle(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
_tv_ms_add	./src/time.c	/^REGPRM3 struct timeval *_tv_ms_add(struct timeval *tv, const struct timeval *from, int ms)$/;"	f
_tv_ms_cmp	./src/time.c	/^REGPRM2 int _tv_ms_cmp(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
_tv_ms_cmp2	./src/time.c	/^REGPRM2 int _tv_ms_cmp2(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
_tv_ms_elapsed	./src/time.c	/^REGPRM2 unsigned long _tv_ms_elapsed(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
_tv_ms_le2	./src/time.c	/^REGPRM2 int _tv_ms_le2(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
_tv_ms_remain	./src/time.c	/^REGPRM2 unsigned long _tv_ms_remain(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
_tv_ms_remain2	./src/time.c	/^REGPRM2 unsigned long _tv_ms_remain2(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
_tv_remain	./src/time.c	/^REGPRM3 struct timeval *_tv_remain(const struct timeval *tv1, const struct timeval *tv2, struct timeval *tv)$/;"	f
_tv_remain2	./src/time.c	/^REGPRM3 struct timeval *_tv_remain2(const struct timeval *tv1, const struct timeval *tv2, struct timeval *tv)$/;"	f
a	./include/types/sample.h	/^	void *a[8];     \/* any array of up to 8 pointers *\/$/;"	m	union:smp_ctx
a2base64	./src/base64.c	/^int a2base64(char *in, int ilen, char *out, int olen)$/;"	f
a_and_b	./contrib/ip6range/ip6range.c	/^static inline struct in6_addr *a_and_b(struct in6_addr *a, struct in6_addr *b, struct in6_addr *r)$/;"	f	file:
a_eq_b	./contrib/ip6range/ip6range.c	/^static inline int a_eq_b(struct in6_addr *a, struct in6_addr *b)$/;"	f	file:
a_gt_b	./contrib/ip6range/ip6range.c	/^static inline int a_gt_b(struct in6_addr *a, struct in6_addr *b)$/;"	f	file:
a_le_b	./contrib/ip6range/ip6range.c	/^static inline int a_le_b(struct in6_addr *a, struct in6_addr *b)$/;"	f	file:
a_minus_b	./contrib/ip6range/ip6range.c	/^static inline struct in6_addr *a_minus_b(struct in6_addr *a, struct in6_addr *b, struct in6_addr *r)$/;"	f	file:
a_plus_b	./contrib/ip6range/ip6range.c	/^static inline struct in6_addr *a_plus_b(struct in6_addr *a, struct in6_addr *b, struct in6_addr *r)$/;"	f	file:
aa	./include/types/dns.h	/^	unsigned char	aa :1;		\/* authoritative answer 0: no, 1: yes *\/$/;"	m	struct:dns_header
accept	./include/types/listener.h	/^	int (*accept)(struct listener *l, int fd, struct sockaddr_storage *addr); \/* upper layer's accept() *\/$/;"	m	struct:listener
accept	./include/types/protocol.h	/^	int (*accept)(int fd);				\/* generic accept function *\/$/;"	m	struct:protocol
accept	./include/types/proxy.h	/^	int (*accept)(struct stream *s);       \/* application layer's accept() *\/$/;"	m	struct:proxy
accept4	./include/common/accept4.h	/^static int accept4(int sockfd, struct sockaddr *addr, socklen_t *addrlen, int flags)$/;"	f
accept_date	./include/types/session.h	/^	struct timeval accept_date;     \/* date of the session's accept() in user date *\/$/;"	m	struct:session	typeref:struct:session::timeval
accept_date	./include/types/stream.h	/^	struct timeval accept_date;     \/* date of the stream's accept() in user date *\/$/;"	m	struct:strm_logs	typeref:struct:strm_logs::timeval
acl	./include/types/acl.h	/^	struct acl *acl;            \/* acl pointed to by this term *\/$/;"	m	struct:acl_term	typeref:struct:acl_term::acl
acl	./include/types/acl.h	/^struct acl {$/;"	s
acl	./include/types/proxy.h	/^	struct list acl;                        \/* ACL declared on this proxy *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
acl_cond	./include/types/acl.h	/^struct acl_cond {$/;"	s
acl_cond_conflicts	./src/acl.c	/^const struct acl *acl_cond_conflicts(const struct acl_cond *cond, unsigned int where)$/;"	f
acl_cond_kw_conflicts	./src/acl.c	/^int acl_cond_kw_conflicts(const struct acl_cond *cond, unsigned int where, struct acl const **acl, char const **kw)$/;"	f
acl_cond_pol	./include/types/acl.h	/^enum acl_cond_pol {$/;"	g
acl_exec_cond	./src/acl.c	/^enum acl_test_res acl_exec_cond(struct acl_cond *cond, struct proxy *px, struct session *sess, struct stream *strm, unsigned int opt)$/;"	f
acl_expr	./include/types/acl.h	/^struct acl_expr {$/;"	s
acl_find_targets	./src/acl.c	/^int acl_find_targets(struct proxy *p)$/;"	f
acl_keyword	./include/types/acl.h	/^struct acl_keyword {$/;"	s
acl_keywords	./src/acl.c	/^static struct acl_kw_list acl_keywords = {$/;"	v	typeref:struct:acl_kw_list	file:
acl_kw_list	./include/types/acl.h	/^struct acl_kw_list {$/;"	s
acl_kws	./src/acl.c	/^static struct acl_kw_list acl_kws = {ILH, {$/;"	v	typeref:struct:acl_kw_list	file:
acl_kws	./src/backend.c	/^static struct acl_kw_list acl_kws = {ILH, {$/;"	v	typeref:struct:acl_kw_list	file:
acl_kws	./src/compression.c	/^static struct acl_kw_list acl_kws = {ILH, {$/;"	v	typeref:struct:acl_kw_list	file:
acl_kws	./src/frontend.c	/^static struct acl_kw_list acl_kws = {ILH, {$/;"	v	typeref:struct:acl_kw_list	file:
acl_kws	./src/listener.c	/^static struct acl_kw_list acl_kws = {ILH, {$/;"	v	typeref:struct:acl_kw_list	file:
acl_kws	./src/payload.c	/^static struct acl_kw_list acl_kws = {ILH, {$/;"	v	typeref:struct:acl_kw_list	file:
acl_kws	./src/proto_http.c	/^static struct acl_kw_list acl_kws = {ILH, {$/;"	v	typeref:struct:acl_kw_list	file:
acl_kws	./src/proto_tcp.c	/^static struct acl_kw_list acl_kws = {ILH, {$/;"	v	typeref:struct:acl_kw_list	file:
acl_kws	./src/ssl_sock.c	/^static struct acl_kw_list acl_kws = {ILH, {$/;"	v	typeref:struct:acl_kw_list	file:
acl_kws	./src/stream.c	/^static struct acl_kw_list acl_kws = {ILH, {$/;"	v	typeref:struct:acl_kw_list	file:
acl_neg	./include/proto/acl.h	/^static inline enum acl_test_res acl_neg(enum acl_test_res res)$/;"	f
acl_pass	./include/proto/acl.h	/^static inline int acl_pass(enum acl_test_res res)$/;"	f
acl_register_keywords	./src/acl.c	/^void acl_register_keywords(struct acl_kw_list *kwl)$/;"	f
acl_term	./include/types/acl.h	/^struct acl_term {$/;"	s
acl_term_suite	./include/types/acl.h	/^struct acl_term_suite {$/;"	s
acl_test_res	./include/types/acl.h	/^enum acl_test_res {$/;"	g
acl_unregister_keywords	./src/acl.c	/^void acl_unregister_keywords(struct acl_kw_list *kwl)$/;"	f
act	./include/types/action.h	/^		} act;                         \/* generic pointers to be used by custom actions *\/$/;"	m	union:act_rule::__anon9	typeref:struct:act_rule::__anon9::__anon20
act	./include/types/lb_chash.h	/^	struct eb_root act;	\/* weighted chash entries of active servers *\/$/;"	m	struct:lb_chash	typeref:struct:lb_chash::eb_root
act	./include/types/lb_fas.h	/^	struct eb_root act;	\/* weighted least conns on the active servers *\/$/;"	m	struct:lb_fas	typeref:struct:lb_fas::eb_root
act	./include/types/lb_fwlc.h	/^	struct eb_root act;	\/* weighted least conns on the active servers *\/$/;"	m	struct:lb_fwlc	typeref:struct:lb_fwlc::eb_root
act	./include/types/lb_fwrr.h	/^	struct fwrr_group act;	\/* weighted round robin on the active servers *\/$/;"	m	struct:lb_fwrr	typeref:struct:lb_fwrr::fwrr_group
act_flag	./include/types/action.h	/^enum act_flag {$/;"	g
act_from	./include/types/action.h	/^enum act_from {$/;"	g
act_name	./include/types/action.h	/^enum act_name {$/;"	g
act_parse_ret	./include/types/action.h	/^enum act_parse_ret {$/;"	g
act_return	./include/types/action.h	/^enum act_return {$/;"	g
act_rule	./include/types/action.h	/^struct act_rule {$/;"	s
actconn	./src/fd.c	/^int actconn;                    \/* # of active sessions *\/$/;"	v
actconns	./include/types/server.h	/^	struct list actconns;			\/* active connections *\/$/;"	m	struct:server	typeref:struct:server::list
action	./include/common/regex.h	/^    int action;				\/* ACT_ALLOW, ACT_REPLACE, ACT_REMOVE, ACT_DENY *\/$/;"	m	struct:hdr_exp
action	./include/types/action.h	/^			int action;$/;"	m	struct:act_rule::__anon9::__anon13
action	./include/types/action.h	/^	enum act_name action;                  \/* ACT_ACTION_* *\/$/;"	m	struct:act_rule	typeref:enum:act_rule::act_name
action	./include/types/checks.h	/^	int action;                             \/* action: send or expect *\/$/;"	m	struct:tcpcheck_rule
action_build_list	./include/proto/action.h	/^static inline void action_build_list(struct list *keywords, struct chunk *chk)$/;"	f
action_http_req_custom	./src/proto_http.c	/^struct action_kw *action_http_req_custom(const char *kw)$/;"	f
action_http_res_custom	./src/proto_http.c	/^struct action_kw *action_http_res_custom(const char *kw)$/;"	f
action_http_set_status	./src/proto_http.c	/^enum act_return action_http_set_status(struct act_rule *rule, struct proxy *px,$/;"	f
action_inc_gpc0	./src/stick_table.c	/^static enum act_return action_inc_gpc0(struct act_rule *rule, struct proxy *px,$/;"	f	file:
action_kw	./include/types/action.h	/^struct action_kw {$/;"	s
action_kw_list	./include/types/action.h	/^struct action_kw_list {$/;"	s
action_lookup	./include/proto/action.h	/^static inline struct action_kw *action_lookup(struct list *keywords, const char *kw)$/;"	f
action_ptr	./include/types/action.h	/^	enum act_return (*action_ptr)(struct act_rule *rule, struct proxy *px,  \/* ptr to custom action *\/$/;"	m	struct:act_rule	typeref:enum:act_rule::action_ptr
action_register_lua	./src/hlua.c	/^static enum act_parse_ret action_register_lua(const char **args, int *cur_arg, struct proxy *px,$/;"	f	file:
action_register_service_http	./src/hlua.c	/^static enum act_parse_ret action_register_service_http(const char **args, int *cur_arg, struct proxy *px,$/;"	f	file:
action_register_service_tcp	./src/hlua.c	/^static enum act_parse_ret action_register_service_tcp(const char **args, int *cur_arg, struct proxy *px,$/;"	f	file:
action_set_gpt0	./src/stick_table.c	/^static enum act_return action_set_gpt0(struct act_rule *rule, struct proxy *px,$/;"	f	file:
action_store	./src/vars.c	/^static enum act_return action_store(struct act_rule *rule, struct proxy *px,$/;"	f	file:
active	./src/shctx.c	/^	struct shared_block active;$/;"	m	struct:shared_context	typeref:struct:shared_context::shared_block	file:
ad	./include/types/dns.h	/^	unsigned char	ad :1;		\/* authentic data *\/$/;"	m	struct:dns_header
add_data	./include/types/compression.h	/^	int (*add_data)(struct comp_ctx *comp_ctx, const char *in_data, int in_len, struct buffer *out);$/;"	m	struct:comp_algo
add_sample_to_logformat_list	./src/log.c	/^void add_sample_to_logformat_list(char *text, char *arg, int arg_len, struct proxy *curpx, struct list *list_format, int options, int cap, const char *file, int line)$/;"	f
add_tcpcheck_expect_str	./src/checks.c	/^static int add_tcpcheck_expect_str(struct list *list, const char *str)$/;"	f	file:
add_tcpcheck_send_strs	./src/checks.c	/^static int add_tcpcheck_send_strs(struct list *list, const char * const *strs)$/;"	f	file:
add_to_logformat_list	./src/log.c	/^void add_to_logformat_list(char *start, char *end, int type, struct list *list_format)$/;"	f
addr	./include/types/checks.h	/^	struct sockaddr_storage addr;   	\/* the address to check *\/$/;"	m	struct:check	typeref:struct:check::sockaddr_storage
addr	./include/types/connection.h	/^	} addr; \/* addresses of the remote side, client for producer and server for consumer *\/$/;"	m	struct:connection	typeref:struct:connection::__anon52
addr	./include/types/connection.h	/^	} addr;$/;"	m	struct:proxy_hdr_v2	typeref:union:proxy_hdr_v2::__anon53
addr	./include/types/dns.h	/^	struct sockaddr_storage addr;	\/* IP address *\/$/;"	m	struct:dns_nameserver	typeref:struct:dns_nameserver::sockaddr_storage
addr	./include/types/listener.h	/^	struct sockaddr_storage addr;	\/* the address we listen to *\/$/;"	m	struct:listener	typeref:struct:listener::sockaddr_storage
addr	./include/types/log.h	/^	struct sockaddr_storage addr;$/;"	m	struct:logsrv	typeref:struct:logsrv::sockaddr_storage
addr	./include/types/mailers.h	/^	struct sockaddr_storage addr;	\/* SMTP server address *\/$/;"	m	struct:mailer	typeref:struct:mailer::sockaddr_storage
addr	./include/types/pattern.h	/^			struct in6_addr addr;$/;"	m	struct:pattern::__anon87::__anon90	typeref:struct:pattern::__anon87::__anon90::in6_addr
addr	./include/types/pattern.h	/^			struct in_addr addr;$/;"	m	struct:pattern::__anon87::__anon89	typeref:struct:pattern::__anon87::__anon89::in_addr
addr	./include/types/peers.h	/^	struct sockaddr_storage addr;  \/* peer address *\/$/;"	m	struct:peer	typeref:struct:peer::sockaddr_storage
addr	./include/types/proto_udp.h	/^	} addr;					\/* addresses of the remote side, client for producer and server for consumer *\/$/;"	m	struct:dgram_conn	typeref:struct:dgram_conn::__anon104
addr	./include/types/server.h	/^	struct sockaddr_storage addr;		\/* the address to connect to *\/$/;"	m	struct:server	typeref:struct:server::sockaddr_storage
addr_to_str	./src/standard.c	/^int addr_to_str(struct sockaddr_storage *addr, char *str, int size)$/;"	f
admin	./include/types/server.h	/^	enum srv_admin admin, prev_admin;       \/* server maintenance status : SRV_ADMF_* *\/$/;"	m	struct:server	typeref:enum:server::srv_admin
admin_rules	./include/common/uri_auth.h	/^	struct list admin_rules;	\/* 'stats admin' rules (chained) *\/$/;"	m	struct:uri_auth	typeref:struct:uri_auth::list
aes_key	./include/types/ssl_sock.h	/^	unsigned char aes_key[16];$/;"	m	struct:tls_sess_key
after_poll	./src/time.c	/^struct timeval after_poll;      \/* system date after leaving poll() *\/$/;"	v	typeref:struct:timeval
agent	./include/types/server.h	/^	struct check agent;                     \/* agent specific configuration *\/$/;"	m	struct:server	typeref:struct:server::check
alertif_too_many_args	./src/cfgparse.c	/^int alertif_too_many_args(int maxarg, const char *file, int linenum, char **args, int *err_code)$/;"	f
alertif_too_many_args_idx	./src/cfgparse.c	/^int alertif_too_many_args_idx(int maxarg, int index, const char *file, int linenum, char **args, int *err_code)$/;"	f
algo	./include/types/backend.h	/^	int algo;			\/* load balancing algorithm and variants: BE_LB_* *\/$/;"	m	struct:lbprm
algos	./include/types/compression.h	/^	struct comp_algo *algos;$/;"	m	struct:comp	typeref:struct:comp::comp_algo
alloc_stats_fe	./src/dumpstats.c	/^static struct proxy *alloc_stats_fe(const char *name, const char *file, int line)$/;"	f	file:
alloc_trash_buffers	./src/chunk.c	/^int alloc_trash_buffers(int bufsize)$/;"	f
alloc_zlib	./src/compression.c	/^static void *alloc_zlib(void *opaque, unsigned int items, unsigned int size)$/;"	f	file:
allocated	./include/common/memory.h	/^	unsigned int allocated;	\/* how many chunks have been allocated *\/$/;"	m	struct:pool_head
allocated	./src/hlua.c	/^	size_t allocated;$/;"	m	struct:hlua_mem_allocator	file:
alltrim	./include/common/standard.h	/^static inline char *alltrim(char *s, char c) {$/;"	f
alpn_len	./include/types/listener.h	/^	int alpn_len;              \/* ALPN protocol string length *\/$/;"	m	struct:bind_conf
alpn_str	./include/types/listener.h	/^	char *alpn_str;            \/* ALPN protocol string *\/$/;"	m	struct:bind_conf
already_warned	./include/types/global.h	/^static inline int already_warned(unsigned int warning)$/;"	f
analyse_exp	./include/types/channel.h	/^	int analyse_exp;                \/* expiration date for current analysers (if set) *\/$/;"	m	struct:channel
analysers	./include/types/channel.h	/^	unsigned int analysers;         \/* bit field indicating what to do on the channel *\/$/;"	m	struct:channel
analysers	./include/types/listener.h	/^	unsigned int analysers;		\/* bitmap of required protocol analysers *\/$/;"	m	struct:listener
analyze_status	./include/types/checks.h	/^struct analyze_status {$/;"	s
analyze_statuses	./src/checks.c	/^static const struct analyze_status analyze_statuses[HANA_STATUS_SIZE] = {		\/* 0: ignore, 1: error, 2: OK *\/$/;"	v	typeref:struct:analyze_status	file:
ancount	./include/types/dns.h	/^	unsigned short	ancount :16;	\/* answer count *\/$/;"	m	struct:dns_header
any_err	./include/types/dns.h	/^		long int any_err;	\/* - void response (usually because ANY qtype) *\/$/;"	m	struct:dns_nameserver::__anon65
appctx	./include/types/applet.h	/^struct appctx {$/;"	s
appctx	./include/types/hlua.h	/^	struct appctx *appctx;$/;"	m	struct:hlua_appctx	typeref:struct:hlua_appctx::appctx
appctx	./include/types/peers.h	/^	struct appctx *appctx;        \/* the appctx running it *\/$/;"	m	struct:peer	typeref:struct:peer::appctx
appctx_free	./include/proto/applet.h	/^static inline void appctx_free(struct appctx *appctx)$/;"	f
appctx_init	./include/proto/applet.h	/^static inline void appctx_init(struct appctx *appctx)$/;"	f
appctx_new	./include/proto/applet.h	/^static inline struct appctx *appctx_new(struct applet *applet)$/;"	f
appctx_pause	./include/proto/applet.h	/^static inline void appctx_pause(struct appctx *appctx)$/;"	f
appctx_wakeup	./include/proto/applet.h	/^static inline void appctx_wakeup(struct appctx *appctx)$/;"	f
applet	./include/types/action.h	/^	struct applet applet;                  \/* used for the applet registration. *\/$/;"	m	struct:act_rule	typeref:struct:act_rule::applet
applet	./include/types/applet.h	/^	struct applet *applet;     \/* applet this context refers to *\/$/;"	m	struct:appctx	typeref:struct:appctx::applet
applet	./include/types/applet.h	/^struct applet {$/;"	s
applet_active_queue	./src/applet.c	/^struct list applet_active_queue = LIST_HEAD_INIT(applet_active_queue);$/;"	v	typeref:struct:list
applet_run_active	./src/applet.c	/^void applet_run_active()$/;"	f
applet_run_queue	./src/applet.c	/^struct list applet_run_queue    = LIST_HEAD_INIT(applet_run_queue);$/;"	v	typeref:struct:list
apply_filter_to_req_headers	./src/proto_http.c	/^int apply_filter_to_req_headers(struct stream *s, struct channel *req, struct hdr_exp *exp)$/;"	f
apply_filter_to_req_line	./src/proto_http.c	/^int apply_filter_to_req_line(struct stream *s, struct channel *req, struct hdr_exp *exp)$/;"	f
apply_filter_to_resp_headers	./src/proto_http.c	/^int apply_filter_to_resp_headers(struct stream *s, struct channel *rtr, struct hdr_exp *exp)$/;"	f
apply_filter_to_sts_line	./src/proto_http.c	/^int apply_filter_to_sts_line(struct stream *s, struct channel *rtr, struct hdr_exp *exp)$/;"	f
apply_filters_to_request	./src/proto_http.c	/^int apply_filters_to_request(struct stream *s, struct channel *req, struct proxy *px)$/;"	f
apply_filters_to_response	./src/proto_http.c	/^int apply_filters_to_response(struct stream *s, struct channel *rtr, struct proxy *px)$/;"	f
apply_server_state	./src/server.c	/^void apply_server_state(void)$/;"	f
arcount	./include/types/dns.h	/^	unsigned short	arcount :16;	\/* additional count *\/$/;"	m	struct:dns_header
arg	./include/types/action.h	/^	} arg;                                 \/* arguments used by some actions *\/$/;"	m	struct:act_rule	typeref:union:act_rule::__anon9
arg	./include/types/arg.h	/^	struct arg *arg;          \/* pointer to the arg, NULL on list head *\/$/;"	m	struct:arg_list	typeref:struct:arg_list::arg
arg	./include/types/arg.h	/^struct arg {$/;"	s
arg	./include/types/listener.h	/^	char *arg;                 \/* argument passed to "bind" for better error reporting *\/$/;"	m	struct:bind_conf
arg	./include/types/log.h	/^	char *arg;     \/\/ text for LOG_FMT_TEXT, arg for others$/;"	m	struct:logformat_node
arg	./include/types/signal.h	/^	int arg;                        \/* arg to pass to function, or signals*\/$/;"	m	struct:sig_handler
arg_data	./include/types/arg.h	/^union arg_data {$/;"	u
arg_list	./include/types/arg.h	/^struct arg_list {$/;"	s
arg_list_add	./src/arg.c	/^struct arg_list *arg_list_add(struct arg_list *orig, struct arg *arg, int pos)$/;"	f
arg_list_clone	./src/arg.c	/^struct arg_list *arg_list_clone(const struct arg_list *orig)$/;"	f
arg_mask	./include/types/sample.h	/^	unsigned int arg_mask;                    \/* arguments (ARG*()) *\/$/;"	m	struct:sample_conv
arg_mask	./include/types/sample.h	/^	unsigned int arg_mask;                    \/* arguments (ARG*()) *\/$/;"	m	struct:sample_fetch
arg_p	./include/types/sample.h	/^	struct arg *arg_p;                        \/* optional arguments *\/$/;"	m	struct:sample_conv_expr	typeref:struct:sample_conv_expr::arg
arg_p	./include/types/sample.h	/^	struct arg *arg_p;                        \/* optional pointer to arguments to fetch function *\/$/;"	m	struct:sample_expr	typeref:struct:sample_expr::arg
arg_pos	./include/types/arg.h	/^	int arg_pos;              \/* argument position *\/$/;"	m	struct:arg_list
arg_type	./include/types/stick_table.h	/^	int arg_type;     \/* type of optional argument, ARG_T_* *\/$/;"	m	struct:stktable_data_type
arg_type_names	./src/arg.c	/^const char *arg_type_names[ARGT_NBTYPES] = {$/;"	v
args	./include/types/hlua.h	/^	char **args;$/;"	m	struct:hlua_rule
args	./include/types/proxy.h	/^		struct arg_list args;           \/* sample arg list that need to be resolved *\/$/;"	m	struct:proxy::__anon109	typeref:struct:proxy::__anon109::arg_list
argv	./include/types/checks.h	/^	char **argv;				\/* the arguments to use if running a process-based check *\/$/;"	m	struct:check
arith_add	./src/sample.c	/^static inline long long int arith_add(long long int a, long long int b)$/;"	f	file:
asn1_generalizedtime_to_epoch	./src/ssl_sock.c	/^static long asn1_generalizedtime_to_epoch(ASN1_GENERALIZEDTIME *d)$/;"	f	file:
assign_server	./src/backend.c	/^int assign_server(struct stream *s)$/;"	f
assign_server_address	./src/backend.c	/^int assign_server_address(struct stream *s)$/;"	f
assign_server_and_queue	./src/backend.c	/^int assign_server_and_queue(struct stream *s)$/;"	f
assign_tproxy_address	./src/backend.c	/^static void assign_tproxy_address(struct stream *s)$/;"	f	file:
atlas	./include/types/global.h	/^		da_atlas_t atlas;$/;"	m	struct:global::__anon75
atlasimgptr	./include/types/global.h	/^		void *atlasimgptr;$/;"	m	struct:global::__anon75
atomic_dec	./src/shctx.c	/^static inline unsigned char atomic_dec(unsigned int *ptr)$/;"	f	file:
auth	./include/types/action.h	/^		} auth;                        \/* arg used by "auth" *\/$/;"	m	union:act_rule::__anon9	typeref:struct:act_rule::__anon9::__anon10
auth	./include/types/proto_http.h	/^	struct http_auth_data auth;	\/* HTTP auth data *\/$/;"	m	struct:http_txn	typeref:struct:http_txn::http_auth_data
auth_find_userlist	./src/auth.c	/^auth_find_userlist(char *name)$/;"	f
auth_groups	./include/types/auth.h	/^struct auth_groups {$/;"	s
auth_groups_list	./include/types/auth.h	/^struct auth_groups_list {$/;"	s
auth_realm	./include/common/uri_auth.h	/^	char *auth_realm;		\/* the realm reported to the client *\/$/;"	m	struct:uri_auth
auth_users	./include/types/auth.h	/^struct auth_users {$/;"	s
avail	./include/types/port_range.h	/^	int avail;			\/* number of available ports left *\/$/;"	m	struct:port_range
b	./ebtree/ebtree.h	/^	eb_troot_t    *b[EB_NODE_BRANCHES]; \/* left and right branches *\/$/;"	m	struct:eb_root
b	./include/types/hlua.h	/^	luaL_Buffer b; \/* buffer used to prepare strings. *\/$/;"	m	struct:hlua_appctx
b	./include/types/hlua.h	/^	luaL_Buffer b; \/* buffer used to prepare strings. *\/$/;"	m	struct:hlua_socket
b64tos30	./src/base64.c	/^int b64tos30(const char *in)$/;"	f
b:current_syntax	./examples/haproxy.vim	/^let b:current_syntax = "haproxy"$/;"	v
b_adv	./include/common/buffer.h	/^static inline void b_adv(struct buffer *b, unsigned int adv)$/;"	f
b_alloc	./include/common/buffer.h	/^static inline struct buffer *b_alloc(struct buffer **buf)$/;"	f
b_alloc_fast	./include/common/buffer.h	/^static inline struct buffer *b_alloc_fast(struct buffer **buf)$/;"	f
b_alloc_margin	./include/common/buffer.h	/^static inline struct buffer *b_alloc_margin(struct buffer **buf, int margin)$/;"	f
b_drop	./include/common/buffer.h	/^static inline void b_drop(struct buffer **buf)$/;"	f
b_flags	./include/types/proxy.h	/^	unsigned int b_flags;		\/* buffer flags *\/$/;"	m	struct:error_snapshot
b_free	./include/common/buffer.h	/^static inline void b_free(struct buffer **buf)$/;"	f
b_out	./include/types/proxy.h	/^	unsigned int b_out;		\/* pending output bytes *\/$/;"	m	struct:error_snapshot
b_ptr	./include/common/buffer.h	/^#define b_ptr(/;"	d
b_reset	./include/common/buffer.h	/^static inline void b_reset(struct buffer *buf)$/;"	f
b_rew	./include/common/buffer.h	/^static inline void b_rew(struct buffer *b, unsigned int adv)$/;"	f
b_tot	./include/types/proxy.h	/^	unsigned long long b_tot;	\/* total bytes transferred via this buffer *\/$/;"	m	struct:error_snapshot
b_wrap	./include/types/proxy.h	/^	unsigned int b_wrap;		\/* position where the buffer is expected to wrap *\/$/;"	m	struct:error_snapshot
back_ebx	./src/i386-linux-vsys.c	/^static __attribute__((used)) unsigned int back_ebx;$/;"	v	file:
back_refs	./include/types/stream.h	/^	struct list back_refs;          \/* list of users tracking this stream *\/$/;"	m	struct:stream	typeref:struct:stream::list
backend	./include/types/applet.h	/^			struct proxy *backend;$/;"	m	struct:appctx::__anon21::__anon34	typeref:struct:appctx::__anon21::__anon34::proxy
backend	./include/types/proxy.h	/^		struct proxy *backend;		\/* target backend *\/$/;"	m	union:switching_rule::__anon112	typeref:struct:switching_rule::__anon112::proxy
backend_lb_algo_str	./src/backend.c	/^const char *backend_lb_algo_str(int algo) {$/;"	f
backend_parse_balance	./src/backend.c	/^int backend_parse_balance(const char **args, char **err, struct proxy *curproxy)$/;"	f
backlog	./include/types/listener.h	/^	unsigned int backlog;		\/* if set, listen backlog *\/$/;"	m	struct:listener
backlog	./include/types/proxy.h	/^	unsigned int backlog;			\/* force the frontend's listen backlog *\/$/;"	m	struct:proxy
base	./contrib/base64/base64rev-gen.c	/^#define base /;"	d	file:
base64dec	./src/base64.c	/^int base64dec(const char *in, size_t ilen, char *out, size_t olen) {$/;"	f
base64rev	./contrib/base64/base64rev-gen.c	/^char base64rev[128];$/;"	v
base64rev	./src/base64.c	/^const char base64rev[]="b###cXYZ[\\\\]^_`a###d###$%&'()*+,-.\/0123456789:;<=######>?@ABCDEFGHIJKLMNOPQRSTUVW";$/;"	v
base64tab	./contrib/base64/base64rev-gen.c	/^const char base64tab[65]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+\/";$/;"	v
base64tab	./src/base64.c	/^const char base64tab[65]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+\/";$/;"	v
bck	./include/types/lb_chash.h	/^	struct eb_root bck;	\/* weighted chash entries of backup servers *\/$/;"	m	struct:lb_chash	typeref:struct:lb_chash::eb_root
bck	./include/types/lb_fas.h	/^	struct eb_root bck;	\/* weighted least conns on the backup servers *\/$/;"	m	struct:lb_fas	typeref:struct:lb_fas::eb_root
bck	./include/types/lb_fwlc.h	/^	struct eb_root bck;	\/* weighted least conns on the backup servers *\/$/;"	m	struct:lb_fwlc	typeref:struct:lb_fwlc::eb_root
bck	./include/types/lb_fwrr.h	/^	struct fwrr_group bck;	\/* weighted round robin on the backup servers *\/$/;"	m	struct:lb_fwrr	typeref:struct:lb_fwrr::fwrr_group
be	./include/types/proxy.h	/^		struct proxy *be;		\/* default backend, or NULL if none set *\/$/;"	m	union:proxy::__anon105	typeref:struct:proxy::__anon105::proxy
be	./include/types/proxy.h	/^	} be;$/;"	m	struct:switching_rule	typeref:union:switching_rule::__anon112
be	./include/types/stream.h	/^	struct proxy *be;               \/* the proxy this stream depends on for the server side *\/$/;"	m	struct:stream	typeref:struct:stream::proxy
be_counters	./include/types/proxy.h	/^	struct pxcounters be_counters;		\/* backend statistics counters *\/$/;"	m	struct:proxy	typeref:struct:proxy::pxcounters
be_downtime	./src/backend.c	/^int be_downtime(struct proxy *px) {$/;"	f
be_lastsession	./src/backend.c	/^int be_lastsession(const struct proxy *be)$/;"	f
be_req_ana	./include/types/proxy.h	/^	unsigned int fe_req_ana, be_req_ana;	\/* bitmap of common request protocol analysers for the frontend and backend *\/$/;"	m	struct:proxy
be_rsp_ana	./include/types/proxy.h	/^	unsigned int fe_rsp_ana, be_rsp_ana;	\/* bitmap of common response protocol analysers for the frontend and backend *\/$/;"	m	struct:proxy
be_sess_per_sec	./include/types/proxy.h	/^	struct freq_ctr be_sess_per_sec;	\/* sessions per second on the backend *\/$/;"	m	struct:proxy	typeref:struct:proxy::freq_ctr
be_set_sess_last	./include/proto/backend.h	/^static void inline be_set_sess_last(struct proxy *be)$/;"	f
beconn	./include/types/proxy.h	/^	unsigned int feconn, beconn;		\/* # of active frontend and backends streams *\/$/;"	m	struct:proxy
before_poll	./src/time.c	/^struct timeval before_poll;     \/* system date before calling poll() *\/$/;"	v	typeref:struct:timeval
bernstein	./tests/test_hashes.c	/^ub4 bernstein(ub1 *key, ub4 len, ub4 level){$/;"	f
bi	./include/types/checks.h	/^	struct buffer *bi, *bo;			\/* input and output buffers to send\/recv check *\/$/;"	m	struct:check	typeref:struct:check::buffer
bi_contig_data	./include/common/buffer.h	/^static inline int bi_contig_data(const struct buffer *b)$/;"	f
bi_end	./include/common/buffer.h	/^static inline char *bi_end(const struct buffer *b)$/;"	f
bi_fast_delete	./include/common/buffer.h	/^static inline void bi_fast_delete(struct buffer *buf, int n)$/;"	f
bi_getblk_nc	./src/channel.c	/^int bi_getblk_nc(struct channel *chn,$/;"	f
bi_getline_nc	./src/channel.c	/^int bi_getline_nc(struct channel *chn,$/;"	f
bi_ptr	./include/common/buffer.h	/^static inline char *bi_ptr(const struct buffer *b)$/;"	f
bi_putblk	./src/channel.c	/^int bi_putblk(struct channel *chn, const char *blk, int len)$/;"	f
bi_putchk	./include/proto/channel.h	/^static inline int bi_putchk(struct channel *chn, struct chunk *chunk)$/;"	f
bi_putchr	./src/channel.c	/^int bi_putchr(struct channel *chn, char c)$/;"	f
bi_putstr	./include/proto/channel.h	/^static inline int bi_putstr(struct channel *chn, const char *str)$/;"	f
bi_space_for_replace	./include/common/buffer.h	/^static inline int bi_space_for_replace(const struct buffer *buf)$/;"	f
bi_swpbuf	./src/channel.c	/^struct buffer *bi_swpbuf(struct channel *chn, struct buffer *buf)$/;"	f
bind	./include/types/protocol.h	/^	int (*bind)(struct listener *l, char *errmsg, int errlen); \/* bind a listener *\/$/;"	m	struct:protocol
bind	./include/types/proxy.h	/^		struct list bind;		\/* list of bind settings *\/$/;"	m	struct:proxy::__anon109	typeref:struct:proxy::__anon109::list
bind_all	./include/types/protocol.h	/^	int (*bind_all)(struct protocol *proto, char *errmsg, int errlen); \/* bind all unbound listeners *\/$/;"	m	struct:protocol
bind_conf	./include/types/listener.h	/^	struct bind_conf *bind_conf;	\/* "bind" line settings, include SSL settings among other things *\/$/;"	m	struct:listener	typeref:struct:listener::bind_conf
bind_conf	./include/types/listener.h	/^struct bind_conf {$/;"	s
bind_conf_alloc	./include/proto/listener.h	/^static inline struct bind_conf *bind_conf_alloc(struct list *lh, const char *file, int line, const char *arg)$/;"	f
bind_dump_kws	./src/listener.c	/^void bind_dump_kws(char **out)$/;"	f
bind_find_kw	./src/listener.c	/^struct bind_kw *bind_find_kw(const char *kw)$/;"	f
bind_hdr_len	./include/types/connection.h	/^	int bind_hdr_len;                    \/* length of the name of the header above *\/$/;"	m	struct:conn_src
bind_hdr_name	./include/types/connection.h	/^	char *bind_hdr_name;                 \/* bind to this header name if defined *\/$/;"	m	struct:conn_src
bind_hdr_occ	./include/types/connection.h	/^	int bind_hdr_occ;                    \/* occurrence number of header above: >0 = from first, <0 = from end, 0=disabled *\/$/;"	m	struct:conn_src
bind_keywords	./src/listener.c	/^static struct bind_kw_list bind_keywords = {$/;"	v	typeref:struct:bind_kw_list	file:
bind_kw	./include/types/listener.h	/^struct bind_kw {$/;"	s
bind_kw_list	./include/types/listener.h	/^struct bind_kw_list {$/;"	s
bind_kws	./src/dumpstats.c	/^static struct bind_kw_list bind_kws = { "STAT", { }, {$/;"	v	typeref:struct:bind_kw_list	file:
bind_kws	./src/listener.c	/^static struct bind_kw_list bind_kws = { "ALL", { }, {$/;"	v	typeref:struct:bind_kw_list	file:
bind_kws	./src/proto_tcp.c	/^static struct bind_kw_list bind_kws = { "TCP", { }, {$/;"	v	typeref:struct:bind_kw_list	file:
bind_kws	./src/proto_uxst.c	/^static struct bind_kw_list bind_kws = { "UNIX", { }, {$/;"	v	typeref:struct:bind_kw_list	file:
bind_kws	./src/ssl_sock.c	/^static struct bind_kw_list bind_kws = { "SSL", { }, {$/;"	v	typeref:struct:bind_kw_list	file:
bind_parse_accept_proxy	./src/listener.c	/^static int bind_parse_accept_proxy(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_alpn	./src/ssl_sock.c	/^static int bind_parse_alpn(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_backlog	./src/listener.c	/^static int bind_parse_backlog(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_ca_file	./src/ssl_sock.c	/^static int bind_parse_ca_file(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_ca_sign_file	./src/ssl_sock.c	/^static int bind_parse_ca_sign_file(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_ca_sign_pass	./src/ssl_sock.c	/^static int bind_parse_ca_sign_pass(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_ciphers	./src/ssl_sock.c	/^static int bind_parse_ciphers(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_crl_file	./src/ssl_sock.c	/^static int bind_parse_crl_file(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_crt	./src/ssl_sock.c	/^static int bind_parse_crt(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_crt_list	./src/ssl_sock.c	/^static int bind_parse_crt_list(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_defer_accept	./src/proto_tcp.c	/^static int bind_parse_defer_accept(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_ecdhe	./src/ssl_sock.c	/^static int bind_parse_ecdhe(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_force_sslv3	./src/ssl_sock.c	/^static int bind_parse_force_sslv3(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_force_tlsv10	./src/ssl_sock.c	/^static int bind_parse_force_tlsv10(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_force_tlsv11	./src/ssl_sock.c	/^static int bind_parse_force_tlsv11(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_force_tlsv12	./src/ssl_sock.c	/^static int bind_parse_force_tlsv12(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_generate_certs	./src/ssl_sock.c	/^static int bind_parse_generate_certs(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_gid	./src/proto_uxst.c	/^static int bind_parse_gid(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_group	./src/proto_uxst.c	/^static int bind_parse_group(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_id	./src/listener.c	/^static int bind_parse_id(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_ignore_err	./src/ssl_sock.c	/^static int bind_parse_ignore_err(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_interface	./src/proto_tcp.c	/^static int bind_parse_interface(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_level	./src/dumpstats.c	/^static int bind_parse_level(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_maxconn	./src/listener.c	/^static int bind_parse_maxconn(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_mode	./src/proto_uxst.c	/^static int bind_parse_mode(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_mss	./src/proto_tcp.c	/^static int bind_parse_mss(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_name	./src/listener.c	/^static int bind_parse_name(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_namespace	./src/proto_tcp.c	/^static int bind_parse_namespace(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_nice	./src/listener.c	/^static int bind_parse_nice(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_no_sslv3	./src/ssl_sock.c	/^static int bind_parse_no_sslv3(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_no_tls_tickets	./src/ssl_sock.c	/^static int bind_parse_no_tls_tickets(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_no_tlsv10	./src/ssl_sock.c	/^static int bind_parse_no_tlsv10(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_no_tlsv11	./src/ssl_sock.c	/^static int bind_parse_no_tlsv11(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_no_tlsv12	./src/ssl_sock.c	/^static int bind_parse_no_tlsv12(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_npn	./src/ssl_sock.c	/^static int bind_parse_npn(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_process	./src/listener.c	/^static int bind_parse_process(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_ssl	./src/ssl_sock.c	/^static int bind_parse_ssl(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_strict_sni	./src/ssl_sock.c	/^static int bind_parse_strict_sni(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_tcp_ut	./src/proto_tcp.c	/^static int bind_parse_tcp_ut(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_tfo	./src/proto_tcp.c	/^static int bind_parse_tfo(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_tls_ticket_keys	./src/ssl_sock.c	/^static int bind_parse_tls_ticket_keys(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_transparent	./src/proto_tcp.c	/^static int bind_parse_transparent(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_uid	./src/proto_uxst.c	/^static int bind_parse_uid(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_user	./src/proto_uxst.c	/^static int bind_parse_user(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_v4v6	./src/proto_tcp.c	/^static int bind_parse_v4v6(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_v6only	./src/proto_tcp.c	/^static int bind_parse_v6only(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_parse_verify	./src/ssl_sock.c	/^static int bind_parse_verify(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err)$/;"	f	file:
bind_proc	./include/types/listener.h	/^	unsigned long bind_proc;   \/* bitmask of processes allowed to use these listeners *\/$/;"	m	struct:bind_conf
bind_proc	./include/types/proxy.h	/^	unsigned long bind_proc;		\/* bitmask of processes using this proxy *\/$/;"	m	struct:proxy
bind_register_keywords	./src/listener.c	/^void bind_register_keywords(struct bind_kw_list *kwl)$/;"	f
bit	./ebtree/ebtree.h	/^	short int      bit;     \/* link's bit position. *\/$/;"	m	struct:eb_node
block_rules	./include/types/proxy.h	/^	struct list block_rules;                \/* http-request block rules to be inserted before other ones *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
block_sigchld	./src/checks.c	/^void block_sigchld(void)$/;"	f
blocked_sig	./src/signal.c	/^sigset_t blocked_sig;$/;"	v
bo	./include/types/checks.h	/^	struct buffer *bi, *bo;			\/* input and output buffers to send\/recv check *\/$/;"	m	struct:check	typeref:struct:check::
bo_contig_data	./include/common/buffer.h	/^static inline int bo_contig_data(const struct buffer *b)$/;"	f
bo_end	./include/common/buffer.h	/^static inline char *bo_end(const struct buffer *b)$/;"	f
bo_getblk	./src/channel.c	/^int bo_getblk(struct channel *chn, char *blk, int len, int offset)$/;"	f
bo_getblk_nc	./src/channel.c	/^int bo_getblk_nc(struct channel *chn, char **blk1, int *len1, char **blk2, int *len2)$/;"	f
bo_getchr	./include/proto/channel.h	/^static inline int bo_getchr(struct channel *chn)$/;"	f
bo_getline	./src/channel.c	/^int bo_getline(struct channel *chn, char *str, int len)$/;"	f
bo_getline_nc	./src/channel.c	/^int bo_getline_nc(struct channel *chn,$/;"	f
bo_inject	./src/channel.c	/^int bo_inject(struct channel *chn, const char *msg, int len)$/;"	f
bo_ptr	./include/common/buffer.h	/^static inline char *bo_ptr(const struct buffer *b)$/;"	f
bo_putblk	./include/common/buffer.h	/^static inline int bo_putblk(struct buffer *b, const char *blk, int len)$/;"	f
bo_putchk	./include/common/buffer.h	/^static inline int bo_putchk(struct buffer *b, const struct chunk *chk)$/;"	f
bo_putchr	./include/common/buffer.h	/^static inline void bo_putchr(struct buffer *b, char c)$/;"	f
bo_putstr	./include/common/buffer.h	/^static inline int bo_putstr(struct buffer *b, const char *str)$/;"	f
bo_skip	./include/proto/channel.h	/^static inline void bo_skip(struct channel *chn, int len)$/;"	f
body_len	./include/types/proto_http.h	/^	unsigned long long body_len;           \/* total known length of the body, excluding encoding *\/$/;"	m	struct:http_msg
bol	./include/types/applet.h	/^			int bol;		\/* pointer to beginning of current line *\/$/;"	m	struct:appctx::__anon21::__anon24
branches	./ebtree/ebtree.h	/^	struct eb_root branches; \/* branches, must be at the beginning *\/$/;"	m	struct:eb_node	typeref:struct:eb_node::eb_root
bref	./include/common/mini-clist.h	/^struct bref {$/;"	s
bref	./include/types/applet.h	/^			struct bref bref;	\/* back-reference from the session being dumped *\/$/;"	m	struct:appctx::__anon21::__anon23	typeref:struct:appctx::__anon21::__anon23::bref
buf	./include/types/applet.h	/^			unsigned int buf;	\/* buffer being dumped, 0 = req, 1 = rep *\/$/;"	m	struct:appctx::__anon21::__anon24
buf	./include/types/channel.h	/^	struct buffer *buf;		\/* buffer attached to the channel, always present but may move *\/$/;"	m	struct:channel	typeref:struct:channel::buffer
buf	./include/types/proxy.h	/^	char buf[BUFSIZE];		\/* copy of the beginning of the message *\/$/;"	m	struct:error_snapshot
buf2ip	./src/standard.c	/^int buf2ip(const char *buf, size_t len, struct in_addr *dst)$/;"	f
buf2ip6	./src/standard.c	/^int buf2ip6(const char *buf, size_t len, struct in6_addr *dst)$/;"	f
buf_empty	./src/buffer.c	/^struct buffer buf_empty  = { .p = buf_empty.data };$/;"	v	typeref:struct:buffer
buf_limit	./include/types/global.h	/^		int buf_limit;     \/* if not null, how many total buffers may only be allocated *\/$/;"	m	struct:global::__anon72
buf_wanted	./src/buffer.c	/^struct buffer buf_wanted = { .p = buf_wanted.data };$/;"	v	typeref:struct:buffer
buffer	./include/common/buffer.h	/^struct buffer {$/;"	s
buffer_almost_full	./include/common/buffer.h	/^static inline int buffer_almost_full(const struct buffer *buf)$/;"	f
buffer_bounce_realign	./src/buffer.c	/^void buffer_bounce_realign(struct buffer *buf)$/;"	f
buffer_contig_area	./include/common/buffer.h	/^static inline int buffer_contig_area(const struct buffer *buf, const char *start, int count)$/;"	f
buffer_contig_space	./include/common/buffer.h	/^static inline int buffer_contig_space(const struct buffer *buf)$/;"	f
buffer_count	./include/common/buffer.h	/^static inline int buffer_count(const struct buffer *buf, const char *from, const char *to)$/;"	f
buffer_dump	./src/buffer.c	/^void buffer_dump(FILE *o, struct buffer *b, int from, int to)$/;"	f
buffer_empty	./include/common/buffer.h	/^static inline int buffer_empty(const struct buffer *buf)$/;"	f
buffer_flush	./include/common/buffer.h	/^static inline void buffer_flush(struct buffer *buf)$/;"	f
buffer_full	./include/common/buffer.h	/^static inline int buffer_full(const struct buffer *b, unsigned int reserve)$/;"	f
buffer_insert_line2	./src/buffer.c	/^int buffer_insert_line2(struct buffer *b, char *pos, const char *str, int len)$/;"	f
buffer_len	./include/common/buffer.h	/^static inline int buffer_len(const struct buffer *buf)$/;"	f
buffer_not_empty	./include/common/buffer.h	/^static inline int buffer_not_empty(const struct buffer *buf)$/;"	f
buffer_pending	./include/common/buffer.h	/^static inline int buffer_pending(const struct buffer *buf)$/;"	f
buffer_pointer	./include/common/buffer.h	/^static inline const char *buffer_pointer(const struct buffer *buf, const char *ptr)$/;"	f
buffer_realign	./include/common/buffer.h	/^static inline int buffer_realign(struct buffer *buf)$/;"	f
buffer_replace	./include/common/buffer.h	/^static inline int buffer_replace(struct buffer *b, char *pos, char *end, const char *str)$/;"	f
buffer_replace2	./src/buffer.c	/^int buffer_replace2(struct buffer *b, char *pos, char *end, const char *str, int len)$/;"	f
buffer_slow_realign	./src/buffer.c	/^void buffer_slow_realign(struct buffer *buf)$/;"	f
buffer_total_space	./include/common/buffer.h	/^static inline int buffer_total_space(const struct buffer *buf)$/;"	f
buffer_wait	./include/types/stream.h	/^	struct list buffer_wait;        \/* position in the list of streams waiting for a buffer *\/$/;"	m	struct:stream	typeref:struct:stream::list
buffer_work_area	./include/common/buffer.h	/^static inline int buffer_work_area(const struct buffer *buf, const char *end)$/;"	f
buffer_wq	./src/stream.c	/^struct list buffer_wq = LIST_HEAD_INIT(buffer_wq);$/;"	v	typeref:struct:list
buffer_wrap_add	./include/common/buffer.h	/^static inline char *buffer_wrap_add(const struct buffer *buf, char *ptr)$/;"	f
buffer_wrap_sub	./include/common/buffer.h	/^static inline char *buffer_wrap_sub(const struct buffer *buf, char *ptr)$/;"	f
bufsize	./include/types/global.h	/^		int bufsize;       \/* buffer size in bytes, defaults to BUFSIZE *\/$/;"	m	struct:global::__anon72
build_acl_cond	./src/acl.c	/^struct acl_cond *build_acl_cond(const char *file, int line, struct proxy *px, const char **args, char **err)$/;"	f
build_logline	./src/log.c	/^int build_logline(struct stream *s, char *dst, size_t maxsize, struct list *list_format)$/;"	f
by_bind	./include/types/listener.h	/^	struct list by_bind;            \/* chaining in bind_conf's list of listeners *\/$/;"	m	struct:listener	typeref:struct:listener::list
by_fe	./include/types/listener.h	/^	struct list by_fe;              \/* chaining in frontend's list of listeners *\/$/;"	m	struct:listener	typeref:struct:listener::list
by_fe	./include/types/listener.h	/^	struct list by_fe;         \/* next binding for the same frontend, or NULL *\/$/;"	m	struct:bind_conf	typeref:struct:bind_conf::list
by_name	./include/types/proxy.h	/^		struct ebpt_node by_name;       \/* proxies are stored sorted by name here *\/$/;"	m	struct:proxy::__anon109	typeref:struct:proxy::__anon109::ebpt_node
by_srv	./include/types/stream.h	/^	struct list by_srv;             \/* position in server stream list *\/$/;"	m	struct:stream	typeref:struct:stream::list
bytes_in	./include/types/counters.h	/^	long long bytes_in;			\/* number of bytes transferred from the client to the server *\/$/;"	m	struct:licounters
bytes_in	./include/types/counters.h	/^	long long bytes_in;			\/* number of bytes transferred from the client to the server *\/$/;"	m	struct:srvcounters
bytes_in	./include/types/counters.h	/^	long long bytes_in;                     \/* number of bytes transferred from the client to the server *\/$/;"	m	struct:pxcounters
bytes_in	./include/types/stream.h	/^	long long bytes_in;             \/* number of bytes transferred from the client to the server *\/$/;"	m	struct:strm_logs
bytes_in_cnt	./include/types/stick_table.h	/^	unsigned long long bytes_in_cnt;$/;"	m	union:stktable_data
bytes_in_rate	./include/types/stick_table.h	/^	struct freq_ctr_period bytes_in_rate;$/;"	m	union:stktable_data	typeref:struct:stktable_data::freq_ctr_period
bytes_out	./include/types/counters.h	/^	long long bytes_out;			\/* number of bytes transferred from the server to the client *\/$/;"	m	struct:licounters
bytes_out	./include/types/counters.h	/^	long long bytes_out;			\/* number of bytes transferred from the server to the client *\/$/;"	m	struct:srvcounters
bytes_out	./include/types/counters.h	/^	long long bytes_out;                    \/* number of bytes transferred from the server to the client *\/$/;"	m	struct:pxcounters
bytes_out	./include/types/stream.h	/^	long long bytes_out;            \/* number of bytes transferred from the server to the client *\/$/;"	m	struct:strm_logs
bytes_out_cnt	./include/types/stick_table.h	/^	unsigned long long bytes_out_cnt;$/;"	m	union:stktable_data
bytes_out_rate	./include/types/stick_table.h	/^	struct freq_ctr_period bytes_out_rate;$/;"	m	union:stktable_data	typeref:struct:stktable_data::freq_ctr_period
c	./include/types/proto_http.h	/^			int c, c_l;            \/* CODE, length *\/$/;"	m	struct:http_msg::__anon99::__anon101
c_addr2bin	./src/sample.c	/^static int c_addr2bin(struct sample *smp)$/;"	f	file:
c_bin2str	./src/sample.c	/^static int c_bin2str(struct sample *smp)$/;"	f	file:
c_int2bin	./src/sample.c	/^static int c_int2bin(struct sample *smp)$/;"	f	file:
c_int2ip	./src/sample.c	/^static int c_int2ip(struct sample *smp)$/;"	f	file:
c_int2ipv6	./src/sample.c	/^static int c_int2ipv6(struct sample *smp)$/;"	f	file:
c_int2str	./src/sample.c	/^static int c_int2str(struct sample *smp)$/;"	f	file:
c_ip2int	./src/sample.c	/^static int c_ip2int(struct sample *smp)$/;"	f	file:
c_ip2ipv6	./src/sample.c	/^static int c_ip2ipv6(struct sample *smp)$/;"	f	file:
c_ip2str	./src/sample.c	/^static int c_ip2str(struct sample *smp)$/;"	f	file:
c_ipv62ip	./src/sample.c	/^static int c_ipv62ip(struct sample *smp)$/;"	f	file:
c_ipv62str	./src/sample.c	/^static int c_ipv62str(struct sample *smp)$/;"	f	file:
c_l	./include/types/proto_http.h	/^			int c, c_l;            \/* CODE, length *\/$/;"	m	struct:http_msg::__anon99::__anon101
c_meth2str	./src/sample.c	/^static int c_meth2str(struct sample *smp)$/;"	f	file:
c_none	./src/sample.c	/^int c_none(struct sample *smp)$/;"	f
c_str2addr	./src/sample.c	/^static int c_str2addr(struct sample *smp)$/;"	f	file:
c_str2int	./src/sample.c	/^static int c_str2int(struct sample *smp)$/;"	f	file:
c_str2ip	./src/sample.c	/^static int c_str2ip(struct sample *smp)$/;"	f	file:
c_str2ipv6	./src/sample.c	/^static int c_str2ipv6(struct sample *smp)$/;"	f	file:
c_str2meth	./src/sample.c	/^static int c_str2meth(struct sample *smp)$/;"	f	file:
c_time	./include/types/counters.h	/^	unsigned int q_time, c_time, d_time, t_time; \/* sums of conn_time, queue_time, data_time, total_time *\/$/;"	m	struct:pxcounters
c_time	./include/types/counters.h	/^	unsigned int q_time, c_time, d_time, t_time; \/* sums of conn_time, queue_time, data_time, total_time *\/$/;"	m	struct:srvcounters
ca_base	./include/types/global.h	/^	char *ca_base;              \/* base directory path for CAs and CRLs *\/$/;"	m	struct:global
ca_file	./include/types/listener.h	/^	char *ca_file;             \/* CAfile to use on verify *\/$/;"	m	struct:bind_conf
ca_file	./include/types/server.h	/^		char *ca_file;			\/* CAfile to use on verify *\/$/;"	m	struct:server::__anon122
ca_ignerr	./include/types/listener.h	/^	unsigned long long ca_ignerr;  \/* ignored verify errors in handshake if depth > 0 *\/$/;"	m	struct:bind_conf
ca_sign_cert	./include/types/listener.h	/^	X509     *ca_sign_cert;    \/* CA certificate referenced by ca_file *\/$/;"	m	struct:bind_conf
ca_sign_file	./include/types/listener.h	/^	char *ca_sign_file;        \/* CAFile used to generate and sign server certificates *\/$/;"	m	struct:bind_conf
ca_sign_pass	./include/types/listener.h	/^	char *ca_sign_pass;        \/* CAKey passphrase *\/$/;"	m	struct:bind_conf
ca_sign_pkey	./include/types/listener.h	/^	EVP_PKEY *ca_sign_pkey;    \/* CA private key referenced by ca_key *\/$/;"	m	struct:bind_conf
cache	./include/types/fd.h	/^	unsigned int  cache;                 \/* position+1 in the FD cache. 0=not in cache. *\/$/;"	m	struct:fdtab
cache_idx	./include/types/acl.h	/^	int cache_idx;              \/* ACL index in cache *\/$/;"	m	struct:acl
cache_size	./include/import/lru.h	/^	int cache_size;$/;"	m	struct:lru64_head
cache_size	./include/types/global.h	/^		int cache_size;$/;"	m	struct:global::__anon76
cache_usage	./include/import/lru.h	/^	int cache_usage;$/;"	m	struct:lru64_head
caddr_clr_flags	./include/common/standard.h	/^static inline unsigned long caddr_clr_flags(unsigned long caddr, unsigned int data)$/;"	f
caddr_from_ptr	./include/common/standard.h	/^static inline unsigned long caddr_from_ptr(void *ptr, unsigned int data)$/;"	f
caddr_set_flags	./include/common/standard.h	/^static inline unsigned long caddr_set_flags(unsigned long caddr, unsigned int data)$/;"	f
caddr_to_data	./include/common/standard.h	/^static inline unsigned int caddr_to_data(unsigned long caddr)$/;"	f
caddr_to_ptr	./include/common/standard.h	/^static inline void *caddr_to_ptr(unsigned long caddr)$/;"	f
calls	./include/types/task.h	/^	unsigned int calls;		\/* number of times ->process() was called *\/$/;"	m	struct:task
cap	./include/types/action.h	/^		} cap;$/;"	m	union:act_rule::__anon9	typeref:struct:act_rule::__anon9::__anon14
cap	./include/types/proxy.h	/^	char cap;                               \/* supported capabilities (PR_CAP_*) *\/$/;"	m	struct:proxy
cap	./src/cfgparse.c	/^	unsigned int cap;$/;"	m	struct:cfg_opt	file:
cap_hdr	./include/types/capture.h	/^struct cap_hdr {$/;"	s
capid	./include/types/action.h	/^		} capid;$/;"	m	union:act_rule::__anon9	typeref:struct:act_rule::__anon9::__anon16
capture_headers	./src/proto_http.c	/^void capture_headers(char *som, struct hdr_idx *idx,$/;"	f
capture_len	./include/types/proxy.h	/^	int  capture_len;			\/* length of the string to be captured *\/$/;"	m	struct:proxy
capture_name	./include/types/proxy.h	/^	char *capture_name;			\/* beginning of the name of the cookie to capture *\/$/;"	m	struct:proxy
capture_namelen	./include/types/proxy.h	/^	int  capture_namelen;			\/* length of the cookie name to match *\/$/;"	m	struct:proxy
caught_signal	./src/haproxy-systemd-wrapper.c	/^static volatile sig_atomic_t caught_signal;$/;"	v	file:
cd	./include/types/dns.h	/^	unsigned char	cd :1;		\/* checking disabled *\/$/;"	m	struct:dns_header
cert_ocsp_tree	./src/ssl_sock.c	/^static struct eb_root cert_ocsp_tree = EB_ROOT_UNIQUE;$/;"	v	typeref:struct:eb_root	file:
certificate_ocsp	./src/ssl_sock.c	/^struct certificate_ocsp {$/;"	s	file:
cfg_cfgfiles	./src/haproxy.c	/^static struct list cfg_cfgfiles = LIST_HEAD_INIT(cfg_cfgfiles);$/;"	v	typeref:struct:list	file:
cfg_keyword	./include/common/cfgparse.h	/^struct cfg_keyword {$/;"	s
cfg_keywords	./src/cfgparse.c	/^static struct cfg_kw_list cfg_keywords = {$/;"	v	typeref:struct:cfg_kw_list	file:
cfg_kw_list	./include/common/cfgparse.h	/^struct cfg_kw_list {$/;"	s
cfg_kws	./src/dumpstats.c	/^static struct cfg_kw_list cfg_kws = {ILH, {$/;"	v	typeref:struct:cfg_kw_list	file:
cfg_kws	./src/hlua.c	/^static struct cfg_kw_list cfg_kws = {{ },{$/;"	v	typeref:struct:cfg_kw_list	file:
cfg_kws	./src/proto_tcp.c	/^static struct cfg_kw_list cfg_kws = {ILH, {$/;"	v	typeref:struct:cfg_kw_list	file:
cfg_kws	./src/proxy.c	/^static struct cfg_kw_list cfg_kws = {ILH, {$/;"	v	typeref:struct:cfg_kw_list	file:
cfg_kws	./src/ssl_sock.c	/^static struct cfg_kw_list cfg_kws = {ILH, {$/;"	v	typeref:struct:cfg_kw_list	file:
cfg_kws	./src/vars.c	/^static struct cfg_kw_list cfg_kws = {{ },{$/;"	v	typeref:struct:cfg_kw_list	file:
cfg_maxconn	./src/cfgparse.c	/^int cfg_maxconn = 0;			\/* # of simultaneous connections, (-n) *\/$/;"	v
cfg_maxpconn	./src/cfgparse.c	/^int cfg_maxpconn = DEFAULT_MAXCONN;	\/* # of simultaneous connections per proxy (-N) *\/$/;"	v
cfg_name	./include/types/compression.h	/^	char *cfg_name;  \/* config name *\/$/;"	m	struct:comp_algo
cfg_name_len	./include/types/compression.h	/^	int cfg_name_len;$/;"	m	struct:comp_algo
cfg_opt	./src/cfgparse.c	/^struct cfg_opt {$/;"	s	file:
cfg_opts	./src/cfgparse.c	/^static const struct cfg_opt cfg_opts[] =$/;"	v	typeref:struct:cfg_opt	file:
cfg_opts2	./src/cfgparse.c	/^static const struct cfg_opt cfg_opts2[] =$/;"	v	typeref:struct:cfg_opt	file:
cfg_parse_global	./src/cfgparse.c	/^int cfg_parse_global(const char *file, int linenum, char **args, int kwm)$/;"	f
cfg_parse_listen	./src/cfgparse.c	/^int cfg_parse_listen(const char *file, int linenum, char **args, int kwm)$/;"	f
cfg_parse_mailers	./src/cfgparse.c	/^int cfg_parse_mailers(const char *file, int linenum, char **args, int kwm)$/;"	f
cfg_parse_netns	./src/cfgparse.c	/^cfg_parse_netns(const char *file, int linenum, char **args, int kwm)$/;"	f
cfg_parse_peers	./src/cfgparse.c	/^int cfg_parse_peers(const char *file, int linenum, char **args, int kwm)$/;"	f
cfg_parse_resolvers	./src/cfgparse.c	/^int cfg_parse_resolvers(const char *file, int linenum, char **args, int kwm)$/;"	f
cfg_parse_users	./src/cfgparse.c	/^cfg_parse_users(const char *file, int linenum, char **args, int kwm)$/;"	f
cfg_register_keywords	./src/cfgparse.c	/^void cfg_register_keywords(struct cfg_kw_list *kwl)$/;"	f
cfg_register_section	./src/cfgparse.c	/^int cfg_register_section(char *section_name,$/;"	f
cfg_section	./src/cfgparse.c	/^struct cfg_section {$/;"	s	file:
cfg_unregister_keywords	./src/cfgparse.c	/^void cfg_unregister_keywords(struct cfg_kw_list *kwl)$/;"	f
cfg_unregister_sections	./src/cfgparse.c	/^void cfg_unregister_sections(void)$/;"	f
chain_regex	./src/regex.c	/^const char *chain_regex(struct hdr_exp **head, struct my_regex *preg,$/;"	f
channel	./include/types/channel.h	/^struct channel {$/;"	s
channel_abort	./include/proto/channel.h	/^static inline void channel_abort(struct channel *chn)$/;"	f
channel_auto_close	./include/proto/channel.h	/^static inline void channel_auto_close(struct channel *chn)$/;"	f
channel_auto_connect	./include/proto/channel.h	/^static inline void channel_auto_connect(struct channel *chn)$/;"	f
channel_auto_read	./include/proto/channel.h	/^static inline void channel_auto_read(struct channel *chn)$/;"	f
channel_check_timeouts	./include/proto/channel.h	/^static inline void channel_check_timeouts(struct channel *chn)$/;"	f
channel_dont_close	./include/proto/channel.h	/^static inline void channel_dont_close(struct channel *chn)$/;"	f
channel_dont_connect	./include/proto/channel.h	/^static inline void channel_dont_connect(struct channel *chn)$/;"	f
channel_dont_read	./include/proto/channel.h	/^static inline void channel_dont_read(struct channel *chn)$/;"	f
channel_erase	./include/proto/channel.h	/^static inline void channel_erase(struct channel *chn)$/;"	f
channel_forward	./include/proto/channel.h	/^static inline unsigned long long channel_forward(struct channel *chn, unsigned long long bytes)$/;"	f
channel_in_transit	./include/proto/channel.h	/^static inline int channel_in_transit(const struct channel *chn)$/;"	f
channel_init	./include/proto/channel.h	/^static inline void channel_init(struct channel *chn)$/;"	f
channel_input_closed	./include/proto/channel.h	/^static inline int channel_input_closed(struct channel *chn)$/;"	f
channel_is_empty	./include/proto/channel.h	/^static inline unsigned int channel_is_empty(struct channel *c)$/;"	f
channel_is_rewritable	./include/proto/channel.h	/^static inline int channel_is_rewritable(const struct channel *chn)$/;"	f
channel_may_recv	./include/proto/channel.h	/^static inline int channel_may_recv(const struct channel *chn)$/;"	f
channel_may_send	./include/proto/channel.h	/^static inline int channel_may_send(const struct channel *chn)$/;"	f
channel_output_closed	./include/proto/channel.h	/^static inline int channel_output_closed(struct channel *chn)$/;"	f
channel_recv_limit	./include/proto/channel.h	/^static inline int channel_recv_limit(const struct channel *chn)$/;"	f
channel_recv_max	./include/proto/channel.h	/^static inline int channel_recv_max(const struct channel *chn)$/;"	f
channel_reserved	./include/proto/channel.h	/^static inline int channel_reserved(const struct channel *chn)$/;"	f
channel_shutr_now	./include/proto/channel.h	/^static inline void channel_shutr_now(struct channel *chn)$/;"	f
channel_shutw_now	./include/proto/channel.h	/^static inline void channel_shutw_now(struct channel *chn)$/;"	f
channel_truncate	./include/proto/channel.h	/^static inline void channel_truncate(struct channel *chn)$/;"	f
chash	./include/types/backend.h	/^	struct lb_chash chash;$/;"	m	struct:lbprm	typeref:struct:lbprm::lb_chash
chash_dequeue_srv	./src/lb_chash.c	/^static inline void chash_dequeue_srv(struct server *s)$/;"	f	file:
chash_get_next_server	./src/lb_chash.c	/^struct server *chash_get_next_server(struct proxy *p, struct server *srvtoavoid)$/;"	f
chash_get_server_hash	./src/lb_chash.c	/^struct server *chash_get_server_hash(struct proxy *p, unsigned int hash)$/;"	f
chash_init_server_tree	./src/lb_chash.c	/^void chash_init_server_tree(struct proxy *p)$/;"	f
chash_queue_dequeue_srv	./src/lb_chash.c	/^static inline void chash_queue_dequeue_srv(struct server *s)$/;"	f	file:
chash_set_server_status_down	./src/lb_chash.c	/^static void chash_set_server_status_down(struct server *srv)$/;"	f	file:
chash_set_server_status_up	./src/lb_chash.c	/^static void chash_set_server_status_up(struct server *srv)$/;"	f	file:
chash_skip_node	./src/lb_chash.c	/^static inline struct eb32_node *chash_skip_node(struct eb_root *root, struct eb32_node *node)$/;"	f	file:
chash_update_server_weight	./src/lb_chash.c	/^static void chash_update_server_weight(struct server *srv)$/;"	f	file:
check	./include/types/checks.h	/^struct check {$/;"	s
check	./include/types/proxy.h	/^		int check;                      \/* maximum time for complete check *\/$/;"	m	struct:proxy::__anon108
check	./include/types/proxy.h	/^	struct check check;		\/* Email alerts are implemented using existing check$/;"	m	struct:email_alertq	typeref:struct:email_alertq::check
check	./include/types/server.h	/^	struct check check;                     \/* health-check specific configuration *\/$/;"	m	struct:server	typeref:struct:server::check
check_args	./src/hlua.c	/^__LJMP static inline void check_args(lua_State *L, int nb, char *fcn)$/;"	f	file:
check_bits	./ebtree/ebtree.h	/^static forceinline int check_bits(const unsigned char *a,$/;"	f
check_command	./include/types/proxy.h	/^	char *check_command;			\/* Command to use for external agent checks *\/$/;"	m	struct:proxy
check_config_validity	./src/cfgparse.c	/^int check_config_validity()$/;"	f
check_conn_cb	./src/checks.c	/^struct data_cb check_conn_cb = {$/;"	v	typeref:struct:data_cb
check_group	./src/auth.c	/^int check_group(struct userlist *ul, char *name)$/;"	f
check_init_uri_auth	./src/uri_auth.c	/^struct uri_auth *check_init_uri_auth(struct uri_auth **root, char *default_uri)$/;"	f
check_len	./include/types/proxy.h	/^	int check_len;				\/* Length of the HTTP or SSL3 request *\/$/;"	m	struct:proxy
check_lua_lib	./Makefile	/^check_lua_lib = $(shell echo "int main(){}" | $(CC) -o \/dev\/null -x c - $(2) -l$(1) 2>\/dev\/null && echo $(1))$/;"	m
check_notify_failure	./src/checks.c	/^static void check_notify_failure(struct check *check)$/;"	f	file:
check_notify_stopping	./src/checks.c	/^static void check_notify_stopping(struct check *check)$/;"	f	file:
check_notify_success	./src/checks.c	/^static void check_notify_success(struct check *check)$/;"	f	file:
check_operator	./src/sample.c	/^static int check_operator(struct arg *args, struct sample_conv *conv,$/;"	f	file:
check_path	./include/types/proxy.h	/^	char *check_path;			\/* PATH environment to use for external agent checks *\/$/;"	m	struct:proxy
check_reason_string	./src/checks.c	/^static const char *check_reason_string(struct check *check)$/;"	f	file:
check_replace_string	./src/regex.c	/^const char *check_replace_string(const char *str)$/;"	f
check_req	./include/types/proxy.h	/^	char *check_req;			\/* HTTP or SSL request to use for PR_O_HTTP_CHK|PR_O_SSL3_CHK *\/$/;"	m	struct:proxy
check_response_for_cacheability	./src/proto_http.c	/^void check_response_for_cacheability(struct stream *s, struct channel *rtr)$/;"	f
check_status	./include/types/checks.h	/^struct check_status {$/;"	s
check_statuses	./src/checks.c	/^static const struct check_status check_statuses[HCHK_STATUS_SIZE] = {$/;"	v	typeref:struct:check_status	file:
check_user	./src/auth.c	/^check_user(struct userlist *ul, const char *user, const char *pass)$/;"	f
checks	./src/cfgparse.c	/^	unsigned int checks;$/;"	m	struct:cfg_opt	file:
chk_rcv	./include/types/stream_interface.h	/^	void (*chk_rcv)(struct stream_interface *); \/* chk_rcv function *\/$/;"	m	struct:si_ops
chk_report_conn_err	./src/checks.c	/^static void chk_report_conn_err(struct connection *conn, int errno_bck, int expired)$/;"	f	file:
chk_result	./include/types/checks.h	/^enum chk_result {$/;"	g
chk_snd	./include/types/stream_interface.h	/^	void (*chk_snd)(struct stream_interface *); \/* chk_snd function *\/$/;"	m	struct:si_ops
chksize	./include/types/global.h	/^		int chksize;       \/* check buffer size in bytes, defaults to BUFSIZE *\/$/;"	m	struct:global::__anon72
chn	./include/types/proto_http.h	/^	struct channel *chn;                   \/* pointer to the channel transporting the message *\/$/;"	m	struct:http_msg	typeref:struct:http_msg::channel
chn_cons	./include/proto/channel.h	/^static inline struct stream_interface *chn_cons(const struct channel *chn)$/;"	f
chn_prod	./include/proto/channel.h	/^static inline struct stream_interface *chn_prod(const struct channel *chn)$/;"	f
chn_strm	./include/proto/channel.h	/^static inline struct stream *chn_strm(const struct channel *chn)$/;"	f
chroot	./include/types/global.h	/^	char *chroot;$/;"	m	struct:global
chunk	./include/common/chunk.h	/^struct chunk {$/;"	s
chunk	./include/types/applet.h	/^			struct chunk chunk;$/;"	m	struct:appctx::__anon21::__anon28	typeref:struct:appctx::__anon21::__anon28::chunk
chunk_appendf	./src/chunk.c	/^int chunk_appendf(struct chunk *chk, const char *fmt, ...)$/;"	f
chunk_asciiencode	./src/chunk.c	/^int chunk_asciiencode(struct chunk *dst, struct chunk *src, char qc)$/;"	f
chunk_destroy	./include/common/chunk.h	/^static inline void chunk_destroy(struct chunk *chk)$/;"	f
chunk_drop	./include/common/chunk.h	/^static inline void chunk_drop(struct chunk *chk)$/;"	f
chunk_dup	./include/common/chunk.h	/^static inline char *chunk_dup(struct chunk *dst, const struct chunk *src)$/;"	f
chunk_htmlencode	./src/chunk.c	/^int chunk_htmlencode(struct chunk *dst, struct chunk *src)$/;"	f
chunk_init	./include/common/chunk.h	/^static inline void chunk_init(struct chunk *chk, char *str, size_t size)$/;"	f
chunk_initlen	./include/common/chunk.h	/^static inline int chunk_initlen(struct chunk *chk, char *str, size_t size, int len)$/;"	f
chunk_initstr	./include/common/chunk.h	/^static inline void chunk_initstr(struct chunk *chk, char *str)$/;"	f
chunk_len	./include/types/proto_http.h	/^	unsigned long long chunk_len;          \/* cache for last chunk size or content-length header value *\/$/;"	m	struct:http_msg
chunk_printf	./src/chunk.c	/^int chunk_printf(struct chunk *chk, const char *fmt, ...)$/;"	f
chunk_reset	./include/common/chunk.h	/^static inline void chunk_reset(struct chunk *chk)$/;"	f
chunk_strcasecmp	./src/chunk.c	/^int chunk_strcasecmp(const struct chunk *chk, const char *str)$/;"	f
chunk_strcmp	./src/chunk.c	/^int chunk_strcmp(const struct chunk *chk, const char *str)$/;"	f
chunk_strcpy	./include/common/chunk.h	/^static inline int chunk_strcpy(struct chunk *chk, const char *str)$/;"	f
cidr2dotted	./src/standard.c	/^int cidr2dotted(int cidr, struct in_addr *mask) {$/;"	f
ciphers	./include/types/listener.h	/^	char *ciphers;             \/* cipher suite to use if non-null *\/$/;"	m	struct:bind_conf
ciphers	./include/types/server.h	/^		char *ciphers;			\/* cipher suite to use if non-null *\/$/;"	m	struct:server::__anon122
ck_opts	./include/types/proxy.h	/^	unsigned int ck_opts;			\/* PR_CK_* (cookie options) *\/$/;"	m	struct:proxy
cklen	./include/types/server.h	/^	int cklen;				\/* the len of the cookie, to speed up checks *\/$/;"	m	struct:server
class_applet_http_ref	./src/hlua.c	/^static int class_applet_http_ref;$/;"	v	file:
class_applet_tcp_ref	./src/hlua.c	/^static int class_applet_tcp_ref;$/;"	v	file:
class_channel_ref	./src/hlua.c	/^static int class_channel_ref;$/;"	v	file:
class_converters_ref	./src/hlua.c	/^static int class_converters_ref;$/;"	v	file:
class_fetches_ref	./src/hlua.c	/^static int class_fetches_ref;$/;"	v	file:
class_http_ref	./src/hlua.c	/^static int class_http_ref;$/;"	v	file:
class_map_ref	./src/hlua.c	/^static int class_map_ref;$/;"	v	file:
class_socket_ref	./src/hlua.c	/^static int class_socket_ref;$/;"	v	file:
class_txn_ref	./src/hlua.c	/^static int class_txn_ref;$/;"	v	file:
clear_addr	./include/common/standard.h	/^static inline void clear_addr(struct sockaddr_storage *addr)$/;"	f
clf_http_log_format	./src/log.c	/^char clf_http_log_format[] = "%{+Q}o %{-Q}ci - - [%T] %r %ST %B \\"\\" \\"\\" %cp %ms %ft %b %s %Tq %Tw %Tc %Tr %Tt %tsc %ac %fc %bc %sc %rc %sq %bq %CC %CS %hrl %hsl";$/;"	v
cli	./include/types/applet.h	/^		} cli;$/;"	m	union:appctx::__anon21	typeref:struct:appctx::__anon21::__anon26
cli_aborts	./include/types/counters.h	/^	long long cli_aborts, srv_aborts;	\/* aborted responses during DATA phase due to client or server *\/$/;"	m	struct:srvcounters
cli_aborts	./include/types/counters.h	/^	long long cli_aborts;                   \/* aborted responses during DATA phase caused by the client *\/$/;"	m	struct:pxcounters
cli_applet	./src/dumpstats.c	/^static struct applet cli_applet = {$/;"	v	typeref:struct:applet	file:
cli_applet	./src/dumpstats.c	/^static struct applet cli_applet;$/;"	v	typeref:struct:applet	file:
cli_cookie	./include/types/proto_http.h	/^	char *cli_cookie;               \/* cookie presented by the client, in capture mode *\/$/;"	m	struct:http_txn
cli_io_handler	./src/dumpstats.c	/^static void cli_io_handler(struct appctx *appctx)$/;"	f	file:
cli_release_handler	./src/dumpstats.c	/^static void cli_release_handler(struct appctx *appctx)$/;"	f	file:
client	./include/types/connection.h	/^	uint8_t client;$/;"	m	struct:tlv_ssl
client	./include/types/proxy.h	/^		int client;                     \/* client I\/O timeout (in ticks) *\/$/;"	m	struct:proxy::__anon108
client_crt	./include/types/server.h	/^		char *client_crt;		\/* client certificate to send *\/$/;"	m	struct:server::__anon122
client_rcvbuf	./include/types/global.h	/^		int client_rcvbuf; \/* set client rcvbuf to this value if not null *\/$/;"	m	struct:global::__anon72
client_sndbuf	./include/types/global.h	/^		int client_sndbuf; \/* set client sndbuf to this value if not null *\/$/;"	m	struct:global::__anon72
clientfin	./include/types/proxy.h	/^		int clientfin;                  \/* timeout to apply to client half-closed connections *\/$/;"	m	struct:proxy::__anon108
clo	./include/types/fd.h	/^	void REGPRM1   (*clo)(const int fd);                 \/* mark <fd> as closed *\/$/;"	m	struct:poller
cloned	./include/types/fd.h	/^	unsigned char cloned:1;              \/* 1 if a cloned socket, requires EPOLL_CTL_DEL on close *\/$/;"	m	struct:fdtab
close	./include/types/connection.h	/^	void (*close)(struct connection *);         \/* close the transport layer *\/$/;"	m	struct:xprt_ops
cmp_bits	./ebtree/ebtree.h	/^static forceinline int cmp_bits(const unsigned char *a, const unsigned char *b, unsigned int pos)$/;"	f
cmpxchg	./src/shctx.c	/^static inline unsigned int cmpxchg(unsigned int *ptr, unsigned int old, unsigned int new)$/;"	f	file:
cname	./include/types/dns.h	/^		long int cname;		\/* - CNAME response requiring new resolution *\/$/;"	m	struct:dns_nameserver::__anon65
cname_error	./include/types/dns.h	/^		long int cname_error;	\/* - error when resolving CNAMEs *\/$/;"	m	struct:dns_nameserver::__anon65
code	./include/types/action.h	/^			unsigned int code;     \/* HTTP status code *\/$/;"	m	struct:act_rule::__anon9::__anon15
code	./include/types/checks.h	/^	short status, code;			\/* check result, check code *\/$/;"	m	struct:check
code	./include/types/proxy.h	/^	int code;$/;"	m	struct:redirect_rule
com	./include/types/hlua.h	/^	struct list com; \/* The list head of the signals attached to this task. *\/$/;"	m	struct:hlua	typeref:struct:hlua::list
com	./include/types/hlua.h	/^	struct list com; \/* list of signal to wake at the end of sleep. *\/$/;"	m	struct:hlua_sleep	typeref:struct:hlua_sleep::list
comment	./include/types/checks.h	/^	char *comment;				\/* comment to be used in the logs and on the stats socket *\/$/;"	m	struct:tcpcheck_rule
commitupdate	./include/types/stick_table.h	/^	unsigned int commitupdate;\/* used to identify the latest local updates$/;"	m	struct:stktable
comp	./include/types/compression.h	/^struct comp {$/;"	s
comp	./include/types/proxy.h	/^	struct comp *comp;			\/* http compression *\/$/;"	m	struct:proxy	typeref:struct:proxy::comp
comp_algo	./include/types/compression.h	/^struct comp_algo {$/;"	s
comp_algo	./include/types/stream.h	/^	struct comp_algo *comp_algo;            \/* HTTP compression algorithm if not NULL *\/$/;"	m	struct:stream	typeref:struct:stream::comp_algo
comp_algos	./src/compression.c	/^const struct comp_algo comp_algos[] =$/;"	v	typeref:struct:comp_algo
comp_append_algo	./src/compression.c	/^int comp_append_algo(struct comp *comp, const char *algo)$/;"	f
comp_append_type	./src/compression.c	/^int comp_append_type(struct comp *comp, const char *type)$/;"	f
comp_bps_in	./include/types/global.h	/^	struct freq_ctr comp_bps_in;	\/* bytes per second, before http compression *\/$/;"	m	struct:global	typeref:struct:global::freq_ctr
comp_bps_out	./include/types/global.h	/^	struct freq_ctr comp_bps_out;	\/* bytes per second, after http compression *\/$/;"	m	struct:global	typeref:struct:global::freq_ctr
comp_byp	./include/types/counters.h	/^	long long comp_byp;                     \/* input bytes that bypassed the compressor (cpu\/ram\/bw limitation) *\/$/;"	m	struct:pxcounters
comp_ctx	./include/types/compression.h	/^struct comp_ctx {$/;"	s
comp_ctx	./include/types/stream.h	/^	struct comp_ctx *comp_ctx;              \/* HTTP compression context *\/$/;"	m	struct:stream	typeref:struct:stream::comp_ctx
comp_in	./include/types/counters.h	/^	long long comp_in;                      \/* input bytes fed to the compressor *\/$/;"	m	struct:pxcounters
comp_maxlevel	./include/types/global.h	/^		int comp_maxlevel;    \/* max HTTP compression level *\/$/;"	m	struct:global::__anon72
comp_out	./include/types/counters.h	/^	long long comp_out;                     \/* output bytes emitted by the compressor *\/$/;"	m	struct:pxcounters
comp_rate_lim	./include/types/global.h	/^	int comp_rate_lim;           \/* HTTP compression rate limit *\/$/;"	m	struct:global
comp_rsp	./include/types/counters.h	/^			long long comp_rsp;     \/* number of compressed responses *\/$/;"	m	struct:pxcounters::__anon57::__anon58
comp_type	./include/types/compression.h	/^struct comp_type {$/;"	s
compress_min_idle	./src/compression.c	/^unsigned int compress_min_idle = 0;$/;"	v
cond	./include/common/mini-clist.h	/^	void *cond;$/;"	m	struct:cond_wordlist
cond	./include/common/regex.h	/^    void *cond;				\/* a possible condition or NULL *\/$/;"	m	struct:hdr_exp
cond	./include/common/uri_auth.h	/^	struct acl_cond *cond;	\/* acl condition to meet *\/$/;"	m	struct:dbmanage_admin_rule	typeref:struct:dbmanage_admin_rule::acl_cond
cond	./include/common/uri_auth.h	/^	struct acl_cond *cond;	\/* acl condition to meet *\/$/;"	m	struct:stats_admin_rule	typeref:struct:stats_admin_rule::acl_cond
cond	./include/types/action.h	/^	struct acl_cond *cond;                 \/* acl condition to meet *\/$/;"	m	struct:act_rule	typeref:struct:act_rule::acl_cond
cond	./include/types/proxy.h	/^	struct acl_cond *cond;			\/* acl condition to meet *\/$/;"	m	struct:persist_rule	typeref:struct:persist_rule::acl_cond
cond	./include/types/proxy.h	/^	struct acl_cond *cond;			\/* acl condition to meet *\/$/;"	m	struct:server_rule	typeref:struct:server_rule::acl_cond
cond	./include/types/proxy.h	/^	struct acl_cond *cond;			\/* acl condition to meet *\/$/;"	m	struct:switching_rule	typeref:struct:switching_rule::acl_cond
cond	./include/types/proxy.h	/^	struct acl_cond *cond;                  \/* acl condition to meet *\/$/;"	m	struct:redirect_rule	typeref:struct:redirect_rule::acl_cond
cond	./include/types/proxy.h	/^	struct acl_cond *cond;                  \/* acl condition to meet *\/$/;"	m	struct:sticking_rule	typeref:struct:sticking_rule::acl_cond
cond_wordlist	./include/common/mini-clist.h	/^struct cond_wordlist {$/;"	s
conf	./include/types/dns.h	/^	} conf;				\/* config information *\/$/;"	m	struct:dns_nameserver	typeref:struct:dns_nameserver::__anon64
conf	./include/types/dns.h	/^	} conf;				\/* config information *\/$/;"	m	struct:dns_resolvers	typeref:struct:dns_resolvers::__anon61
conf	./include/types/listener.h	/^	} conf;				\/* config information *\/$/;"	m	struct:listener	typeref:struct:listener::__anon78
conf	./include/types/mailers.h	/^	} conf;				\/* config information *\/$/;"	m	struct:mailer	typeref:struct:mailer::__anon82
conf	./include/types/mailers.h	/^	} conf;				\/* config information *\/$/;"	m	struct:mailers	typeref:struct:mailers::__anon83
conf	./include/types/peers.h	/^	} conf;				 \/* config information *\/$/;"	m	struct:peers	typeref:struct:peers::__anon93
conf	./include/types/peers.h	/^	} conf;		  	  \/* config information *\/$/;"	m	struct:peer	typeref:struct:peer::__anon92
conf	./include/types/proxy.h	/^	} conf;					\/* config information *\/$/;"	m	struct:proxy	typeref:struct:proxy::__anon109
conf	./include/types/server.h	/^	} conf;					\/* config information *\/$/;"	m	struct:server	typeref:struct:server::__anon123
config_callback	./src/log.c	/^	int (*config_callback)(struct logformat_node *node, struct proxy *curproxy);$/;"	m	struct:logformat_type	file:
confirm	./include/types/peers.h	/^	unsigned int confirm;         \/* confirm message counter *\/$/;"	m	struct:peer
conn	./include/types/checks.h	/^	struct connection *conn;		\/* connection state for health checks *\/$/;"	m	struct:check	typeref:struct:check::connection
conn_attach	./include/proto/connection.h	/^static inline void conn_attach(struct connection *conn, void *owner, const struct data_cb *data)$/;"	f
conn_cnt	./include/types/stick_table.h	/^	unsigned int conn_cnt;$/;"	m	union:stktable_data
conn_complete_session	./src/session.c	/^static int conn_complete_session(struct connection *conn)$/;"	f	file:
conn_cond_update_data_polling	./include/proto/connection.h	/^static inline void conn_cond_update_data_polling(struct connection *c)$/;"	f
conn_cond_update_polling	./include/proto/connection.h	/^static inline void conn_cond_update_polling(struct connection *c)$/;"	f
conn_cond_update_sock_polling	./include/proto/connection.h	/^static inline void conn_cond_update_sock_polling(struct connection *c)$/;"	f
conn_ctrl_close	./include/proto/connection.h	/^static inline void conn_ctrl_close(struct connection *conn)$/;"	f
conn_ctrl_init	./include/proto/connection.h	/^static inline void conn_ctrl_init(struct connection *conn)$/;"	f
conn_ctrl_ready	./include/proto/connection.h	/^static inline int conn_ctrl_ready(const struct connection *conn)$/;"	f
conn_cur	./include/types/stick_table.h	/^	unsigned int conn_cur;$/;"	m	union:stktable_data
conn_data_polling_changes	./include/proto/connection.h	/^static inline unsigned int conn_data_polling_changes(const struct connection *c)$/;"	f
conn_data_read0	./include/proto/connection.h	/^static inline void conn_data_read0(struct connection *c)$/;"	f
conn_data_read0_pending	./include/proto/connection.h	/^static inline int conn_data_read0_pending(struct connection *c)$/;"	f
conn_data_shutw	./include/proto/connection.h	/^static inline void conn_data_shutw(struct connection *c)$/;"	f
conn_data_shutw_hard	./include/proto/connection.h	/^static inline void conn_data_shutw_hard(struct connection *c)$/;"	f
conn_data_stop_both	./include/proto/connection.h	/^static inline void conn_data_stop_both(struct connection *c)$/;"	f
conn_data_stop_recv	./include/proto/connection.h	/^static inline void conn_data_stop_recv(struct connection *c)$/;"	f
conn_data_stop_send	./include/proto/connection.h	/^static inline void conn_data_stop_send(struct connection *c)$/;"	f
conn_data_want_recv	./include/proto/connection.h	/^static inline void conn_data_want_recv(struct connection *c)$/;"	f
conn_data_want_send	./include/proto/connection.h	/^static inline void conn_data_want_send(struct connection *c)$/;"	f
conn_err_code_str	./include/proto/connection.h	/^static inline const char *conn_err_code_str(struct connection *c)$/;"	f
conn_fd_handler	./src/connection.c	/^int conn_fd_handler(int fd)$/;"	f
conn_force_close	./include/proto/connection.h	/^static inline void conn_force_close(struct connection *conn)$/;"	f
conn_free	./include/proto/connection.h	/^static inline void conn_free(struct connection *conn)$/;"	f
conn_full_close	./include/proto/connection.h	/^static inline void conn_full_close(struct connection *conn)$/;"	f
conn_get_from_addr	./include/proto/connection.h	/^static inline void conn_get_from_addr(struct connection *conn)$/;"	f
conn_get_to_addr	./include/proto/connection.h	/^static inline void conn_get_to_addr(struct connection *conn)$/;"	f
conn_init	./include/proto/connection.h	/^static inline void conn_init(struct connection *conn)$/;"	f
conn_max	./include/types/counters.h	/^	unsigned int conn_max;			\/* max # of active listener sessions *\/$/;"	m	struct:licounters
conn_max	./include/types/counters.h	/^	unsigned int conn_max;                  \/* max # of active sessions *\/$/;"	m	struct:pxcounters
conn_new	./include/proto/connection.h	/^static inline struct connection *conn_new()$/;"	f
conn_opts	./include/types/checks.h	/^	unsigned short conn_opts;               \/* options when setting up a new connection *\/$/;"	m	struct:tcpcheck_rule
conn_per_sec	./include/types/global.h	/^	struct freq_ctr conn_per_sec;$/;"	m	struct:global	typeref:struct:global::freq_ctr
conn_prepare	./include/proto/connection.h	/^static inline void conn_prepare(struct connection *conn, const struct protocol *proto, const struct xprt_ops *xprt)$/;"	f
conn_rate	./include/types/stick_table.h	/^	struct freq_ctr_period conn_rate;$/;"	m	union:stktable_data	typeref:struct:stktable_data::freq_ctr_period
conn_recv_proxy	./src/connection.c	/^int conn_recv_proxy(struct connection *conn, int flag)$/;"	f
conn_refresh_polling_flags	./include/proto/connection.h	/^static inline void conn_refresh_polling_flags(struct connection *conn)$/;"	f
conn_retries	./include/types/proxy.h	/^	int conn_retries;			\/* maximum number of connect retries *\/$/;"	m	struct:proxy
conn_retries	./include/types/stream_interface.h	/^	int conn_retries;	\/* number of connect retries left *\/$/;"	m	struct:stream_interface
conn_si_send_proxy	./src/stream_interface.c	/^int conn_si_send_proxy(struct connection *conn, unsigned int flag)$/;"	f
conn_sock_drain	./src/connection.c	/^int conn_sock_drain(struct connection *conn)$/;"	f
conn_sock_polling_changes	./include/proto/connection.h	/^static inline unsigned int conn_sock_polling_changes(const struct connection *c)$/;"	f
conn_sock_read0	./include/proto/connection.h	/^static inline void conn_sock_read0(struct connection *c)$/;"	f
conn_sock_send	./src/connection.c	/^int conn_sock_send(struct connection *conn, const void *buf, int len, int flags)$/;"	f
conn_sock_shutw	./include/proto/connection.h	/^static inline void conn_sock_shutw(struct connection *c)$/;"	f
conn_sock_shutw_pending	./include/proto/connection.h	/^static inline int conn_sock_shutw_pending(struct connection *c)$/;"	f
conn_sock_stop_both	./include/proto/connection.h	/^static inline void conn_sock_stop_both(struct connection *c)$/;"	f
conn_sock_stop_recv	./include/proto/connection.h	/^static inline void conn_sock_stop_recv(struct connection *c)$/;"	f
conn_sock_stop_send	./include/proto/connection.h	/^static inline void conn_sock_stop_send(struct connection *c)$/;"	f
conn_sock_want_recv	./include/proto/connection.h	/^static inline void conn_sock_want_recv(struct connection *c)$/;"	f
conn_sock_want_send	./include/proto/connection.h	/^static inline void conn_sock_want_send(struct connection *c)$/;"	f
conn_src	./include/types/connection.h	/^struct conn_src {$/;"	s
conn_src	./include/types/proxy.h	/^	struct conn_src conn_src;               \/* connection source settings *\/$/;"	m	struct:proxy	typeref:struct:proxy::conn_src
conn_src	./include/types/server.h	/^	struct conn_src conn_src;               \/* connection source settings *\/$/;"	m	struct:server	typeref:struct:server::conn_src
conn_stop_polling	./include/proto/connection.h	/^static inline void conn_stop_polling(struct connection *c)$/;"	f
conn_update_data_polling	./src/connection.c	/^void conn_update_data_polling(struct connection *c)$/;"	f
conn_update_session	./src/session.c	/^static int conn_update_session(struct connection *conn)$/;"	f	file:
conn_update_sock_polling	./src/connection.c	/^void conn_update_sock_polling(struct connection *c)$/;"	f
conn_xprt_close	./include/proto/connection.h	/^static inline void conn_xprt_close(struct connection *conn)$/;"	f
conn_xprt_init	./include/proto/connection.h	/^static inline int conn_xprt_init(struct connection *conn)$/;"	f
conn_xprt_ready	./include/proto/connection.h	/^static inline int conn_xprt_ready(const struct connection *conn)$/;"	f
connect	./include/types/protocol.h	/^	int (*connect)(struct connection *, int data, int delack);  \/* connect function if any *\/$/;"	m	struct:protocol
connect	./include/types/proxy.h	/^		int connect;                    \/* connect timeout (in ticks) *\/$/;"	m	struct:proxy::__anon108
connect_conn_chk	./src/checks.c	/^static int connect_conn_chk(struct task *t)$/;"	f	file:
connect_default_ciphers	./include/types/global.h	/^	char *connect_default_ciphers;$/;"	m	struct:global
connect_default_ssloptions	./include/types/global.h	/^	int connect_default_ssloptions;$/;"	m	struct:global
connect_proc_chk	./src/checks.c	/^static int connect_proc_chk(struct task *t)$/;"	f	file:
connect_server	./src/backend.c	/^int connect_server(struct stream *s)$/;"	f
connected	./include/types/applet.h	/^			int connected;$/;"	m	struct:appctx::__anon21::__anon30
connection	./include/types/connection.h	/^struct connection {$/;"	s
cons	./include/types/pipe.h	/^	int cons;	\/* FD the consumer must read from ; -1 if none *\/$/;"	m	struct:pipe
consecutive_errors	./include/types/server.h	/^	int consecutive_errors;			\/* current number of consecutive errors *\/$/;"	m	struct:server
consecutive_errors_limit	./include/types/server.h	/^	int consecutive_errors_limit;		\/* number of consecutive errors that triggers an event *\/$/;"	m	struct:server
container_of	./ebtree/ebtree.h	/^#define container_of(/;"	d
container_of	./include/common/rbtree.h	/^#define container_of(/;"	d
container_of_safe	./ebtree/ebtree.h	/^#define container_of_safe(/;"	d
context	./include/types/task.h	/^	void *context;			\/* the task's context *\/$/;"	m	struct:task
conv	./include/types/arg.h	/^	const char *conv;         \/* conv keyword when in conv, otherwise NULL *\/$/;"	m	struct:arg_list
conv	./include/types/map.h	/^	struct sample_conv *conv;      \/* original converter descriptor *\/$/;"	m	struct:map_descriptor	typeref:struct:map_descriptor::sample_conv
conv	./include/types/sample.h	/^	struct sample_conv *conv;                 \/* sample conversion used *\/$/;"	m	struct:sample_conv_expr	typeref:struct:sample_conv_expr::sample_conv
conv_check_var	./src/vars.c	/^static int conv_check_var(struct arg *args, struct sample_conv *conv,$/;"	f	file:
conv_exprs	./include/types/sample.h	/^	struct list conv_exprs;                   \/* list of conversion expression to apply *\/$/;"	m	struct:sample_expr	typeref:struct:sample_expr::list
conv_kws	./src/51d.c	/^static struct sample_conv_kw_list conv_kws = {ILH, {$/;"	v	typeref:struct:sample_conv_kw_list	file:
conv_kws	./src/da.c	/^static struct sample_conv_kw_list conv_kws = {ILH, {$/;"	v	typeref:struct:sample_conv_kw_list	file:
convert_date	./contrib/halog/halog.c	/^int convert_date(const char *field)$/;"	f
convert_date_to_timestamp	./contrib/halog/halog.c	/^int convert_date_to_timestamp(const char *field)$/;"	f
convert_range	./contrib/ip6range/ip6range.c	/^static void convert_range(struct in6_addr *low, struct in6_addr *high, const char *eol, const char *pfx)$/;"	f	file:
convert_range	./contrib/iprange/iprange.c	/^static void convert_range(unsigned int low, unsigned int high, const char *eol, const char *pfx)$/;"	f	file:
cookie	./include/types/server.h	/^	char *cookie;				\/* the id set in the cookie *\/$/;"	m	struct:server
cookie_domain	./include/types/proxy.h	/^	char *cookie_domain;			\/* domain used to insert the cookie *\/$/;"	m	struct:proxy
cookie_first_date	./include/types/proto_http.h	/^	int cookie_first_date;          \/* if non-zero, first date the expirable cookie was set\/seen *\/$/;"	m	struct:http_txn
cookie_last_date	./include/types/proto_http.h	/^	int cookie_last_date;           \/* if non-zero, last date the expirable cookie was set\/seen *\/$/;"	m	struct:http_txn
cookie_len	./include/types/global.h	/^		int cookie_len;    \/* max length of cookie captures *\/$/;"	m	struct:global::__anon72
cookie_len	./include/types/proxy.h	/^	int  cookie_len;			\/* strlen(cookie_name), computed only once *\/$/;"	m	struct:proxy
cookie_len	./include/types/proxy.h	/^	int cookie_len;$/;"	m	struct:redirect_rule
cookie_maxidle	./include/types/proxy.h	/^	unsigned int cookie_maxidle;		\/* max idle time for this cookie *\/$/;"	m	struct:proxy
cookie_maxlife	./include/types/proxy.h	/^	unsigned int cookie_maxlife;		\/* max life time for this cookie *\/$/;"	m	struct:proxy
cookie_name	./include/types/proxy.h	/^	char *cookie_name;			\/* name of the cookie to look for *\/$/;"	m	struct:proxy
cookie_str	./include/types/proxy.h	/^	char *cookie_str;$/;"	m	struct:redirect_rule
cookiename	./include/types/global.h	/^		char *cookiename;$/;"	m	struct:global::__anon75
cookienamelen	./include/types/global.h	/^		size_t cookienamelen;$/;"	m	struct:global::__anon75
copyright	./doc/lua-api/conf.py	/^copyright = u'2015, Thierry FOURNIER'$/;"	v
count	./contrib/halog/halog.c	/^	unsigned int count;$/;"	m	struct:timer	file:
count	./include/types/mailers.h	/^	int count;			\/* total number of mailers in this mailers section *\/$/;"	m	struct:mailers
count	./include/types/peers.h	/^	int count;			 \/* total of peers *\/$/;"	m	struct:peers
count	./include/types/signal.h	/^	int count;                      \/* number of times raised *\/$/;"	m	struct:signal_descriptor
count_hash_results	./tests/ip-hash.c	/^void count_hash_results(unsigned long hash, int counts[NSERV][NSERV]) {$/;"	f
count_hash_results	./tests/uri_hash.c	/^void count_hash_results(unsigned long hash, int counts[NSERV][NSERV]) {$/;"	f
count_nameservers	./include/types/dns.h	/^	int count_nameservers;			\/* total number of nameservers in a resolvers section *\/$/;"	m	struct:dns_resolvers
counters	./include/types/dns.h	/^	} counters;$/;"	m	struct:dns_nameserver	typeref:struct:dns_nameserver::__anon65
counters	./include/types/listener.h	/^	struct licounters *counters;	\/* statistics counters *\/$/;"	m	struct:listener	typeref:struct:listener::licounters
counters	./include/types/server.h	/^	struct srvcounters counters;		\/* statistics counters *\/$/;"	m	struct:server	typeref:struct:server::srvcounters
counts_SuperFastHash	./tests/uri_hash.c	/^int counts_SuperFastHash[NSERV][NSERV];$/;"	v
counts_SuperFastHash2	./tests/uri_hash.c	/^int counts_SuperFastHash2[NSERV][NSERV];$/;"	v
counts_bj6	./tests/ip-hash.c	/^int counts_bj6[NSERV][NSERV];$/;"	v
counts_bj6x	./tests/ip-hash.c	/^int counts_bj6x[NSERV][NSERV];$/;"	v
counts_bj7	./tests/ip-hash.c	/^int counts_bj7[NSERV][NSERV];$/;"	v
counts_bj7x	./tests/ip-hash.c	/^int counts_bj7x[NSERV][NSERV];$/;"	v
counts_gd1	./tests/uri_hash.c	/^int counts_gd1[NSERV][NSERV];$/;"	v
counts_gd2	./tests/uri_hash.c	/^int counts_gd2[NSERV][NSERV];$/;"	v
counts_gd3	./tests/uri_hash.c	/^int counts_gd3[NSERV][NSERV];$/;"	v
counts_gd4	./tests/uri_hash.c	/^int counts_gd4[NSERV][NSERV];$/;"	v
counts_gd5	./tests/uri_hash.c	/^int counts_gd5[NSERV][NSERV];$/;"	v
counts_gd6	./tests/uri_hash.c	/^int counts_gd6[NSERV][NSERV];$/;"	v
counts_id	./tests/ip-hash.c	/^int counts_id[NSERV][NSERV];$/;"	v
counts_srv	./tests/uri_hash.c	/^int counts_srv[NSERV][NSERV];$/;"	v
counts_tw1	./tests/ip-hash.c	/^int counts_tw1[NSERV][NSERV];$/;"	v
counts_tw2	./tests/ip-hash.c	/^int counts_tw2[NSERV][NSERV];$/;"	v
counts_tw3	./tests/ip-hash.c	/^int counts_tw3[NSERV][NSERV];$/;"	v
counts_wt1	./tests/uri_hash.c	/^int counts_wt1[NSERV][NSERV];$/;"	v
counts_wt2	./tests/uri_hash.c	/^int counts_wt2[NSERV][NSERV];$/;"	v
cps_lim	./include/types/global.h	/^	int cps_lim, cps_max;$/;"	m	struct:global
cps_max	./include/types/counters.h	/^	unsigned int cps_max;                   \/* maximum of new connections received per second *\/$/;"	m	struct:pxcounters
cps_max	./include/types/global.h	/^	int cps_lim, cps_max;$/;"	m	struct:global
cpu_map	./include/types/global.h	/^	unsigned long cpu_map[LONGBITS];  \/* list of CPU masks for the 32\/64 first processes *\/$/;"	m	struct:global
cr	./include/types/hdr_idx.h	/^        unsigned cr   : 1; \/* CR present (1=CRLF, 0=LF). Total line size=len+cr+1. *\/$/;"	m	struct:hdr_idx_elem
create_cond_regex_rule	./src/cfgparse.c	/^static int create_cond_regex_rule(const char *file, int line,$/;"	f	file:
create_pool	./src/memory.c	/^struct pool_head *create_pool(char *name, unsigned int size, unsigned int flags)$/;"	f
create_server_socket	./src/proto_tcp.c	/^static int create_server_socket(struct connection *conn)$/;"	f	file:
crl_file	./include/types/listener.h	/^	char *crl_file;            \/* CRLfile to use on verify *\/$/;"	m	struct:bind_conf
crl_file	./include/types/server.h	/^		char *crl_file;			\/* CRLfile to use on verify *\/$/;"	m	struct:server::__anon122
crt_base	./include/types/global.h	/^	char *crt_base;             \/* base directory path for certificates *\/$/;"	m	struct:global
crt_ignerr	./include/types/listener.h	/^	unsigned long long crt_ignerr; \/* ignored verify errors in handshake if depth == 0 *\/$/;"	m	struct:bind_conf
cstr	./include/common/standard.h	/^static inline const char *cstr(const char *str)$/;"	f
csv_enc	./src/standard.c	/^const char *csv_enc(const char *str, int quote, struct chunk *output)$/;"	f
ctrl	./include/types/connection.h	/^	const struct protocol *ctrl;  \/* operations at the socket layer *\/$/;"	m	struct:connection	typeref:struct:connection::protocol
ctx	./include/types/applet.h	/^	} ctx;					\/* used by stats I\/O handlers to dump the stats *\/$/;"	m	struct:appctx	typeref:union:appctx::__anon21
ctx	./include/types/arg.h	/^	int ctx;                  \/* context where the arg is used (ARGC_*) *\/$/;"	m	struct:arg_list
ctx	./include/types/sample.h	/^	union smp_ctx ctx;$/;"	m	struct:sample	typeref:union:sample::smp_ctx
ctx	./include/types/server.h	/^		SSL_CTX *ctx;$/;"	m	struct:server::__anon122
ctx	./include/types/ssl_sock.h	/^	SSL_CTX *ctx;             \/* context associated to the certificate *\/$/;"	m	struct:sni_ctx
cum_conn	./include/types/counters.h	/^	long long    cum_conn;                  \/* cumulated number of received connections *\/$/;"	m	struct:pxcounters
cum_conn	./include/types/counters.h	/^	long long cum_conn;			\/* cumulated number of received connections *\/$/;"	m	struct:licounters
cum_ct	./contrib/halog/halog.c	/^	unsigned long long cum_ct, cum_rt;$/;"	m	struct:srv_st	file:
cum_lbconn	./include/types/counters.h	/^	long long  cum_lbconn;                  \/* cumulated number of sessions processed by load balancing (BE only) *\/$/;"	m	struct:pxcounters
cum_lbconn	./include/types/counters.h	/^	long long cum_lbconn;			\/* cumulated number of sessions directed by load balancing *\/$/;"	m	struct:srvcounters
cum_req	./include/types/counters.h	/^			long long cum_req;      \/* cumulated number of processed HTTP requests *\/$/;"	m	struct:pxcounters::__anon57::__anon58
cum_rt	./contrib/halog/halog.c	/^	unsigned long long cum_ct, cum_rt;$/;"	m	struct:srv_st	file:
cum_sess	./include/types/counters.h	/^	long long    cum_sess;                  \/* cumulated number of accepted connections *\/$/;"	m	struct:pxcounters
cum_sess	./include/types/counters.h	/^	long long cum_sess;			\/* cumulated number of accepted sessions *\/$/;"	m	struct:licounters
cum_sess	./include/types/counters.h	/^	long long cum_sess;			\/* cumulated number of sessions really sent to this server *\/$/;"	m	struct:srvcounters
cur_lvl	./include/types/compression.h	/^	int cur_lvl;$/;"	m	struct:comp_ctx
cur_poller	./src/fd.c	/^struct poller cur_poller;$/;"	v	typeref:struct:poller
cur_sess	./include/types/server.h	/^	int cur_sess;				\/* number of currently active sessions (including syn_sent) *\/$/;"	m	struct:server
cur_sess_max	./include/types/counters.h	/^	unsigned int cur_sess_max;		\/* max number of currently active sessions *\/$/;"	m	struct:srvcounters
curpid	./include/types/checks.h	/^	struct pid_list *curpid;		\/* entry in pid_list used for current process-based test, or -1 if not in test *\/$/;"	m	struct:check	typeref:struct:check::pid_list
curr	./include/types/lb_fwrr.h	/^	struct eb_root curr;    \/* tree for servers in "current" time range *\/$/;"	m	struct:fwrr_group	typeref:struct:fwrr_group::eb_root
curr_ctr	./include/types/freq_ctr.h	/^	unsigned int curr_ctr;  \/* cumulated value for current period *\/$/;"	m	struct:freq_ctr_period
curr_ctr	./include/types/freq_ctr.h	/^	unsigned int curr_ctr; \/* cumulated value for current period *\/$/;"	m	struct:freq_ctr
curr_pos	./include/types/lb_fwrr.h	/^	int curr_pos;           \/* current position in the tree *\/$/;"	m	struct:fwrr_group
curr_resolution	./include/types/dns.h	/^	struct list curr_resolution;	\/* current running resolutions *\/$/;"	m	struct:dns_resolvers	typeref:struct:dns_resolvers::list
curr_sec	./include/types/freq_ctr.h	/^	unsigned int curr_sec; \/* start date of current period (seconds from now.tv_sec) *\/$/;"	m	struct:freq_ctr
curr_sec_ms	./src/time.c	/^unsigned int   curr_sec_ms;     \/* millisecond of current second (0..999) *\/$/;"	v
curr_tick	./include/types/freq_ctr.h	/^	unsigned int curr_tick; \/* start date of current period (wrapping ticks) *\/$/;"	m	struct:freq_ctr_period
curr_weight	./include/types/lb_fwrr.h	/^	int curr_weight;        \/* total weight of the current time range *\/$/;"	m	struct:fwrr_group
current	./include/types/stick_table.h	/^	unsigned int current;     \/* number of sticky sessions currently in table *\/$/;"	m	struct:stktable
current_rule	./include/types/stream.h	/^	void *current_rule;                     \/* this is used to store the current rule to be resumed. *\/$/;"	m	struct:stream
current_rule_list	./include/types/stream.h	/^	struct list *current_rule_list;         \/* this is used to store the current executed rule list. *\/$/;"	m	struct:stream	typeref:struct:stream::list
current_step	./include/types/checks.h	/^	struct tcpcheck_rule *current_step;     \/* current step when using tcpcheck *\/$/;"	m	struct:check	typeref:struct:check::tcpcheck_rule
cursection	./src/cfgparse.c	/^static char *cursection = NULL;$/;"	v	file:
cut_crlf	./include/common/standard.h	/^static inline char *cut_crlf(char *s) {$/;"	f
d	./include/types/sample.h	/^	double d;       \/* any float or double *\/$/;"	m	union:smp_ctx
d_time	./include/types/counters.h	/^	unsigned int q_time, c_time, d_time, t_time; \/* sums of conn_time, queue_time, data_time, total_time *\/$/;"	m	struct:pxcounters
d_time	./include/types/counters.h	/^	unsigned int q_time, c_time, d_time, t_time; \/* sums of conn_time, queue_time, data_time, total_time *\/$/;"	m	struct:srvcounters
da_haproxy	./src/da.c	/^static int da_haproxy(const struct arg *args, struct sample *smp, da_deviceinfo_t *devinfo)$/;"	f	file:
da_haproxy_conv	./src/da.c	/^static int da_haproxy_conv(const struct arg *args, struct sample *smp, void *private)$/;"	f	file:
da_haproxy_fetch	./src/da.c	/^static int da_haproxy_fetch(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
da_haproxy_log	./src/da.c	/^static void da_haproxy_log(da_severity_t severity, da_status_t status,$/;"	f	file:
da_haproxy_read	./src/da.c	/^static size_t da_haproxy_read(void *ctx, size_t len, char *buf)$/;"	f	file:
da_haproxy_seek	./src/da.c	/^static da_status_t da_haproxy_seek(void *ctx, off_t off)$/;"	f	file:
da_json_file	./src/da.c	/^static int da_json_file(char **args, int section_type, struct proxy *curpx,$/;"	f	file:
da_log_level	./src/da.c	/^static int da_log_level(char **args, int section_type, struct proxy *curpx,$/;"	f	file:
da_properties_cookie	./src/da.c	/^static int da_properties_cookie(char **args, int section_type, struct proxy *curpx,$/;"	f	file:
da_property_separator	./src/da.c	/^static int da_property_separator(char **args, int section_type, struct proxy *curpx,$/;"	f	file:
dacfg_kws	./src/da.c	/^static struct cfg_kw_list dacfg_kws = {{ }, {$/;"	v	typeref:struct:cfg_kw_list	file:
daset	./include/types/global.h	/^		unsigned char daset:1;$/;"	m	struct:global::__anon75
data	./include/common/buffer.h	/^	char data[0];                   \/* <size> bytes *\/$/;"	m	struct:buffer
data	./include/common/epoll.h	/^	} data;$/;"	m	struct:epoll_event	typeref:union:epoll_event::__anon2
data	./include/import/lru.h	/^	void *data;                   \/* returned value, user decides how to use this *\/$/;"	m	struct:lru64
data	./include/types/arg.h	/^	union arg_data data;      \/* argument data *\/$/;"	m	struct:arg	typeref:union:arg::arg_data
data	./include/types/connection.h	/^	const struct data_cb  *data;  \/* data layer callbacks. Must be set before xprt->init() *\/$/;"	m	struct:connection	typeref:struct:connection::data_cb
data	./include/types/pattern.h	/^	struct sample_data *data;       \/* used to store a pointer to sample value associated$/;"	m	struct:pattern	typeref:struct:pattern::sample_data
data	./include/types/pattern.h	/^	struct sample_data *data;$/;"	m	struct:pattern_tree	typeref:struct:pattern_tree::sample_data
data	./include/types/pipe.h	/^	int data;	\/* number of bytes present in the pipe  *\/$/;"	m	struct:pipe
data	./include/types/proto_udp.h	/^	const struct dgram_data_cb *data;	\/* data layer callbacks. Must be set before *\/$/;"	m	struct:dgram_conn	typeref:struct:dgram_conn::dgram_data_cb
data	./include/types/sample.h	/^	struct sample_data data;$/;"	m	struct:sample	typeref:struct:sample::sample_data
data	./include/types/vars.h	/^	struct sample_data data; \/* data storage. *\/$/;"	m	struct:var	typeref:struct:var::sample_data
data	./src/shctx.c	/^		unsigned char data[sizeof(struct shared_session)];$/;"	m	union:shared_block::__anon144	file:
data	./src/shctx.c	/^	unsigned char data[0];$/;"	m	struct:shsess_packet	file:
data	./src/shctx.c	/^	unsigned char data[SHSESS_BLOCK_MIN_SIZE];$/;"	m	struct:shared_session	file:
data	./src/shctx.c	/^	unsigned char data[SHSESS_MAX_DATA_LEN];$/;"	m	struct:shared_context	file:
data	./src/shctx.c	/^	} data;$/;"	m	struct:shared_block	typeref:union:shared_block::__anon144	file:
data_arg	./include/types/stick_table.h	/^	} data_arg[STKTABLE_DATA_TYPES]; \/* optional argument of each data type *\/$/;"	m	struct:stktable	typeref:union:stktable::__anon128
data_cb	./include/types/connection.h	/^struct data_cb {$/;"	s
data_file_path	./include/types/global.h	/^		char *data_file_path;$/;"	m	struct:global::__anon76
data_len	./src/shctx.c	/^	short int data_len;$/;"	m	struct:shared_block	file:
data_len	./src/shctx.c	/^	short int data_len;$/;"	m	struct:shared_context	file:
data_ofs	./include/types/stick_table.h	/^	int data_ofs[STKTABLE_DATA_TYPES]; \/* negative offsets of present data types, or 0 if absent *\/$/;"	m	struct:stktable
data_op	./include/types/applet.h	/^			signed char data_op;	\/* operator (STD_OP_*) when data_type set *\/$/;"	m	struct:appctx::__anon21::__anon25
data_set	./include/types/global.h	/^		fiftyoneDegreesDataSet data_set; \/* data set used with the pattern detection method. *\/$/;"	m	struct:global::__anon76
data_size	./include/types/stick_table.h	/^	int data_size;            \/* the size of the data that is prepended *before* stksess *\/$/;"	m	struct:stktable
data_type	./include/types/applet.h	/^			signed char data_type;	\/* type of data to compare, or -1 if none *\/$/;"	m	struct:appctx::__anon21::__anon25
date	./src/time.c	/^struct timeval date;            \/* the real current date *\/$/;"	v	typeref:struct:timeval
date2str_log	./src/standard.c	/^char *date2str_log(char *dst, struct tm *tm, struct timeval *date, size_t size)$/;"	f
dbmanage_admin_rule	./include/common/uri_auth.h	/^struct dbmanage_admin_rule {$/;"	s
debug_hdr	./src/proto_http.c	/^void debug_hdr(const char *dir, struct stream *s, const char *start, const char *end)$/;"	f
default_acl_list	./src/acl.c	/^} default_acl_list[] = {$/;"	v	typeref:struct:__anon133
default_ctx	./include/types/listener.h	/^	SSL_CTX *default_ctx;      \/* SSL context of first\/default certificate *\/$/;"	m	struct:bind_conf
default_http_log_format	./src/log.c	/^char default_http_log_format[] = "%ci:%cp [%t] %ft %b\/%s %Tq\/%Tw\/%Tc\/%Tr\/%Tt %ST %B %CC %CS %tsc %ac\/%fc\/%bc\/%sc\/%rc %sq\/%bq %hr %hs %{+Q}r"; \/\/ default format$/;"	v
default_namespace	./src/namespace.c	/^static int default_namespace = -1;$/;"	v	file:
default_ok	./include/types/server.h	/^	int default_ok; \/* non-zero if kw is supported in default-server section *\/$/;"	m	struct:srv_kw
default_rfc5424_sd_log_format	./src/log.c	/^char default_rfc5424_sd_log_format[] = "- ";$/;"	v
default_size	./include/types/stick_table.h	/^	size_t default_size;      \/* default key size *\/$/;"	m	struct:stktable_type
default_srv_error	./src/stream.c	/^void default_srv_error(struct stream *s, struct stream_interface *si)$/;"	f
default_target	./include/types/listener.h	/^	enum obj_type *default_target;  \/* default target to use for accepted sessions or NULL *\/$/;"	m	struct:listener	typeref:enum:listener::obj_type
default_target	./include/types/proxy.h	/^	enum obj_type *default_target;		\/* default target to use for accepted streams or NULL *\/$/;"	m	struct:proxy	typeref:enum:proxy::obj_type
default_tcp_log_format	./src/log.c	/^char default_tcp_log_format[] = "%ci:%cp [%t] %ft %b\/%s %Tw\/%Tc\/%Tt %B %ts %ac\/%fc\/%bc\/%sc\/%rc %sq\/%bq";$/;"	v
defbe	./include/types/proxy.h	/^	} defbe;$/;"	m	struct:proxy	typeref:union:proxy::__anon105
deflate_add_data	./src/compression.c	/^static int deflate_add_data(struct comp_ctx *comp_ctx, const char *in_data, int in_len, struct buffer *out)$/;"	f	file:
deflate_end	./src/compression.c	/^static int deflate_end(struct comp_ctx **comp_ctx)$/;"	f	file:
deflate_finish	./src/compression.c	/^static int deflate_finish(struct comp_ctx *comp_ctx, struct buffer *out)$/;"	f	file:
deflate_flush	./src/compression.c	/^static int deflate_flush(struct comp_ctx *comp_ctx, struct buffer *out)$/;"	f	file:
deflate_flush_or_finish	./src/compression.c	/^static int deflate_flush_or_finish(struct comp_ctx *comp_ctx, struct buffer *out, int flag)$/;"	f	file:
deflate_init	./src/compression.c	/^static int deflate_init(struct comp_ctx **comp_ctx, int level)$/;"	f	file:
defproxy	./src/cfgparse.c	/^static struct proxy defproxy;		\/* fake proxy used to assign default values on all instances *\/$/;"	v	typeref:struct:proxy	file:
defsrv	./include/types/proxy.h	/^	struct server *srv, defsrv;		\/* known servers; default server configuration *\/$/;"	m	struct:proxy	typeref:struct:proxy::
deinit	./src/haproxy.c	/^void deinit(void)$/;"	f
deinit_51degrees	./src/51d.c	/^void deinit_51degrees(void)$/;"	f
deinit_acl_cond	./src/haproxy.c	/^static void deinit_acl_cond(struct acl_cond *cond)$/;"	f	file:
deinit_comp_ctx	./src/compression.c	/^static inline int deinit_comp_ctx(struct comp_ctx **comp_ctx)$/;"	f	file:
deinit_deviceatlas	./src/da.c	/^void deinit_deviceatlas(void)$/;"	f
deinit_pollers	./src/fd.c	/^void deinit_pollers() {$/;"	f
deinit_sample_arg	./src/haproxy.c	/^static void deinit_sample_arg(struct arg *p)$/;"	f	file:
deinit_signals	./src/signal.c	/^void deinit_signals()$/;"	f
deinit_stick_rules	./src/haproxy.c	/^static void deinit_stick_rules(struct list *rules)$/;"	f	file:
deinit_tcp_rules	./src/haproxy.c	/^static void deinit_tcp_rules(struct list *rules)$/;"	f	file:
del	./include/types/proto_http.h	/^	int  del;  \/* relative to line *\/$/;"	m	struct:hdr_ctx
del_hdr_value	./src/proto_http.c	/^int del_hdr_value(struct buffer *buf, char **from, char *next)$/;"	f
delete_listener	./src/listener.c	/^void delete_listener(struct listener *listener)$/;"	f
denied_conn	./include/types/counters.h	/^	long long denied_conn;			\/* denied connection requests (tcp-req rules) *\/$/;"	m	struct:licounters
denied_conn	./include/types/counters.h	/^	long long denied_conn;                  \/* denied connection requests (tcp-req rules) *\/$/;"	m	struct:pxcounters
denied_req	./include/types/counters.h	/^	long long denied_req, denied_resp;	\/* blocked requests\/responses because of security concerns *\/$/;"	m	struct:licounters
denied_req	./include/types/counters.h	/^	long long denied_req;                   \/* blocked requests\/responses because of security concerns *\/$/;"	m	struct:pxcounters
denied_resp	./include/types/counters.h	/^	long long denied_req, denied_resp;	\/* blocked requests\/responses because of security concerns *\/$/;"	m	struct:licounters
denied_resp	./include/types/counters.h	/^	long long denied_resp;                  \/* blocked requests\/responses because of security concerns *\/$/;"	m	struct:pxcounters
deny_status	./include/types/action.h	/^	short deny_status;                     \/* HTTP status to return to user when denying *\/$/;"	m	struct:act_rule
dequeue_all_listeners	./src/listener.c	/^void dequeue_all_listeners(struct list *list)$/;"	f
dequeue_srv	./tests/filltab25.c	/^static inline void dequeue_srv(struct srv *s) {$/;"	f	file:
desc	./include/common/uri_auth.h	/^	char *node, *desc;		\/* node name & description reported in this stats *\/$/;"	m	struct:uri_auth
desc	./include/types/checks.h	/^	char *desc;				\/* description *\/$/;"	m	struct:analyze_status
desc	./include/types/checks.h	/^	char *desc;			\/* long description *\/$/;"	m	struct:check_status
desc	./include/types/checks.h	/^	char desc[HCHK_DESC_LEN];		\/* health check description *\/$/;"	m	struct:check
desc	./include/types/global.h	/^	char *node, *desc;		\/* node name & description *\/$/;"	m	struct:global
desc	./include/types/proxy.h	/^	char *id, *desc;			\/* proxy id (name) and description *\/$/;"	m	struct:proxy
destroy_uxst_socket	./src/proto_uxst.c	/^static void destroy_uxst_socket(const char *path)$/;"	f	file:
device_offsets	./include/types/global.h	/^		fiftyoneDegreesDeviceOffsets device_offsets; \/* Memory used for device offsets. *\/$/;"	m	struct:global::__anon76
deviceatlas	./include/types/global.h	/^	} deviceatlas;$/;"	m	struct:global	typeref:struct:global::__anon75
dgram	./include/types/dns.h	/^	struct dgram_conn *dgram;		\/* transport layer *\/$/;"	m	struct:dns_nameserver	typeref:struct:dns_nameserver::dgram_conn
dgram_conn	./include/types/proto_udp.h	/^struct dgram_conn {$/;"	s
dgram_data_cb	./include/types/proto_udp.h	/^struct dgram_data_cb {$/;"	s
dgram_fd_handler	./src/proto_udp.c	/^int dgram_fd_handler(int fd)$/;"	f
die	./contrib/halog/halog.c	/^void die(const char *msg)$/;"	f
dir	./include/types/hlua.h	/^	int dir;                \/* SMP_OPT_DIR_{REQ,RES} *\/$/;"	m	struct:hlua_smp
dir	./include/types/hlua.h	/^	int dir;                \/* SMP_OPT_DIR_{REQ,RES} *\/$/;"	m	struct:hlua_txn
direct_len	./include/types/compression.h	/^	int direct_len;         \/* length of direct_ptr if not NULL *\/$/;"	m	struct:comp_ctx
direct_ptr	./include/types/compression.h	/^	const void *direct_ptr; \/* NULL or pointer to beginning of data *\/$/;"	m	struct:comp_ctx
disable_all	./include/types/protocol.h	/^	int (*disable_all)(struct protocol *proto);	\/* disable all bound listeners *\/$/;"	m	struct:protocol
disable_all_listeners	./src/listener.c	/^int disable_all_listeners(struct protocol *proto)$/;"	f
disable_listener	./src/listener.c	/^void disable_listener(struct listener *listener)$/;"	f
disable_poller	./src/fd.c	/^void disable_poller(const char *poller_name)$/;"	f
disabled	./src/trace.c	/^static int disabled;$/;"	v	file:
dispatch_addr	./include/types/proxy.h	/^	struct sockaddr_storage dispatch_addr;	\/* the default address to connect to *\/$/;"	m	struct:proxy	typeref:struct:proxy::sockaddr_storage
display	./include/types/pattern.h	/^	char *display; \/* String displayed to identify the pattern origin. *\/$/;"	m	struct:pat_ref
display_build_opts	./src/haproxy.c	/^void display_build_opts()$/;"	f
display_flags	./include/types/applet.h	/^			unsigned int display_flags;$/;"	m	struct:appctx::__anon21::__anon28
display_version	./src/haproxy.c	/^void display_version()$/;"	f
div64_32	./include/common/standard.h	/^static inline unsigned int div64_32(unsigned long long o1, unsigned int o2)$/;"	f
dns_build_query	./src/dns.c	/^int dns_build_query(int query_id, int query_type, char *hostname_dn, int hostname_dn_len, char *buf, int bufsize)$/;"	f
dns_check_resolution_queue	./src/dns.c	/^int dns_check_resolution_queue(struct dns_resolvers *resolvers)$/;"	f
dns_get_ip_from_response	./src/dns.c	/^int dns_get_ip_from_response(unsigned char *resp, unsigned char *resp_end,$/;"	f
dns_header	./include/types/dns.h	/^struct dns_header {$/;"	s
dns_hostname_validation	./src/dns.c	/^int dns_hostname_validation(const char *string, char **err)$/;"	f
dns_init_resolvers	./src/dns.c	/^int dns_init_resolvers(void)$/;"	f
dns_nameserver	./include/types/dns.h	/^struct dns_nameserver {$/;"	s
dns_print_current_resolutions	./src/dns.c	/^void dns_print_current_resolutions(struct dns_resolvers *resolvers)$/;"	f
dns_process_resolve	./src/dns.c	/^struct task *dns_process_resolve(struct task *t)$/;"	f
dns_query_id_seed	./src/dns.c	/^static int64_t dns_query_id_seed;	\/* random seed *\/$/;"	v	file:
dns_question	./include/types/dns.h	/^struct dns_question {$/;"	s
dns_reset_resolution	./src/dns.c	/^void dns_reset_resolution(struct dns_resolution *resolution)$/;"	f
dns_resolution	./include/types/dns.h	/^struct dns_resolution {$/;"	s
dns_resolve_recv	./src/dns.c	/^void dns_resolve_recv(struct dgram_conn *dgram)$/;"	f
dns_resolve_send	./src/dns.c	/^void dns_resolve_send(struct dgram_conn *dgram)$/;"	f
dns_resolvers	./include/types/dns.h	/^struct dns_resolvers {$/;"	s
dns_resolvers	./src/dns.c	/^struct list dns_resolvers = LIST_HEAD_INIT(dns_resolvers);$/;"	v	typeref:struct:list
dns_response_get_query_id	./src/dns.c	/^int dns_response_get_query_id(unsigned char *resp)$/;"	f
dns_rnd16	./src/dns.c	/^uint16_t dns_rnd16(void)$/;"	f
dns_send_query	./src/dns.c	/^int dns_send_query(struct dns_resolution *resolution)$/;"	f
dns_str_to_dn_label	./src/dns.c	/^char *dns_str_to_dn_label(const char *string, char *dn, int dn_len)$/;"	f
dns_str_to_dn_label_len	./src/dns.c	/^int dns_str_to_dn_label_len(const char *string)$/;"	f
dns_update_resolvers_timeout	./src/dns.c	/^void dns_update_resolvers_timeout(struct dns_resolvers *resolvers)$/;"	f
dns_validate_dns_response	./src/dns.c	/^int dns_validate_dns_response(unsigned char *resp, unsigned char *bufend, char *dn_name, int dn_name_len)$/;"	f
do_free	./include/types/map.h	/^	int do_free;                   \/* set if <pat> is the orignal pat and must be freed *\/$/;"	m	struct:map_descriptor
do_free	./include/types/pattern.h	/^	int do_free;$/;"	m	struct:pattern_expr_list
do_log	./include/types/stream.h	/^	void (*do_log)(struct stream *s);       \/* the function to call in order to log (or NULL) *\/$/;"	m	struct:stream
do_restart	./src/haproxy-systemd-wrapper.c	/^static void do_restart(void)$/;"	f	file:
do_shutdown	./src/haproxy-systemd-wrapper.c	/^static void do_shutdown(void)$/;"	f	file:
domain	./include/import/lru.h	/^	void *domain;                 \/* who this data belongs to *\/$/;"	m	struct:lru64
dow	./include/types/pattern.h	/^	int dow:7;              \/* 1 bit per day of week: 0-6 *\/$/;"	m	struct:pat_time
down_time	./include/types/proxy.h	/^	unsigned down_time;			\/* total time the proxy was down *\/$/;"	m	struct:proxy
down_time	./include/types/server.h	/^	unsigned down_time;			\/* total time the server was down *\/$/;"	m	struct:server
down_trans	./include/types/counters.h	/^	long long down_trans;			\/* up->down transitions *\/$/;"	m	struct:srvcounters
down_trans	./include/types/proxy.h	/^	unsigned down_trans;			\/* up-down transitions *\/$/;"	m	struct:proxy
downinter	./include/types/checks.h	/^	int inter, fastinter, downinter;        \/* checks: time in milliseconds *\/$/;"	m	struct:check
drain	./include/types/protocol.h	/^	int (*drain)(int fd);                           \/* indicates whether we can safely close the fd *\/$/;"	m	struct:protocol
dst_addr	./include/types/connection.h	/^			uint32_t dst_addr;$/;"	m	struct:proxy_hdr_v2::__anon53::__anon54
dst_addr	./include/types/connection.h	/^			uint8_t  dst_addr[16];$/;"	m	struct:proxy_hdr_v2::__anon53::__anon55
dst_addr	./include/types/connection.h	/^			uint8_t dst_addr[108];$/;"	m	struct:proxy_hdr_v2::__anon53::__anon56
dst_port	./include/types/connection.h	/^			uint16_t dst_port;$/;"	m	struct:proxy_hdr_v2::__anon53::__anon54
dst_port	./include/types/connection.h	/^			uint16_t dst_port;$/;"	m	struct:proxy_hdr_v2::__anon53::__anon55
dump	./src/haproxy.c	/^void dump(struct sig_handler *sh)$/;"	f
dump_binary	./src/dumpstats.c	/^static int dump_binary(struct chunk *out, const char *buf, int bsize)$/;"	f	file:
dump_hash_results	./tests/ip-hash.c	/^void dump_hash_results(char *name, int counts[NSERV][NSERV]) {$/;"	f
dump_hash_results	./tests/uri_hash.c	/^void dump_hash_results(char *name, int counts[NSERV][NSERV]) {$/;"	f
dump_pools	./src/memory.c	/^void dump_pools(void)$/;"	f
dump_pools_to_trash	./src/memory.c	/^void dump_pools_to_trash()$/;"	f
dump_servers_state	./src/dumpstats.c	/^static void dump_servers_state(struct proxy *backend, struct chunk *buf)$/;"	f	file:
dump_text	./src/dumpstats.c	/^static int dump_text(struct chunk *out, const char *buf, int bsize)$/;"	f	file:
dump_text_line	./src/dumpstats.c	/^static int dump_text_line(struct chunk *out, const char *buf, int bsize, int len,$/;"	f	file:
duration	./include/types/checks.h	/^	long duration;				\/* time in ms took to finish last health check *\/$/;"	m	struct:check
dynamic	./include/types/proxy.h	/^	int dynamic;				\/* this is a dynamic rule using the logformat expression *\/$/;"	m	struct:switching_rule
eb32_delete	./ebtree/eb32tree.h	/^static inline void eb32_delete(struct eb32_node *eb32)$/;"	f
eb32_entry	./ebtree/eb32tree.h	/^#define eb32_entry(/;"	d
eb32_first	./ebtree/eb32tree.h	/^static inline struct eb32_node *eb32_first(struct eb_root *root)$/;"	f
eb32_insert	./ebtree/eb32tree.c	/^REGPRM2 struct eb32_node *eb32_insert(struct eb_root *root, struct eb32_node *new)$/;"	f
eb32_last	./ebtree/eb32tree.h	/^static inline struct eb32_node *eb32_last(struct eb_root *root)$/;"	f
eb32_lookup	./ebtree/eb32tree.c	/^REGPRM2 struct eb32_node *eb32_lookup(struct eb_root *root, u32 x)$/;"	f
eb32_lookup_ge	./ebtree/eb32tree.c	/^REGPRM2 struct eb32_node *eb32_lookup_ge(struct eb_root *root, u32 x)$/;"	f
eb32_lookup_le	./ebtree/eb32tree.c	/^REGPRM2 struct eb32_node *eb32_lookup_le(struct eb_root *root, u32 x)$/;"	f
eb32_next	./ebtree/eb32tree.h	/^static inline struct eb32_node *eb32_next(struct eb32_node *eb32)$/;"	f
eb32_next_dup	./ebtree/eb32tree.h	/^static inline struct eb32_node *eb32_next_dup(struct eb32_node *eb32)$/;"	f
eb32_next_unique	./ebtree/eb32tree.h	/^static inline struct eb32_node *eb32_next_unique(struct eb32_node *eb32)$/;"	f
eb32_node	./ebtree/eb32tree.h	/^struct eb32_node {$/;"	s
eb32_prev	./ebtree/eb32tree.h	/^static inline struct eb32_node *eb32_prev(struct eb32_node *eb32)$/;"	f
eb32_prev_dup	./ebtree/eb32tree.h	/^static inline struct eb32_node *eb32_prev_dup(struct eb32_node *eb32)$/;"	f
eb32_prev_unique	./ebtree/eb32tree.h	/^static inline struct eb32_node *eb32_prev_unique(struct eb32_node *eb32)$/;"	f
eb32i_insert	./ebtree/eb32tree.c	/^REGPRM2 struct eb32_node *eb32i_insert(struct eb_root *root, struct eb32_node *new)$/;"	f
eb32i_lookup	./ebtree/eb32tree.c	/^REGPRM2 struct eb32_node *eb32i_lookup(struct eb_root *root, s32 x)$/;"	f
eb64_delete	./ebtree/eb64tree.h	/^static inline void eb64_delete(struct eb64_node *eb64)$/;"	f
eb64_entry	./ebtree/eb64tree.h	/^#define eb64_entry(/;"	d
eb64_first	./ebtree/eb64tree.h	/^static inline struct eb64_node *eb64_first(struct eb_root *root)$/;"	f
eb64_insert	./ebtree/eb64tree.c	/^REGPRM2 struct eb64_node *eb64_insert(struct eb_root *root, struct eb64_node *new)$/;"	f
eb64_last	./ebtree/eb64tree.h	/^static inline struct eb64_node *eb64_last(struct eb_root *root)$/;"	f
eb64_lookup	./ebtree/eb64tree.c	/^REGPRM2 struct eb64_node *eb64_lookup(struct eb_root *root, u64 x)$/;"	f
eb64_lookup_ge	./ebtree/eb64tree.c	/^REGPRM2 struct eb64_node *eb64_lookup_ge(struct eb_root *root, u64 x)$/;"	f
eb64_lookup_le	./ebtree/eb64tree.c	/^REGPRM2 struct eb64_node *eb64_lookup_le(struct eb_root *root, u64 x)$/;"	f
eb64_next	./ebtree/eb64tree.h	/^static inline struct eb64_node *eb64_next(struct eb64_node *eb64)$/;"	f
eb64_next_dup	./ebtree/eb64tree.h	/^static inline struct eb64_node *eb64_next_dup(struct eb64_node *eb64)$/;"	f
eb64_next_unique	./ebtree/eb64tree.h	/^static inline struct eb64_node *eb64_next_unique(struct eb64_node *eb64)$/;"	f
eb64_node	./ebtree/eb64tree.h	/^struct eb64_node {$/;"	s
eb64_prev	./ebtree/eb64tree.h	/^static inline struct eb64_node *eb64_prev(struct eb64_node *eb64)$/;"	f
eb64_prev_dup	./ebtree/eb64tree.h	/^static inline struct eb64_node *eb64_prev_dup(struct eb64_node *eb64)$/;"	f
eb64_prev_unique	./ebtree/eb64tree.h	/^static inline struct eb64_node *eb64_prev_unique(struct eb64_node *eb64)$/;"	f
eb64i_insert	./ebtree/eb64tree.c	/^REGPRM2 struct eb64_node *eb64i_insert(struct eb_root *root, struct eb64_node *new)$/;"	f
eb64i_lookup	./ebtree/eb64tree.c	/^REGPRM2 struct eb64_node *eb64i_lookup(struct eb_root *root, s64 x)$/;"	f
eb_clrtag	./ebtree/ebtree.h	/^static inline struct eb_root *eb_clrtag(const eb_troot_t *troot)$/;"	f
eb_delete	./ebtree/ebtree.c	/^void eb_delete(struct eb_node *node)$/;"	f
eb_dotag	./ebtree/ebtree.h	/^static inline eb_troot_t *eb_dotag(const struct eb_root *root, const int tag)$/;"	f
eb_entry	./ebtree/ebtree.h	/^#define eb_entry(/;"	d
eb_first	./ebtree/ebtree.h	/^static inline struct eb_node *eb_first(struct eb_root *root)$/;"	f
eb_gettag	./ebtree/ebtree.h	/^static inline int eb_gettag(eb_troot_t *troot)$/;"	f
eb_insert_dup	./ebtree/ebtree.c	/^REGPRM1 struct eb_node *eb_insert_dup(struct eb_node *sub, struct eb_node *new)$/;"	f
eb_is_dup	./ebtree/ebtree.h	/^static inline int eb_is_dup(struct eb_node *node)$/;"	f
eb_is_empty	./ebtree/ebtree.h	/^static inline int eb_is_empty(struct eb_root *root)$/;"	f
eb_last	./ebtree/ebtree.h	/^static inline struct eb_node *eb_last(struct eb_root *root)$/;"	f
eb_next	./ebtree/ebtree.h	/^static inline struct eb_node *eb_next(struct eb_node *node)$/;"	f
eb_next_dup	./ebtree/ebtree.h	/^static inline struct eb_node *eb_next_dup(struct eb_node *node)$/;"	f
eb_next_unique	./ebtree/ebtree.h	/^static inline struct eb_node *eb_next_unique(struct eb_node *node)$/;"	f
eb_node	./ebtree/ebtree.h	/^struct eb_node {$/;"	s
eb_prev	./ebtree/ebtree.h	/^static inline struct eb_node *eb_prev(struct eb_node *node)$/;"	f
eb_prev_dup	./ebtree/ebtree.h	/^static inline struct eb_node *eb_prev_dup(struct eb_node *node)$/;"	f
eb_prev_unique	./ebtree/ebtree.h	/^static inline struct eb_node *eb_prev_unique(struct eb_node *node)$/;"	f
eb_root	./ebtree/ebtree.h	/^struct eb_root {$/;"	s
eb_root_to_node	./ebtree/ebtree.h	/^static inline struct eb_node *eb_root_to_node(struct eb_root *root)$/;"	f
eb_troot_t	./ebtree/ebtree.h	/^typedef void eb_troot_t;$/;"	t
eb_untag	./ebtree/ebtree.h	/^static inline struct eb_root *eb_untag(const eb_troot_t *troot, const int tag)$/;"	f
eb_walk_down	./ebtree/ebtree.h	/^static inline struct eb_node *eb_walk_down(eb_troot_t *start, unsigned int side)$/;"	f
ebim_insert	./ebtree/ebimtree.c	/^ebim_insert(struct eb_root *root, struct ebpt_node *new, unsigned int len)$/;"	f
ebim_lookup	./ebtree/ebimtree.c	/^ebim_lookup(struct eb_root *root, const void *x, unsigned int len)$/;"	f
ebis_insert	./ebtree/ebistree.c	/^REGPRM2 struct ebpt_node *ebis_insert(struct eb_root *root, struct ebpt_node *new)$/;"	f
ebis_lookup	./ebtree/ebistree.c	/^REGPRM2 struct ebpt_node *ebis_lookup(struct eb_root *root, const char *x)$/;"	f
ebis_lookup_len	./ebtree/ebistree.h	/^ebis_lookup_len(struct eb_root *root, const char *x, unsigned int len)$/;"	f
ebmb_delete	./ebtree/ebmbtree.h	/^static forceinline void ebmb_delete(struct ebmb_node *ebmb)$/;"	f
ebmb_entry	./ebtree/ebmbtree.h	/^#define ebmb_entry(/;"	d
ebmb_first	./ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *ebmb_first(struct eb_root *root)$/;"	f
ebmb_insert	./ebtree/ebmbtree.c	/^ebmb_insert(struct eb_root *root, struct ebmb_node *new, unsigned int len)$/;"	f
ebmb_insert_prefix	./ebtree/ebmbtree.c	/^ebmb_insert_prefix(struct eb_root *root, struct ebmb_node *new, unsigned int len)$/;"	f
ebmb_last	./ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *ebmb_last(struct eb_root *root)$/;"	f
ebmb_lookup	./ebtree/ebmbtree.c	/^ebmb_lookup(struct eb_root *root, const void *x, unsigned int len)$/;"	f
ebmb_lookup_longest	./ebtree/ebmbtree.c	/^ebmb_lookup_longest(struct eb_root *root, const void *x)$/;"	f
ebmb_lookup_prefix	./ebtree/ebmbtree.c	/^ebmb_lookup_prefix(struct eb_root *root, const void *x, unsigned int pfx)$/;"	f
ebmb_next	./ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *ebmb_next(struct ebmb_node *ebmb)$/;"	f
ebmb_next_dup	./ebtree/ebmbtree.h	/^static inline struct ebmb_node *ebmb_next_dup(struct ebmb_node *ebmb)$/;"	f
ebmb_next_unique	./ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *ebmb_next_unique(struct ebmb_node *ebmb)$/;"	f
ebmb_node	./ebtree/ebmbtree.h	/^struct ebmb_node {$/;"	s
ebmb_prev	./ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *ebmb_prev(struct ebmb_node *ebmb)$/;"	f
ebmb_prev_dup	./ebtree/ebmbtree.h	/^static inline struct ebmb_node *ebmb_prev_dup(struct ebmb_node *ebmb)$/;"	f
ebmb_prev_unique	./ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *ebmb_prev_unique(struct ebmb_node *ebmb)$/;"	f
ebpt_delete	./ebtree/ebpttree.h	/^static forceinline void ebpt_delete(struct ebpt_node *ebpt)$/;"	f
ebpt_entry	./ebtree/ebpttree.h	/^#define ebpt_entry(/;"	d
ebpt_first	./ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_first(struct eb_root *root)$/;"	f
ebpt_insert	./ebtree/ebpttree.c	/^REGPRM2 struct ebpt_node *ebpt_insert(struct eb_root *root, struct ebpt_node *new)$/;"	f
ebpt_insert	./ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_insert(struct eb_root *root, struct ebpt_node *new)$/;"	f
ebpt_last	./ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_last(struct eb_root *root)$/;"	f
ebpt_lookup	./ebtree/ebpttree.c	/^REGPRM2 struct ebpt_node *ebpt_lookup(struct eb_root *root, void *x)$/;"	f
ebpt_lookup	./ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_lookup(struct eb_root *root, void *x)$/;"	f
ebpt_lookup_ge	./ebtree/ebpttree.c	/^REGPRM2 struct ebpt_node *ebpt_lookup_ge(struct eb_root *root, void *x)$/;"	f
ebpt_lookup_ge	./ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_lookup_ge(struct eb_root *root, void *x)$/;"	f
ebpt_lookup_le	./ebtree/ebpttree.c	/^REGPRM2 struct ebpt_node *ebpt_lookup_le(struct eb_root *root, void *x)$/;"	f
ebpt_lookup_le	./ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_lookup_le(struct eb_root *root, void *x)$/;"	f
ebpt_next	./ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_next(struct ebpt_node *ebpt)$/;"	f
ebpt_next_dup	./ebtree/ebpttree.h	/^static inline struct ebpt_node *ebpt_next_dup(struct ebpt_node *ebpt)$/;"	f
ebpt_next_unique	./ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_next_unique(struct ebpt_node *ebpt)$/;"	f
ebpt_node	./ebtree/ebpttree.h	/^struct ebpt_node {$/;"	s
ebpt_prev	./ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_prev(struct ebpt_node *ebpt)$/;"	f
ebpt_prev_dup	./ebtree/ebpttree.h	/^static inline struct ebpt_node *ebpt_prev_dup(struct ebpt_node *ebpt)$/;"	f
ebpt_prev_unique	./ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_prev_unique(struct ebpt_node *ebpt)$/;"	f
ebst_insert	./ebtree/ebsttree.c	/^REGPRM2 struct ebmb_node *ebst_insert(struct eb_root *root, struct ebmb_node *new)$/;"	f
ebst_lookup	./ebtree/ebsttree.c	/^REGPRM2 struct ebmb_node *ebst_lookup(struct eb_root *root, const char *x)$/;"	f
ebst_lookup_len	./ebtree/ebsttree.h	/^ebst_lookup_len(struct eb_root *root, const char *x, unsigned int len)$/;"	f
ecdhe	./include/types/listener.h	/^	char *ecdhe;               \/* named curve to use for ECDHE *\/$/;"	m	struct:bind_conf
elt	./include/types/applet.h	/^			struct pat_ref_elt *elt;$/;"	m	struct:appctx::__anon21::__anon28	typeref:struct:appctx::__anon21::__anon28::pat_ref_elt
email_alert	./include/types/proxy.h	/^	} email_alert;$/;"	m	struct:proxy	typeref:struct:proxy::__anon110
email_alert	./include/types/proxy.h	/^struct email_alert {$/;"	s
email_alert_free	./src/checks.c	/^void email_alert_free(struct email_alert *alert)$/;"	f
email_alertq	./include/types/proxy.h	/^struct email_alertq {$/;"	s
email_alerts	./include/types/proxy.h	/^	struct list email_alerts;$/;"	m	struct:email_alertq	typeref:struct:email_alertq::list
emit_hex	./src/trace.c	/^static char *emit_hex(unsigned long h, char *out)$/;"	f	file:
empty_arg_list	./src/arg.c	/^struct arg empty_arg_list[ARGM_NBARGS] = { };$/;"	v	typeref:struct:arg
enable_all	./include/types/protocol.h	/^	int (*enable_all)(struct protocol *proto);	\/* enable all bound listeners *\/$/;"	m	struct:protocol
enable_all_listeners	./src/listener.c	/^int enable_all_listeners(struct protocol *proto)$/;"	f
enable_listener	./src/listener.c	/^void enable_listener(struct listener *listener)$/;"	f
encode_chunk	./src/standard.c	/^char *encode_chunk(char *start, char *stop,$/;"	f
encode_string	./src/standard.c	/^char *encode_string(char *start, char *stop,$/;"	f
end	./include/types/compression.h	/^	int (*end)(struct comp_ctx **comp_ctx);$/;"	m	struct:comp_algo
end	./include/types/stream_interface.h	/^	enum obj_type *end;     \/* points to the end point (connection or appctx) *\/$/;"	m	struct:stream_interface	typeref:enum:stream_interface::obj_type
enqueue_email_alert	./src/checks.c	/^static void enqueue_email_alert(struct proxy *p, const char *msg)$/;"	f	file:
enqueue_one_email_alert	./src/checks.c	/^static int enqueue_one_email_alert(struct email_alertq *q, const char *msg)$/;"	f	file:
entry	./include/types/applet.h	/^			struct stksess *entry;	\/* last entry we were trying to dump (or first if NULL) *\/$/;"	m	struct:appctx::__anon21::__anon25	typeref:struct:appctx::__anon21::__anon25::stksess
entry	./include/types/stick_table.h	/^	unsigned long   entry;          \/* entry containing counters currently being tracked by this stream  *\/$/;"	m	struct:stkctr
env_expand	./src/standard.c	/^char *env_expand(char *in)$/;"	f
envp	./include/types/checks.h	/^	char **envp;				\/* the environment to use if running a process-based check *\/$/;"	m	struct:check
eoh	./include/types/proto_http.h	/^	unsigned int eoh;                      \/* End Of Headers, relative to buffer *\/$/;"	m	struct:http_msg
eol	./include/types/proto_http.h	/^	unsigned int eol;                      \/* end of line *\/$/;"	m	struct:http_msg
eol	./src/shctx.c	/^	unsigned int eol;$/;"	m	struct:shsess_packet_hdr	file:
epoll_event	./include/common/epoll.h	/^struct epoll_event {$/;"	s
epoll_events	./src/ev_epoll.c	/^static struct epoll_event *epoll_events;$/;"	v	typeref:struct:epoll_event	file:
epoll_fd	./src/ev_epoll.c	/^static int epoll_fd;$/;"	v	file:
equal_bits	./ebtree/ebtree.h	/^static forceinline int equal_bits(const unsigned char *a,$/;"	f
err	./include/types/applet.h	/^			char *err;        \/* pointer to a 'must free' message to be returned in PRINT_FREE state *\/$/;"	m	struct:appctx::__anon21::__anon26
err_code	./include/types/connection.h	/^	unsigned char err_code;       \/* CO_ER_* *\/$/;"	m	struct:connection
err_pos	./include/types/proto_http.h	/^	int err_pos;                           \/* err handling: -2=block, -1=pass, 0+=detected *\/$/;"	m	struct:http_msg
err_type	./include/types/stream_interface.h	/^	unsigned int err_type;  \/* first error detected, one of SI_ET_* *\/$/;"	m	struct:stream_interface
errmsg	./include/types/proxy.h	/^	struct chunk errmsg[HTTP_ERR_SIZE];	\/* default or customized error messages for known errors *\/$/;"	m	struct:proxy	typeref:struct:proxy::chunk
error_500	./src/hlua.c	/^static const char error_500[] =$/;"	v	file:
error_snapshot	./include/types/proxy.h	/^struct error_snapshot {$/;"	s
error_snapshot_id	./src/proxy.c	/^unsigned int error_snapshot_id = 0;     \/* global ID assigned to each error then incremented *\/$/;"	v
errors	./include/types/applet.h	/^		} errors;$/;"	m	union:appctx::__anon21	typeref:struct:appctx::__anon21::__anon24
ev	./include/types/fd.h	/^	unsigned char ev;                    \/* event seen in return of poll() : FD_POLL_* *\/$/;"	m	struct:fdtab
ev	./src/ev_epoll.c	/^static struct epoll_event ev;$/;"	v	typeref:struct:epoll_event	file:
ev_id	./include/types/proxy.h	/^	unsigned int ev_id;		\/* event number (counter incremented for each capture) *\/$/;"	m	struct:error_snapshot
event_srv_chk_r	./src/checks.c	/^static void event_srv_chk_r(struct connection *conn)$/;"	f	file:
event_srv_chk_w	./src/checks.c	/^static void event_srv_chk_w(struct connection *conn)$/;"	f	file:
events	./include/common/epoll.h	/^	uint32_t events;$/;"	m	struct:epoll_event
eweight	./include/types/server.h	/^	unsigned iweight,uweight, eweight;	\/* initial weight, user-specified weight, and effective weight *\/$/;"	m	struct:server
except_mask	./include/types/proxy.h	/^	struct in_addr except_net, except_mask; \/* don't x-forward-for for this address. FIXME: should support IPv6 *\/$/;"	m	struct:proxy	typeref:struct:proxy::
except_mask_to	./include/types/proxy.h	/^	struct in_addr except_mask_to;		\/* the netmask for except_to. *\/$/;"	m	struct:proxy	typeref:struct:proxy::in_addr
except_net	./include/types/proxy.h	/^	struct in_addr except_net, except_mask; \/* don't x-forward-for for this address. FIXME: should support IPv6 *\/$/;"	m	struct:proxy	typeref:struct:proxy::in_addr
except_to	./include/types/proxy.h	/^	struct in_addr except_to;		\/* don't x-original-to for this address. *\/$/;"	m	struct:proxy	typeref:struct:proxy::in_addr
exclude_patterns	./doc/lua-api/conf.py	/^exclude_patterns = ['_build']$/;"	v
exited	./include/types/server.h	/^	int exited;$/;"	m	struct:pid_list
exp	./include/types/stick_table.h	/^	struct eb32_node exp;     \/* ebtree node used to hold the session in expiration tree *\/$/;"	m	struct:stksess	typeref:struct:stksess::eb32_node
exp	./include/types/stream_interface.h	/^	unsigned int exp;       \/* wake up time for connect, queue, turn-around, ... *\/$/;"	m	struct:stream_interface
exp_next	./include/types/stick_table.h	/^	int exp_next;             \/* next expiration date (ticks) *\/$/;"	m	struct:stktable
exp_replace	./src/regex.c	/^int exp_replace(char *dst, unsigned int dst_size, char *src, const char *str, const regmatch_t *matches)$/;"	f
exp_task	./include/types/stick_table.h	/^	struct task *exp_task;    \/* expiration task *\/$/;"	m	struct:stktable	typeref:struct:stktable::task
expect_frontend_admin	./src/dumpstats.c	/^static struct proxy *expect_frontend_admin(struct stream *s, struct stream_interface *si, const char *arg)$/;"	f	file:
expect_regex	./include/types/checks.h	/^	struct my_regex *expect_regex;          \/* expected *\/$/;"	m	struct:tcpcheck_rule	typeref:struct:tcpcheck_rule::my_regex
expect_regex	./include/types/proxy.h	/^	struct my_regex *expect_regex;		\/* http-check expected content *\/$/;"	m	struct:proxy	typeref:struct:proxy::my_regex
expect_server_admin	./src/dumpstats.c	/^static struct server *expect_server_admin(struct stream *s, struct stream_interface *si, char *arg)$/;"	f	file:
expect_str	./include/types/proxy.h	/^	char *expect_str;			\/* http-check expected content : string or text version of the regex *\/$/;"	m	struct:proxy
expect_type	./include/types/pattern.h	/^	int expect_type; \/* type of the expected sample (SMP_T_*) *\/$/;"	m	struct:pattern_head
expire	./include/types/stick_table.h	/^	int expire;               \/* time to live for sticky sessions (milliseconds) *\/$/;"	m	struct:stktable
expire	./include/types/stick_table.h	/^	unsigned int expire;      \/* session expiration date *\/$/;"	m	struct:stksess
expire	./include/types/task.h	/^	int expire;			\/* next expiration date for this task, in ticks *\/$/;"	m	struct:task
expire	./src/ssl_sock.c	/^	long expire;$/;"	m	struct:certificate_ocsp	file:
expr	./include/types/acl.h	/^	struct list expr;	    \/* list of acl_exprs *\/$/;"	m	struct:acl	typeref:struct:acl::list
expr	./include/types/action.h	/^			struct sample_expr *expr; \/* expression used as the key *\/$/;"	m	struct:act_rule::__anon9::__anon14	typeref:struct:act_rule::__anon9::__anon14::sample_expr
expr	./include/types/action.h	/^			struct sample_expr *expr;$/;"	m	struct:act_rule::__anon9::__anon16	typeref:struct:act_rule::__anon9::__anon16::sample_expr
expr	./include/types/action.h	/^			struct sample_expr *expr;$/;"	m	struct:act_rule::__anon9::__anon17	typeref:struct:act_rule::__anon9::__anon17::sample_expr
expr	./include/types/action.h	/^		struct sample_expr *expr;$/;"	m	union:act_rule::__anon9	typeref:struct:act_rule::__anon9::sample_expr
expr	./include/types/applet.h	/^			struct pattern_expr *expr;$/;"	m	struct:appctx::__anon21::__anon28	typeref:struct:appctx::__anon21::__anon28::pattern_expr
expr	./include/types/log.h	/^	void *expr;    \/\/ for use with LOG_FMT_EXPR$/;"	m	struct:logformat_node
expr	./include/types/pattern.h	/^	struct pattern_expr *expr; \/* The used expr. *\/$/;"	m	struct:pattern_expr_list	typeref:struct:pattern_expr_list::pattern_expr
expr	./include/types/proxy.h	/^		struct list expr;		\/* logformat expression to use for dynamic rules *\/$/;"	m	union:switching_rule::__anon112	typeref:struct:switching_rule::__anon112::list
expr	./include/types/proxy.h	/^	struct sample_expr *expr;               \/* fetch expr to fetch key *\/$/;"	m	struct:sticking_rule	typeref:struct:sticking_rule::sample_expr
expr	./include/types/stick_table.h	/^	struct sample_expr *expr;		\/* expression used as the key *\/$/;"	m	struct:track_ctr_prm	typeref:struct:track_ctr_prm::sample_expr
expr	./src/acl.c	/^	const char *expr[4]; \/* put enough for longest expression *\/$/;"	m	struct:__anon133	file:
exps	./include/types/stick_table.h	/^	struct eb_root exps;      \/* head of sticky session expiration tree *\/$/;"	m	struct:stktable	typeref:struct:stktable::eb_root
extcheck_env	./include/types/checks.h	/^struct extcheck_env {$/;"	s
extcheck_envs	./src/checks.c	/^const struct extcheck_env extcheck_envs[EXTCHK_SIZE] = {$/;"	v	typeref:struct:extcheck_env
extchk_setenv	./src/checks.c	/^static int extchk_setenv(struct check *check, int idx, const char *value)$/;"	f	file:
extensions	./doc/lua-api/conf.py	/^extensions = []$/;"	v
external_check	./include/types/global.h	/^	int external_check;$/;"	m	struct:global
extra	./include/common/regex.h	/^	pcre_extra *extra;$/;"	m	struct:my_regex
extract_cookie_value	./src/proto_http.c	/^extract_cookie_value(char *hdr, const char *hdr_end,$/;"	f
facility	./include/types/log.h	/^	int facility;$/;"	m	struct:logsrv
failed_checks	./include/types/counters.h	/^	long long failed_checks, failed_hana;	\/* failed health checks and health analyses *\/$/;"	m	struct:srvcounters
failed_conns	./include/types/counters.h	/^	long long failed_conns, failed_resp;	\/* failed connect() and responses *\/$/;"	m	struct:srvcounters
failed_conns	./include/types/counters.h	/^	long long failed_conns;                 \/* failed connect() attempts (BE only) *\/$/;"	m	struct:pxcounters
failed_hana	./include/types/counters.h	/^	long long failed_checks, failed_hana;	\/* failed health checks and health analyses *\/$/;"	m	struct:srvcounters
failed_req	./include/types/counters.h	/^	long long failed_req;			\/* failed requests (eg: invalid or timeout) *\/$/;"	m	struct:licounters
failed_req	./include/types/counters.h	/^	long long failed_req;                   \/* failed requests (eg: invalid or timeout) *\/$/;"	m	struct:pxcounters
failed_resp	./include/types/counters.h	/^	long long failed_conns, failed_resp;	\/* failed connect() and responses *\/$/;"	m	struct:srvcounters
failed_resp	./include/types/counters.h	/^	long long failed_resp;                  \/* failed responses (BE only) *\/$/;"	m	struct:pxcounters
failed_secu	./include/types/counters.h	/^	long long failed_secu;			\/* blocked responses because of security concerns *\/$/;"	m	struct:srvcounters
fall	./include/types/checks.h	/^	int rise, fall;				\/* time in iterations *\/$/;"	m	struct:check
fam	./include/types/connection.h	/^	uint8_t fam;       \/* protocol family and transport *\/$/;"	m	struct:proxy_hdr_v2
fas	./include/types/backend.h	/^	struct lb_fas fas;$/;"	m	struct:lbprm	typeref:struct:lbprm::lb_fas
fas_dequeue_srv	./src/lb_fas.c	/^static inline void fas_dequeue_srv(struct server *s)$/;"	f	file:
fas_get_next_server	./src/lb_fas.c	/^struct server *fas_get_next_server(struct proxy *p, struct server *srvtoavoid)$/;"	f
fas_init_server_tree	./src/lb_fas.c	/^void fas_init_server_tree(struct proxy *p)$/;"	f
fas_queue_srv	./src/lb_fas.c	/^static inline void fas_queue_srv(struct server *s)$/;"	f	file:
fas_remove_from_tree	./src/lb_fas.c	/^static inline void fas_remove_from_tree(struct server *s)$/;"	f	file:
fas_set_server_status_down	./src/lb_fas.c	/^static void fas_set_server_status_down(struct server *srv)$/;"	f	file:
fas_set_server_status_up	./src/lb_fas.c	/^static void fas_set_server_status_up(struct server *srv)$/;"	f	file:
fas_srv_reposition	./src/lb_fas.c	/^static void fas_srv_reposition(struct server *s)$/;"	f	file:
fas_update_server_weight	./src/lb_fas.c	/^static void fas_update_server_weight(struct server *srv)$/;"	f	file:
fast_time	./src/trace.c	/^static int fast_time;$/;"	v	file:
fastinter	./include/types/checks.h	/^	int inter, fastinter, downinter;        \/* checks: time in milliseconds *\/$/;"	m	struct:check
fbck	./include/types/backend.h	/^	struct server *fbck;		\/* first backup server when !PR_O_USE_ALL_BK, or NULL *\/$/;"	m	struct:lbprm	typeref:struct:lbprm::server
fcn	./include/types/hlua.h	/^	struct hlua_function fcn;$/;"	m	struct:hlua_rule	typeref:struct:hlua_rule::hlua_function
fct	./include/types/applet.h	/^	void (*fct)(struct appctx *);      \/* internal I\/O handler, may never be NULL *\/$/;"	m	struct:applet
fd	./include/common/epoll.h	/^		int fd;$/;"	m	union:epoll_event::__anon2
fd	./include/common/namespace.h	/^	int fd;$/;"	m	struct:netns_entry
fd	./include/types/connection.h	/^			int fd;       \/* file descriptor for a stream driver when known *\/$/;"	m	struct:connection::__anon50::__anon51
fd	./include/types/listener.h	/^	int fd;				\/* the listen socket *\/$/;"	m	struct:listener
fd	./include/types/proto_udp.h	/^			int fd;			\/* file descriptor *\/$/;"	m	struct:dgram_conn::__anon102::__anon103
fd_alloc_cache_entry	./include/proto/fd.h	/^static inline void fd_alloc_cache_entry(const int fd)$/;"	f
fd_cache	./src/fd.c	/^unsigned int *fd_cache = NULL; \/\/ FD events cache$/;"	v
fd_cache_num	./src/fd.c	/^int fd_cache_num = 0;          \/\/ number of events in the cache$/;"	v
fd_cant_recv	./include/proto/fd.h	/^static inline void fd_cant_recv(const int fd)$/;"	f
fd_cant_send	./include/proto/fd.h	/^static inline void fd_cant_send(const int fd)$/;"	f
fd_compute_new_polled_status	./include/proto/fd.h	/^static inline int fd_compute_new_polled_status(int state)$/;"	f
fd_delete	./src/fd.c	/^void fd_delete(int fd)$/;"	f
fd_done_recv	./include/proto/fd.h	/^static inline void fd_done_recv(const int fd)$/;"	f
fd_evts	./src/ev_poll.c	/^static unsigned int *fd_evts[2];$/;"	v	file:
fd_evts	./src/ev_select.c	/^static fd_set *fd_evts[2];$/;"	v	file:
fd_insert	./include/proto/fd.h	/^static inline void fd_insert(int fd)$/;"	f
fd_may_recv	./include/proto/fd.h	/^static inline void fd_may_recv(const int fd)$/;"	f
fd_may_send	./include/proto/fd.h	/^static inline void fd_may_send(const int fd)$/;"	f
fd_nbupdt	./src/fd.c	/^int fd_nbupdt = 0;             \/\/ number of updates in the list$/;"	v
fd_process_cached_events	./src/fd.c	/^void fd_process_cached_events()$/;"	f
fd_recv_active	./include/proto/fd.h	/^static inline int fd_recv_active(const int fd)$/;"	f
fd_recv_polled	./include/proto/fd.h	/^static inline int fd_recv_polled(const int fd)$/;"	f
fd_recv_ready	./include/proto/fd.h	/^static inline int fd_recv_ready(const int fd)$/;"	f
fd_recv_state	./include/proto/fd.h	/^static inline int fd_recv_state(const int fd)$/;"	f
fd_release_cache_entry	./include/proto/fd.h	/^static inline void fd_release_cache_entry(int fd)$/;"	f
fd_send_active	./include/proto/fd.h	/^static inline int fd_send_active(const int fd)$/;"	f
fd_send_polled	./include/proto/fd.h	/^static inline int fd_send_polled(const int fd)$/;"	f
fd_send_ready	./include/proto/fd.h	/^static inline int fd_send_ready(const int fd)$/;"	f
fd_send_state	./include/proto/fd.h	/^static inline int fd_send_state(const int fd)$/;"	f
fd_states	./include/types/fd.h	/^enum fd_states {$/;"	g
fd_stop_both	./include/proto/fd.h	/^static inline void fd_stop_both(int fd)$/;"	f
fd_stop_recv	./include/proto/fd.h	/^static inline void fd_stop_recv(int fd)$/;"	f
fd_stop_send	./include/proto/fd.h	/^static inline void fd_stop_send(int fd)$/;"	f
fd_update_cache	./include/proto/fd.h	/^static inline void fd_update_cache(int fd)$/;"	f
fd_updt	./src/fd.c	/^unsigned int *fd_updt = NULL;  \/\/ FD updates list$/;"	v
fd_want_recv	./include/proto/fd.h	/^static inline void fd_want_recv(int fd)$/;"	f
fd_want_send	./include/proto/fd.h	/^static inline void fd_want_send(int fd)$/;"	f
fddebug	./include/common/standard.h	/^#define fddebug(/;"	d
fdinfo	./include/types/fd.h	/^struct fdinfo {$/;"	s
fdinfo	./src/fd.c	/^struct fdinfo *fdinfo = NULL;   \/* less-often used infos for file descriptors *\/$/;"	v	typeref:struct:fdinfo
fdtab	./include/types/fd.h	/^struct fdtab {$/;"	s
fdtab	./src/fd.c	/^struct fdtab *fdtab = NULL;     \/* array of all the file descriptors *\/$/;"	v	typeref:struct:fdtab
fe	./include/types/session.h	/^	struct proxy *fe;               \/* the proxy this session depends on for the client side *\/$/;"	m	struct:session	typeref:struct:session::proxy
fe_conn_per_sec	./include/types/proxy.h	/^	struct freq_ctr fe_conn_per_sec;	\/* received connections per second on the frontend *\/$/;"	m	struct:proxy	typeref:struct:proxy::freq_ctr
fe_counters	./include/types/proxy.h	/^	struct pxcounters fe_counters;		\/* frontend statistics counters *\/$/;"	m	struct:proxy	typeref:struct:proxy::pxcounters
fe_req_ana	./include/types/proxy.h	/^	unsigned int fe_req_ana, be_req_ana;	\/* bitmap of common request protocol analysers for the frontend and backend *\/$/;"	m	struct:proxy
fe_req_per_sec	./include/types/proxy.h	/^	struct freq_ctr fe_req_per_sec;		\/* HTTP requests per second on the frontend *\/$/;"	m	struct:proxy	typeref:struct:proxy::freq_ctr
fe_rsp_ana	./include/types/proxy.h	/^	unsigned int fe_rsp_ana, be_rsp_ana;	\/* bitmap of common response protocol analysers for the frontend and backend *\/$/;"	m	struct:proxy
fe_sess_per_sec	./include/types/proxy.h	/^	struct freq_ctr fe_sess_per_sec;	\/* accepted sessions per second on the frontend (after tcp rules) *\/$/;"	m	struct:proxy	typeref:struct:proxy::freq_ctr
fe_sps_lim	./include/types/proxy.h	/^	unsigned int fe_sps_lim;		\/* limit on new sessions per second on the frontend *\/$/;"	m	struct:proxy
feconn	./include/types/proxy.h	/^	unsigned int feconn, beconn;		\/* # of active frontend and backends streams *\/$/;"	m	struct:proxy
fetch	./include/types/sample.h	/^	struct sample_fetch *fetch;               \/* sample fetch method *\/$/;"	m	struct:sample_expr	typeref:struct:sample_expr::sample_fetch
fetch_cap	./src/sample.c	/^const unsigned int fetch_cap[SMP_SRC_ENTRIES] = {$/;"	v
fetch_ckp_names	./src/sample.c	/^static const char *fetch_ckp_names[SMP_CKP_ENTRIES] = {$/;"	v	file:
fetch_kw	./include/types/acl.h	/^	char *fetch_kw;$/;"	m	struct:acl_keyword
fetch_kws	./src/da.c	/^static struct sample_fetch_kw_list fetch_kws = {ILH, {$/;"	v	typeref:struct:sample_fetch_kw_list	file:
fetch_rdp_cookie_name	./src/payload.c	/^fetch_rdp_cookie_name(struct stream *s, struct sample *smp, const char *cname, int clen)$/;"	f
fetch_src_names	./src/sample.c	/^static const char *fetch_src_names[SMP_SRC_ENTRIES] = {$/;"	v	file:
fgets2	./contrib/halog/fgets2.c	/^const char *fgets2(FILE *stream)$/;"	f
field_start	./contrib/halog/halog.c	/^const char *field_start(const char *p, int field)$/;"	f
field_stop	./contrib/halog/halog.c	/^const char *field_stop(const char *p)$/;"	f
field_stop	./contrib/halog/halog.c	/^static inline const char *field_stop(const char *p)$/;"	f	file:
file	./include/types/acl.h	/^	const char *file;           \/* config file where the condition is declared *\/$/;"	m	struct:acl_cond
file	./include/types/arg.h	/^	const char *file;         \/* file name where the args are referenced *\/$/;"	m	struct:arg_list
file	./include/types/dns.h	/^		const char *file;	\/* file where the section appears *\/$/;"	m	struct:dns_nameserver::__anon64
file	./include/types/dns.h	/^		const char *file;	\/* file where the section appears *\/$/;"	m	struct:dns_resolvers::__anon61
file	./include/types/listener.h	/^	char *file;                \/* file where the section appears *\/$/;"	m	struct:bind_conf
file	./include/types/mailers.h	/^		const char *file;	\/* file where the section appears *\/$/;"	m	struct:mailer::__anon82
file	./include/types/mailers.h	/^		const char *file;	\/* file where the section appears *\/$/;"	m	struct:mailers::__anon83
file	./include/types/peers.h	/^		const char *file;	 \/* file where the section appears *\/$/;"	m	struct:peers::__anon93
file	./include/types/peers.h	/^		const char *file; \/* file where the section appears *\/$/;"	m	struct:peer::__anon92
file	./include/types/proxy.h	/^		char *file;			\/* file where the section appears *\/$/;"	m	struct:proxy::__anon109
file	./include/types/server.h	/^		const char *file;		\/* file where the section appears *\/$/;"	m	struct:server::__anon123
filename	./include/types/ssl_sock.h	/^	char *filename;$/;"	m	struct:tls_keys_ref
filter	./contrib/halog/halog.c	/^unsigned int filter = 0;$/;"	v
filter2	./contrib/halog/halog.c	/^unsigned int filter2 = 0;$/;"	v
filter_accept_holes	./contrib/halog/halog.c	/^void filter_accept_holes(const char *accept_field, const char *time_field, struct timer **tptr)$/;"	f
filter_count_cook_codes	./contrib/halog/halog.c	/^void filter_count_cook_codes(const char *accept_field, const char *time_field, struct timer **tptr)$/;"	f
filter_count_ip	./contrib/halog/halog.c	/^void filter_count_ip(const char *source_field, const char *accept_field, const char *time_field, struct timer **tptr)$/;"	f
filter_count_srv_status	./contrib/halog/halog.c	/^void filter_count_srv_status(const char *accept_field, const char *time_field, struct timer **tptr)$/;"	f
filter_count_status	./contrib/halog/halog.c	/^void filter_count_status(const char *accept_field, const char *time_field, struct timer **tptr)$/;"	f
filter_count_term_codes	./contrib/halog/halog.c	/^void filter_count_term_codes(const char *accept_field, const char *time_field, struct timer **tptr)$/;"	f
filter_count_url	./contrib/halog/halog.c	/^void filter_count_url(const char *accept_field, const char *time_field, struct timer **tptr)$/;"	f
filter_graphs	./contrib/halog/halog.c	/^void filter_graphs(const char *accept_field, const char *time_field, struct timer **tptr)$/;"	f
filter_invert	./contrib/halog/halog.c	/^unsigned int filter_invert = 0;$/;"	v
filter_output_line	./contrib/halog/halog.c	/^void filter_output_line(const char *accept_field, const char *time_field, struct timer **tptr)$/;"	f
final	./src/shctx.c	/^	unsigned char final:1;$/;"	m	struct:shsess_packet_hdr	file:
final	./tests/test_hashes.c	/^#define final(/;"	d	file:
find_acl_by_name	./src/acl.c	/^struct acl *find_acl_by_name(const char *name, struct list *head)$/;"	f
find_acl_default	./src/acl.c	/^static struct acl *find_acl_default(const char *acl_name, struct list *known_acl,$/;"	f	file:
find_acl_kw	./src/acl.c	/^struct acl_keyword *find_acl_kw(const char *kw)$/;"	f
find_cookie_value_end	./src/proto_http.c	/^char *find_cookie_value_end(char *s, const char *e)$/;"	f
find_hdr_value_end	./src/proto_http.c	/^char *find_hdr_value_end(char *s, const char *e)$/;"	f
find_http_meth	./src/proto_http.c	/^enum http_meth_t find_http_meth(const char *str, const int len)$/;"	f
find_lf	./contrib/halog/fgets2.c	/^static char *find_lf(char *next, char *end)$/;"	f	file:
find_next_stat_id	./contrib/netsnmp-perl/haproxy.pl	/^sub find_next_stat_id {$/;"	s
find_next_url_param	./src/proto_http.c	/^find_next_url_param(const char **chunks,$/;"	f	file:
find_param_list	./src/proto_http.c	/^static inline char *find_param_list(char *path, size_t path_l, char delim)$/;"	f	file:
find_sample_conv	./src/sample.c	/^struct sample_conv *find_sample_conv(const char *kw, int len)$/;"	f
find_sample_fetch	./src/sample.c	/^struct sample_fetch *find_sample_fetch(const char *kw, int len)$/;"	f
find_url_param_pos	./src/proto_http.c	/^find_url_param_pos(const char **chunks,$/;"	f	file:
findserver	./src/proxy.c	/^struct server *findserver(const struct proxy *px, const char *name) {$/;"	f
finish	./include/types/compression.h	/^	int (*finish)(struct comp_ctx *comp_ctx, struct buffer *out);$/;"	m	struct:comp_algo
fix_pointer_if_wrap	./src/proto_http.c	/^static inline int fix_pointer_if_wrap(const char **chunks, const char **ptr)$/;"	f	file:
flags	./include/common/memory.h	/^	unsigned int flags;	\/* MEM_F_* *\/$/;"	m	struct:pool_head
flags	./include/common/uri_auth.h	/^	int flags;			\/* some flags describing the statistics page *\/$/;"	m	struct:uri_auth
flags	./include/types/applet.h	/^			int flags;$/;"	m	struct:appctx::__anon21::__anon31
flags	./include/types/applet.h	/^			int flags;$/;"	m	struct:appctx::__anon21::__anon32
flags	./include/types/applet.h	/^			unsigned int flags;	\/* STAT_* *\/$/;"	m	struct:appctx::__anon21::__anon22
flags	./include/types/auth.h	/^	unsigned int flags;$/;"	m	struct:auth_users
flags	./include/types/channel.h	/^	unsigned int flags;             \/* CF_* *\/$/;"	m	struct:channel
flags	./include/types/connection.h	/^	unsigned int flags;           \/* CO_FL_* *\/$/;"	m	struct:connection
flags	./include/types/hlua.h	/^	unsigned int flags;     \/* LUA_F_OPT_* *\/$/;"	m	struct:hlua_smp
flags	./include/types/hlua.h	/^	unsigned int flags; \/* The current execution flags. *\/$/;"	m	struct:hlua
flags	./include/types/pattern.h	/^	unsigned int flags; \/* flags PAT_REF_*. *\/$/;"	m	struct:pat_ref
flags	./include/types/peers.h	/^	int flags;$/;"	m	struct:shared_table
flags	./include/types/peers.h	/^	unsigned int flags;		 \/* current peers section resync state *\/$/;"	m	struct:peers
flags	./include/types/peers.h	/^	unsigned int flags; 	      \/* peer session flags *\/$/;"	m	struct:peer
flags	./include/types/proto_http.h	/^	unsigned char flags;                   \/* flags describing the message (HTTP version, ...) *\/$/;"	m	struct:http_msg
flags	./include/types/proto_http.h	/^	unsigned int flags;             \/* transaction flags *\/$/;"	m	struct:http_txn
flags	./include/types/proxy.h	/^	int flags;                              \/* STK_* *\/$/;"	m	struct:sticking_rule
flags	./include/types/proxy.h	/^	unsigned int flags;$/;"	m	struct:redirect_rule
flags	./include/types/sample.h	/^	unsigned int flags;       \/* SMP_F_* *\/$/;"	m	struct:sample
flags	./include/types/server.h	/^	unsigned char flags;                    \/* server flags (SRV_F_*) *\/$/;"	m	struct:server
flags	./include/types/signal.h	/^	int flags;                      \/* SIG_F_* *\/$/;"	m	struct:sig_handler
flags	./include/types/stick_table.h	/^	int flags;                \/* type flags *\/$/;"	m	struct:stktable_type
flags	./include/types/stream.h	/^	int flags;                      \/* some flags describing the stream *\/$/;"	m	struct:stream
flags	./include/types/stream_interface.h	/^	unsigned short flags;    \/* SI_FL_* *\/$/;"	m	struct:stream_interface
fls64	./ebtree/ebtree.h	/^static inline int fls64(unsigned long long x)$/;"	f
fls_auto	./ebtree/ebtree.h	/^#define fls_auto(/;"	d
flsnz	./ebtree/ebtree.h	/^#define flsnz(/;"	d
flsnz	./ebtree/ebtree.h	/^static inline int flsnz(int x)$/;"	f
flsnz8	./ebtree/ebtree.h	/^static inline int flsnz8(unsigned char x)$/;"	f
flsnz8	./ebtree/ebtree.h	/^static inline int flsnz8(unsigned int x)$/;"	f
flsnz8_generic	./ebtree/ebtree.h	/^static inline int flsnz8_generic(unsigned int x)$/;"	f
flush	./include/types/compression.h	/^	int (*flush)(struct comp_ctx *comp_ctx, struct buffer *out);$/;"	m	struct:comp_algo
fmt	./include/types/action.h	/^			struct list fmt;       \/* log-format compatible expression *\/$/;"	m	struct:act_rule::__anon9::__anon11	typeref:struct:act_rule::__anon9::__anon11::list
fmt_directive	./src/log.c	/^static inline const char *fmt_directive(const struct proxy *curproxy)$/;"	f	file:
fnv_32a_str	./tests/test_hashes.c	/^fnv_32a_str(char *str, Fnv32_t hval)$/;"	f
fnv_hash	./tests/test_hashes.c	/^unsigned fnv_hash ( void *key, int len )$/;"	f
forceinline	./include/common/compiler.h	/^#define forceinline /;"	d
fork	./include/types/fd.h	/^	int  REGPRM1   (*fork)(struct poller *p);            \/* post-fork re-opening *\/$/;"	m	struct:poller
fork_poller	./src/fd.c	/^int fork_poller()$/;"	f
format	./include/types/log.h	/^	int format;$/;"	m	struct:logsrv
format_unique_id	./include/types/proxy.h	/^	struct list format_unique_id;		\/* unique-id format *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
free	./include/import/lru.h	/^	void (*free)(void *data);     \/* function to release data, if needed *\/$/;"	m	struct:lru64
free	./src/shctx.c	/^	struct shared_block free;$/;"	m	struct:shared_context	typeref:struct:shared_context::shared_block	file:
free_check	./src/checks.c	/^void free_check(struct check *check)$/;"	f
free_email_alert	./src/cfgparse.c	/^static void free_email_alert(struct proxy *p)$/;"	f	file:
free_func	./src/compression.c	/^#define free_func /;"	d	file:
free_func	./src/compression.c	/^#undef free_func$/;"	d	file:
free_http_req_rules	./src/proto_http.c	/^void free_http_req_rules(struct list *r)$/;"	f
free_http_res_rules	./src/proto_http.c	/^void free_http_res_rules(struct list *r)$/;"	f
free_list	./include/common/memory.h	/^	void **free_list;$/;"	m	struct:pool_head
free_pattern_tree	./src/pattern.c	/^void free_pattern_tree(struct eb_root *root)$/;"	f
free_trash_buffers	./src/chunk.c	/^void free_trash_buffers(void)$/;"	f
free_zlib	./src/compression.c	/^static void free_zlib(void *opaque, void *ptr)$/;"	f	file:
freq_ctr	./include/types/freq_ctr.h	/^struct freq_ctr {$/;"	s
freq_ctr_period	./include/types/freq_ctr.h	/^struct freq_ctr_period {$/;"	s
freq_ctr_remain	./src/freq_ctr.c	/^unsigned int freq_ctr_remain(struct freq_ctr *ctr, unsigned int freq, unsigned int pend)$/;"	f
freq_ctr_remain_period	./src/freq_ctr.c	/^unsigned int freq_ctr_remain_period(struct freq_ctr_period *ctr, unsigned int period,$/;"	f
from	./include/types/action.h	/^	enum act_from from;                    \/* ACT_F_* *\/$/;"	m	struct:act_rule	typeref:enum:act_rule::act_from
from	./include/types/connection.h	/^		struct sockaddr_storage from;	\/* client address, or address to spoof when connecting to the server *\/$/;"	m	struct:connection::__anon52	typeref:struct:connection::__anon52::sockaddr_storage
from	./include/types/proto_udp.h	/^		struct sockaddr_storage from;	\/* client address, or address to spoof when connecting to the server *\/$/;"	m	struct:dgram_conn::__anon104	typeref:struct:dgram_conn::__anon104::sockaddr_storage
from	./include/types/proxy.h	/^		char *from;			\/* Address to send email alerts from *\/$/;"	m	struct:proxy::__anon110
frontend	./include/types/listener.h	/^	struct proxy *frontend;		\/* the frontend this listener belongs to, or NULL *\/$/;"	m	struct:listener	typeref:struct:listener::proxy
frontend_accept	./src/frontend.c	/^int frontend_accept(struct stream *s)$/;"	f
full_hash	./src/standard.c	/^unsigned int full_hash(unsigned int a)$/;"	f
fullconn	./include/types/proxy.h	/^	unsigned int fullconn;			\/* #conns on backend above which servers are used at full load *\/$/;"	m	struct:proxy
function_ref	./include/types/hlua.h	/^	int function_ref;$/;"	m	struct:hlua_function
function_ref	./include/types/hlua.h	/^	int function_ref;$/;"	m	struct:hlua_init_function
fwdfor_hdr_len	./include/types/proxy.h	/^	int fwdfor_hdr_len;			\/* length of "x-forwarded-for" header *\/$/;"	m	struct:proxy
fwdfor_hdr_name	./include/types/proxy.h	/^	char *fwdfor_hdr_name;			\/* header to use - default: "x-forwarded-for" *\/$/;"	m	struct:proxy
fwlc	./include/types/backend.h	/^	struct lb_fwlc fwlc;$/;"	m	struct:lbprm	typeref:struct:lbprm::lb_fwlc
fwlc_dequeue_srv	./src/lb_fwlc.c	/^static inline void fwlc_dequeue_srv(struct server *s)$/;"	f	file:
fwlc_get_next_server	./src/lb_fwlc.c	/^struct server *fwlc_get_next_server(struct proxy *p, struct server *srvtoavoid)$/;"	f
fwlc_init_server_tree	./src/lb_fwlc.c	/^void fwlc_init_server_tree(struct proxy *p)$/;"	f
fwlc_queue_srv	./src/lb_fwlc.c	/^static inline void fwlc_queue_srv(struct server *s)$/;"	f	file:
fwlc_remove_from_tree	./src/lb_fwlc.c	/^static inline void fwlc_remove_from_tree(struct server *s)$/;"	f	file:
fwlc_set_server_status_down	./src/lb_fwlc.c	/^static void fwlc_set_server_status_down(struct server *srv)$/;"	f	file:
fwlc_set_server_status_up	./src/lb_fwlc.c	/^static void fwlc_set_server_status_up(struct server *srv)$/;"	f	file:
fwlc_srv_reposition	./src/lb_fwlc.c	/^static void fwlc_srv_reposition(struct server *s)$/;"	f	file:
fwlc_update_server_weight	./src/lb_fwlc.c	/^static void fwlc_update_server_weight(struct server *srv)$/;"	f	file:
fwrr	./include/types/backend.h	/^	struct lb_fwrr fwrr;$/;"	m	struct:lbprm	typeref:struct:lbprm::lb_fwrr
fwrr_dequeue_srv	./src/lb_fwrr.c	/^static inline void fwrr_dequeue_srv(struct server *s)$/;"	f	file:
fwrr_get_next_server	./src/lb_fwrr.c	/^struct server *fwrr_get_next_server(struct proxy *p, struct server *srvtoavoid)$/;"	f
fwrr_get_server_from_group	./src/lb_fwrr.c	/^static struct server *fwrr_get_server_from_group(struct fwrr_group *grp)$/;"	f	file:
fwrr_get_srv	./src/lb_fwrr.c	/^static void fwrr_get_srv(struct server *s)$/;"	f	file:
fwrr_get_srv_down	./src/lb_fwrr.c	/^static inline void fwrr_get_srv_down(struct server *s)$/;"	f	file:
fwrr_get_srv_init	./src/lb_fwrr.c	/^static inline void fwrr_get_srv_init(struct server *s)$/;"	f	file:
fwrr_get_srv_next	./src/lb_fwrr.c	/^static inline void fwrr_get_srv_next(struct server *s)$/;"	f	file:
fwrr_group	./include/types/lb_fwrr.h	/^struct fwrr_group {$/;"	s
fwrr_init_server_groups	./src/lb_fwrr.c	/^void fwrr_init_server_groups(struct proxy *p)$/;"	f
fwrr_queue_by_weight	./src/lb_fwrr.c	/^static inline void fwrr_queue_by_weight(struct eb_root *root, struct server *s)$/;"	f	file:
fwrr_queue_srv	./src/lb_fwrr.c	/^static void fwrr_queue_srv(struct server *s)$/;"	f	file:
fwrr_remove_from_tree	./src/lb_fwrr.c	/^static inline void fwrr_remove_from_tree(struct server *s)$/;"	f	file:
fwrr_set_server_status_down	./src/lb_fwrr.c	/^static void fwrr_set_server_status_down(struct server *srv)$/;"	f	file:
fwrr_set_server_status_up	./src/lb_fwrr.c	/^static void fwrr_set_server_status_up(struct server *srv)$/;"	f	file:
fwrr_switch_trees	./src/lb_fwrr.c	/^static inline void fwrr_switch_trees(struct fwrr_group *grp)$/;"	f	file:
fwrr_update_position	./src/lb_fwrr.c	/^static inline void fwrr_update_position(struct fwrr_group *grp, struct server *s)$/;"	f	file:
fwrr_update_server_weight	./src/lb_fwrr.c	/^static void fwrr_update_server_weight(struct server *srv)$/;"	f	file:
gL	./src/hlua.c	/^struct hlua gL;$/;"	v	typeref:struct:hlua
gen_hash	./src/backend.c	/^static unsigned int gen_hash(const struct proxy* px, const char* key, unsigned long len)$/;"	f	file:
generate_certs	./include/types/listener.h	/^	int generate_certs;        \/* 1 if generate-certificates option is set, else 0 *\/$/;"	m	struct:bind_conf
get	./examples/check	/^sub get$/;"	s
get	./include/types/port_range.h	/^	int size, get, put;		\/* range size, and get\/put positions *\/$/;"	m	struct:port_range
get16bits	./tests/test_hashes.c	/^#define get16bits(/;"	d	file:
get16bits	./tests/test_hashes.c	/^#undef get16bits$/;"	d	file:
get16bits	./tests/uri_hash.c	/^#define get16bits(/;"	d	file:
get16bits	./tests/uri_hash.c	/^#undef get16bits$/;"	d	file:
getRawStat	./examples/stats_haproxy.sh	/^getRawStat ()$/;"	f
getStat	./examples/stats_haproxy.sh	/^getStat ()$/;"	f
get_addr	./contrib/ip6range/ip6range.c	/^static const char *get_addr(struct in6_addr *addr)$/;"	f	file:
get_addr_len	./include/common/standard.h	/^static inline int get_addr_len(const struct sockaddr_storage *addr)$/;"	f
get_analyze_status	./src/checks.c	/^const char *get_analyze_status(short analyze_status) {$/;"	f
get_backend_server	./src/proxy.c	/^int get_backend_server(const char *bk_name, const char *sv_name,$/;"	f
get_bit	./ebtree/ebtree.h	/^static forceinline int get_bit(const unsigned char *a, unsigned int pos)$/;"	f
get_check_status_description	./src/checks.c	/^const char *get_check_status_description(short check_status) {$/;"	f
get_check_status_info	./src/checks.c	/^const char *get_check_status_info(short check_status) {$/;"	f
get_conn_ctrl_name	./src/dumpstats.c	/^static inline const char *get_conn_ctrl_name(const struct connection *conn)$/;"	f	file:
get_conn_data_name	./src/dumpstats.c	/^static inline const char *get_conn_data_name(const struct connection *conn)$/;"	f	file:
get_conn_xprt_name	./src/dumpstats.c	/^static inline const char *get_conn_xprt_name(const struct connection *conn)$/;"	f	file:
get_dst	./include/types/protocol.h	/^	int (*get_dst)(int fd, struct sockaddr *, socklen_t, int dir); \/* syscall used to retrieve dst addr *\/$/;"	m	struct:protocol
get_gmtime	./include/common/standard.h	/^static inline void get_gmtime(const time_t now, struct tm *tm)$/;"	f
get_host_port	./include/common/standard.h	/^static inline int get_host_port(struct sockaddr_storage *addr)$/;"	f
get_http_auth	./src/proto_http.c	/^get_http_auth(struct stream *s)$/;"	f
get_http_auth_buff	./src/proto_http.c	/^char *get_http_auth_buff;$/;"	v
get_ipv4_addr	./contrib/iprange/iprange.c	/^static const char *get_ipv4_addr(unsigned int addr)$/;"	f	file:
get_ipv6_addr	./contrib/ip6range/ip6range.c	/^static const char *get_ipv6_addr(struct in6_addr *addr)$/;"	f	file:
get_localtime	./include/common/standard.h	/^static inline void get_localtime(const time_t now, struct tm *tm)$/;"	f
get_log_facility	./src/log.c	/^int get_log_facility(const char *fac)$/;"	f
get_log_format	./src/log.c	/^int get_log_format(const char *fmt)$/;"	f
get_log_level	./src/log.c	/^int get_log_level(const char *lev)$/;"	f
get_net_port	./include/common/standard.h	/^static inline int get_net_port(struct sockaddr_storage *addr)$/;"	f
get_next_id	./src/standard.c	/^unsigned int get_next_id(struct eb_root *root, unsigned int key)$/;"	f
get_next_server	./tests/filltab25.c	/^struct srv *get_next_server() {$/;"	f
get_pipe	./src/pipe.c	/^struct pipe *get_pipe()$/;"	f
get_reason	./src/proto_http.c	/^const char *get_reason(unsigned int status)$/;"	f
get_server_hh	./src/backend.c	/^struct server *get_server_hh(struct stream *s)$/;"	f
get_server_ph	./src/backend.c	/^struct server *get_server_ph(struct proxy *px, const char *uri, int uri_len)$/;"	f
get_server_ph_post	./src/backend.c	/^struct server *get_server_ph_post(struct stream *s)$/;"	f
get_server_rch	./src/backend.c	/^struct server *get_server_rch(struct stream *s)$/;"	f
get_server_sh	./src/backend.c	/^struct server *get_server_sh(struct proxy *px, const char *addr, int len)$/;"	f
get_server_uh	./src/backend.c	/^struct server *get_server_uh(struct proxy *px, char *uri, int uri_len)$/;"	f
get_src	./include/types/protocol.h	/^	int (*get_src)(int fd, struct sockaddr *, socklen_t, int dir); \/* syscall used to retrieve src addr *\/$/;"	m	struct:protocol
get_srv	./tests/filltab25.c	/^void get_srv(struct srv *s) {$/;"	f
get_srv_down	./tests/filltab25.c	/^static inline void get_srv_down(struct srv *s) {$/;"	f	file:
get_srv_init	./tests/filltab25.c	/^static inline void get_srv_init(struct srv *s) {$/;"	f	file:
get_srv_next	./tests/filltab25.c	/^static inline void get_srv_next(struct srv *s) {$/;"	f	file:
get_std_op	./src/standard.c	/^int get_std_op(const char *str)$/;"	f
get_tlv_length	./src/connection.c	/^static int get_tlv_length(const struct tlv *src)$/;"	f	file:
get_trash_chunk	./src/chunk.c	/^struct chunk *get_trash_chunk(void)$/;"	f
get_value	./src/lru.c	/^static long get_value(struct lru64_head *lru, long a)$/;"	f	file:
getptr	./contrib/trace/trace.awk	/^function getptr(ptr)$/;"	f
gid	./include/types/global.h	/^			gid_t gid;      \/* -1 to leave unchanged *\/$/;"	m	struct:global::__anon73::__anon74
gid	./include/types/global.h	/^	int gid;$/;"	m	struct:global
gid	./include/types/listener.h	/^		gid_t gid;         \/* -1 to leave unchanged *\/$/;"	m	struct:bind_conf::__anon77
global	./include/types/global.h	/^struct global {$/;"	s
global	./src/haproxy.c	/^struct global global = {$/;"	v	typeref:struct:global
global_dh	./src/ssl_sock.c	/^static DH *global_dh = NULL;$/;"	v	file:
global_listener_queue	./src/haproxy.c	/^struct list global_listener_queue = LIST_HEAD_INIT(global_listener_queue);$/;"	v	typeref:struct:list
global_listener_queue_task	./src/haproxy.c	/^struct task *global_listener_queue_task;$/;"	v	typeref:struct:task
gmt2str_log	./src/standard.c	/^char *gmt2str_log(char *dst, struct tm *tm, size_t size)$/;"	f
gpc	./include/types/action.h	/^		} gpc;$/;"	m	union:act_rule::__anon9	typeref:struct:act_rule::__anon9::__anon18
gpc0	./include/types/stick_table.h	/^	unsigned int gpc0;$/;"	m	union:stktable_data
gpc0_rate	./include/types/stick_table.h	/^	struct freq_ctr_period gpc0_rate;$/;"	m	union:stktable_data	typeref:struct:stktable_data::freq_ctr_period
gpt	./include/types/action.h	/^		} gpt;$/;"	m	union:act_rule::__anon9	typeref:struct:act_rule::__anon9::__anon19
gpt0	./include/types/stick_table.h	/^	unsigned int gpt0;$/;"	m	union:stktable_data
grace	./include/types/proxy.h	/^	int grace;				\/* grace time after stop request *\/$/;"	m	struct:proxy
group	./include/types/auth.h	/^	struct auth_groups *group;$/;"	m	struct:auth_groups_list	typeref:struct:auth_groups_list::auth_groups
groups	./include/types/auth.h	/^		struct auth_groups_list *groups;$/;"	m	union:auth_users::__anon37	typeref:struct:auth_users::__anon37::auth_groups_list
groups	./include/types/auth.h	/^	struct auth_groups *groups;$/;"	m	struct:userlist	typeref:struct:userlist::auth_groups
groups_names	./include/types/auth.h	/^		char *groups_names; \/* Just used during the configuration parsing. *\/$/;"	m	union:auth_users::__anon37
groupusers	./include/types/auth.h	/^	char *groupusers; \/* Just used during the configuration parsing. *\/$/;"	m	struct:auth_groups
gzip_init	./src/compression.c	/^static int gzip_init(struct comp_ctx **comp_ctx, int level)$/;"	f	file:
h1	./include/types/pattern.h	/^	int h1:5, m1:6;         \/* 0..24:0..60. Use 0:0 for all day. *\/$/;"	m	struct:pat_time
h2	./include/types/pattern.h	/^	int h2:5, m2:6;         \/* 0..24:0..60. Use 24:0 for all day. *\/$/;"	m	struct:pat_time
handler	./include/types/listener.h	/^	struct task * (*handler)(struct task *t); \/* protocol handler. It is a task *\/$/;"	m	struct:listener	typeref:struct:listener::handler
handler	./include/types/signal.h	/^	void *handler;                  \/* function to call or task to wake up *\/$/;"	m	struct:sig_handler
handlers	./include/types/signal.h	/^	struct list handlers;           \/* sig_handler *\/$/;"	m	struct:signal_descriptor	typeref:struct:signal_descriptor::list
hap_fd_clr	./src/ev_poll.c	/^static inline void hap_fd_clr(int fd, unsigned int *evts)$/;"	f	file:
hap_fd_isset	./src/ev_poll.c	/^static inline unsigned int hap_fd_isset(int fd, unsigned int *evts)$/;"	f	file:
hap_fd_set	./src/ev_poll.c	/^static inline void hap_fd_set(int fd, unsigned int *evts)$/;"	f	file:
haproxy_info	./contrib/netsnmp-perl/haproxy.pl	/^sub haproxy_info {$/;"	s
haproxy_server_hash	./tests/test_hashes.c	/^unsigned int haproxy_server_hash(const char *addr, int len){$/;"	f
haproxy_server_hash	./tests/uri_hash.c	/^unsigned int haproxy_server_hash(const char *addr, int len){$/;"	f
haproxy_stat	./contrib/netsnmp-perl/haproxy.pl	/^sub haproxy_stat {$/;"	s
haproxy_uri_hash	./tests/test_hashes.c	/^unsigned long haproxy_uri_hash(char *uri, int uri_len){$/;"	f
hardmaxconn	./include/types/global.h	/^	int maxconn, hardmaxconn;$/;"	m	struct:global
has_zero	./contrib/halog/fgets2.c	/^static inline unsigned long has_zero(unsigned long x)$/;"	f	file:
has_zero32	./contrib/halog/fgets2.c	/^static inline unsigned int has_zero32(unsigned int x)$/;"	f	file:
has_zero64	./contrib/halog/fgets2.c	/^static inline unsigned long long has_zero64(unsigned long long x)$/;"	f	file:
hash_bj6	./tests/ip-hash.c	/^uint32_t hash_bj6(uint32_t a)$/;"	f
hash_bj7	./tests/ip-hash.c	/^uint32_t hash_bj7(uint32_t a)$/;"	f
hash_crc32	./src/hash.c	/^unsigned int hash_crc32(const char *key, int len)$/;"	f
hash_djb2	./src/hash.c	/^unsigned int hash_djb2(const char *key, int len)$/;"	f
hash_djbx33	./tests/test_hashes.c	/^hash_djbx33($/;"	f	file:
hash_gd1	./tests/uri_hash.c	/^static unsigned long hash_gd1(char *uri)$/;"	f	file:
hash_gd2	./tests/uri_hash.c	/^static unsigned long hash_gd2(char *uri)$/;"	f	file:
hash_gd3	./tests/uri_hash.c	/^static unsigned long hash_gd3(char *uri)$/;"	f	file:
hash_gd4	./tests/uri_hash.c	/^static unsigned long hash_gd4(char *uri)$/;"	f	file:
hash_gd5	./tests/uri_hash.c	/^static unsigned long hash_gd5(char *uri)$/;"	f	file:
hash_gd6	./tests/uri_hash.c	/^static unsigned long hash_gd6(char *uri)$/;"	f	file:
hash_id	./tests/ip-hash.c	/^uint32_t hash_id( uint32_t a)$/;"	f
hash_sdbm	./src/hash.c	/^unsigned int hash_sdbm(const char *key, int len)$/;"	f
hash_tw1	./tests/ip-hash.c	/^uint32_t hash_tw1(uint32_t a)$/;"	f
hash_tw2	./tests/ip-hash.c	/^uint32_t hash_tw2(uint32_t a)$/;"	f
hash_tw3	./tests/ip-hash.c	/^uint32_t hash_tw3(uint32_t a)$/;"	f
hash_wt1	./tests/uri_hash.c	/^static unsigned long hash_wt1(int hsize, char *string) {$/;"	f	file:
hash_wt2	./tests/uri_hash.c	/^int hash_wt2(const char *src, int len) {$/;"	f
hash_wt6	./src/hash.c	/^unsigned int hash_wt6(const char *key, int len)$/;"	f
hashpjw	./tests/test_hashes.c	/^int hashpjw(const void *key) {$/;"	f
hashword	./tests/test_hashes.c	/^uint32_t hashword($/;"	f
hdr	./include/types/action.h	/^			struct cap_hdr *hdr;      \/* the capture storage *\/$/;"	m	struct:act_rule::__anon9::__anon14	typeref:struct:act_rule::__anon9::__anon14::cap_hdr
hdr	./src/shctx.c	/^	struct shsess_packet_hdr hdr;$/;"	m	struct:shsess_packet	typeref:struct:shsess_packet::shsess_packet_hdr	file:
hdr_add	./include/types/action.h	/^		} hdr_add;                     \/* args used by "add-header" and "set-header" *\/$/;"	m	union:act_rule::__anon9	typeref:struct:act_rule::__anon9::__anon11
hdr_ctx	./include/types/proto_http.h	/^struct hdr_ctx {$/;"	s
hdr_encode_map	./src/proto_http.c	/^fd_set hdr_encode_map[(sizeof(fd_set) > (256\/8)) ? 1 : ((256\/8) \/ sizeof(fd_set))];$/;"	v
hdr_exp	./include/common/regex.h	/^struct hdr_exp {$/;"	s
hdr_idx	./include/types/hdr_idx.h	/^struct hdr_idx {$/;"	s
hdr_idx	./include/types/proto_http.h	/^	struct hdr_idx hdr_idx;         \/* array of header indexes (max: global.tune.max_http_hdr) *\/$/;"	m	struct:http_txn	typeref:struct:http_txn::hdr_idx
hdr_idx_add	./src/hdr_idx.c	/^int hdr_idx_add(int len, int cr, struct hdr_idx *list, int after)$/;"	f
hdr_idx_elem	./include/types/hdr_idx.h	/^struct hdr_idx_elem {$/;"	s
hdr_idx_first_idx	./include/proto/hdr_idx.h	/^static inline int hdr_idx_first_idx(struct hdr_idx *list)$/;"	f
hdr_idx_first_pos	./include/proto/hdr_idx.h	/^static inline int hdr_idx_first_pos(struct hdr_idx *list)$/;"	f
hdr_idx_init	./include/proto/hdr_idx.h	/^static inline void hdr_idx_init(struct hdr_idx *list)$/;"	f
hdr_idx_set_start	./include/proto/hdr_idx.h	/^static inline void hdr_idx_set_start(struct hdr_idx *list, int len, int cr)$/;"	f
head	./include/types/pattern.h	/^	struct list head; \/* The head of the list of struct pat_ref_elt. *\/$/;"	m	struct:pat_ref	typeref:struct:pat_ref::list
head	./include/types/pattern.h	/^	struct list head; \/* This is a list of struct pattern_expr_list. *\/$/;"	m	struct:pattern_head	typeref:struct:pattern_head::list
head	./include/types/vars.h	/^	struct list head;$/;"	m	struct:vars	typeref:struct:vars::list
header_count	./include/types/global.h	/^		int header_count; \/* number of HTTP headers related to device detection. *\/$/;"	m	struct:global::__anon76
header_names	./include/types/global.h	/^		struct chunk *header_names; \/* array of HTTP header names. *\/$/;"	m	struct:global::__anon76	typeref:struct:global::__anon76::chunk
header_offsets	./include/types/global.h	/^		int32_t *header_offsets; \/* offsets to the HTTP header name string. *\/$/;"	m	struct:global::__anon76
header_unique_id	./include/types/proxy.h	/^	char *header_unique_id; 		\/* unique-id header *\/$/;"	m	struct:proxy
health	./include/types/checks.h	/^	int health;				\/* 0 to rise-1 = bad;$/;"	m	struct:check
health_adjust	./include/proto/checks.h	/^static inline void health_adjust(struct server *s, short status)$/;"	f
help	./contrib/halog/halog.c	/^void help()$/;"	f
hex2i	./include/common/standard.h	/^static inline int hex2i(int c)$/;"	f
hextab	./src/standard.c	/^const char hextab[16] = "0123456789ABCDEF";$/;"	v
hh_len	./include/types/proxy.h	/^	int  hh_len;				\/* strlen(hh_name), computed only once *\/$/;"	m	struct:proxy
hh_match_domain	./include/types/proxy.h	/^	int  hh_match_domain;			\/* toggle use of special match function *\/$/;"	m	struct:proxy
hh_name	./include/types/proxy.h	/^	char *hh_name;				\/* name of the header parameter used for hashing *\/$/;"	m	struct:proxy
hlua	./include/types/applet.h	/^			struct hlua hlua;$/;"	m	struct:appctx::__anon21::__anon31	typeref:struct:appctx::__anon21::__anon31::hlua
hlua	./include/types/applet.h	/^			struct hlua hlua;$/;"	m	struct:appctx::__anon21::__anon32	typeref:struct:appctx::__anon21::__anon32::hlua
hlua	./include/types/applet.h	/^		} hlua;$/;"	m	union:appctx::__anon21	typeref:struct:appctx::__anon21::__anon30
hlua	./include/types/hlua.h	/^struct hlua { };$/;"	s
hlua	./include/types/hlua.h	/^struct hlua {$/;"	s
hlua	./include/types/stream.h	/^	struct hlua hlua;                       \/* lua runtime context *\/$/;"	m	struct:stream	typeref:struct:stream::hlua
hlua_action	./src/hlua.c	/^static enum act_return hlua_action(struct act_rule *rule, struct proxy *px,$/;"	f	file:
hlua_add_acl	./src/hlua.c	/^static int hlua_add_acl(lua_State *L)$/;"	f	file:
hlua_alloc	./src/hlua.c	/^static void *hlua_alloc(void *ud, void *ptr, size_t osize, size_t nsize)$/;"	f	file:
hlua_appctx	./include/types/hlua.h	/^struct hlua_appctx {$/;"	s
hlua_apphttp	./include/types/applet.h	/^		} hlua_apphttp;$/;"	m	union:appctx::__anon21	typeref:struct:appctx::__anon21::__anon32
hlua_applet_http_addheader	./src/hlua.c	/^__LJMP static int hlua_applet_http_addheader(lua_State *L)$/;"	f	file:
hlua_applet_http_fct	./src/hlua.c	/^static void hlua_applet_http_fct(struct appctx *ctx)$/;"	f	file:
hlua_applet_http_getline	./src/hlua.c	/^__LJMP static int hlua_applet_http_getline(lua_State *L)$/;"	f	file:
hlua_applet_http_getline_yield	./src/hlua.c	/^__LJMP static int hlua_applet_http_getline_yield(lua_State *L, int status, lua_KContext ctx)$/;"	f	file:
hlua_applet_http_init	./src/hlua.c	/^static int hlua_applet_http_init(struct appctx *ctx, struct proxy *px, struct stream *strm)$/;"	f	file:
hlua_applet_http_new	./src/hlua.c	/^static int hlua_applet_http_new(lua_State *L, struct appctx *ctx)$/;"	f	file:
hlua_applet_http_recv	./src/hlua.c	/^__LJMP static int hlua_applet_http_recv(lua_State *L)$/;"	f	file:
hlua_applet_http_recv_yield	./src/hlua.c	/^__LJMP static int hlua_applet_http_recv_yield(lua_State *L, int status, lua_KContext ctx)$/;"	f	file:
hlua_applet_http_release	./src/hlua.c	/^static void hlua_applet_http_release(struct appctx *ctx)$/;"	f	file:
hlua_applet_http_send	./src/hlua.c	/^__LJMP static int hlua_applet_http_send(lua_State *L)$/;"	f	file:
hlua_applet_http_send_yield	./src/hlua.c	/^__LJMP static int hlua_applet_http_send_yield(lua_State *L, int status, lua_KContext ctx)$/;"	f	file:
hlua_applet_http_start_response	./src/hlua.c	/^__LJMP static int hlua_applet_http_start_response(lua_State *L)$/;"	f	file:
hlua_applet_http_start_response_yield	./src/hlua.c	/^__LJMP static int hlua_applet_http_start_response_yield(lua_State *L, int status, lua_KContext ctx)$/;"	f	file:
hlua_applet_http_status	./src/hlua.c	/^__LJMP static int hlua_applet_http_status(lua_State *L)$/;"	f	file:
hlua_applet_tcp_fct	./src/hlua.c	/^static void hlua_applet_tcp_fct(struct appctx *ctx)$/;"	f	file:
hlua_applet_tcp_getline	./src/hlua.c	/^__LJMP static int hlua_applet_tcp_getline(lua_State *L)$/;"	f	file:
hlua_applet_tcp_getline_yield	./src/hlua.c	/^__LJMP static int hlua_applet_tcp_getline_yield(lua_State *L, int status, lua_KContext ctx)$/;"	f	file:
hlua_applet_tcp_init	./src/hlua.c	/^static int hlua_applet_tcp_init(struct appctx *ctx, struct proxy *px, struct stream *strm)$/;"	f	file:
hlua_applet_tcp_new	./src/hlua.c	/^static int hlua_applet_tcp_new(lua_State *L, struct appctx *ctx)$/;"	f	file:
hlua_applet_tcp_recv	./src/hlua.c	/^__LJMP static int hlua_applet_tcp_recv(lua_State *L)$/;"	f	file:
hlua_applet_tcp_recv_yield	./src/hlua.c	/^__LJMP static int hlua_applet_tcp_recv_yield(lua_State *L, int status, lua_KContext ctx)$/;"	f	file:
hlua_applet_tcp_release	./src/hlua.c	/^static void hlua_applet_tcp_release(struct appctx *ctx)$/;"	f	file:
hlua_applet_tcp_send	./src/hlua.c	/^__LJMP static int hlua_applet_tcp_send(lua_State *L)$/;"	f	file:
hlua_applet_tcp_send_yield	./src/hlua.c	/^__LJMP static int hlua_applet_tcp_send_yield(lua_State *L, int status, lua_KContext ctx)$/;"	f	file:
hlua_applet_timeout	./src/hlua.c	/^static int hlua_applet_timeout(char **args, int section_type, struct proxy *curpx,$/;"	f	file:
hlua_applet_wakeup	./src/hlua.c	/^struct task *hlua_applet_wakeup(struct task *t)$/;"	f
hlua_apptcp	./include/types/applet.h	/^		} hlua_apptcp;$/;"	m	union:appctx::__anon21	typeref:struct:appctx::__anon21::__anon31
hlua_arg2lua	./src/hlua.c	/^static int hlua_arg2lua(lua_State *L, const struct arg *arg)$/;"	f	file:
hlua_channel_append	./src/hlua.c	/^__LJMP static int hlua_channel_append(lua_State *L)$/;"	f	file:
hlua_channel_append_yield	./src/hlua.c	/^__LJMP static int hlua_channel_append_yield(lua_State *L, int status, lua_KContext ctx)$/;"	f	file:
hlua_channel_dup	./src/hlua.c	/^__LJMP static int hlua_channel_dup(lua_State *L)$/;"	f	file:
hlua_channel_dup_yield	./src/hlua.c	/^__LJMP static int hlua_channel_dup_yield(lua_State *L, int status, lua_KContext ctx)$/;"	f	file:
hlua_channel_forward	./src/hlua.c	/^__LJMP static int hlua_channel_forward(lua_State *L)$/;"	f	file:
hlua_channel_forward_yield	./src/hlua.c	/^__LJMP static int hlua_channel_forward_yield(lua_State *L, int status, lua_KContext ctx)$/;"	f	file:
hlua_channel_get	./src/hlua.c	/^__LJMP static int hlua_channel_get(lua_State *L)$/;"	f	file:
hlua_channel_get_in_len	./src/hlua.c	/^__LJMP static int hlua_channel_get_in_len(lua_State *L)$/;"	f	file:
hlua_channel_get_out_len	./src/hlua.c	/^__LJMP static int hlua_channel_get_out_len(lua_State *L)$/;"	f	file:
hlua_channel_get_yield	./src/hlua.c	/^__LJMP static int hlua_channel_get_yield(lua_State *L, int status, lua_KContext ctx)$/;"	f	file:
hlua_channel_getline	./src/hlua.c	/^__LJMP static int hlua_channel_getline(lua_State *L)$/;"	f	file:
hlua_channel_getline_yield	./src/hlua.c	/^__LJMP static int hlua_channel_getline_yield(lua_State *L, int status, lua_KContext ctx)$/;"	f	file:
hlua_channel_new	./src/hlua.c	/^static int hlua_channel_new(lua_State *L, struct channel *channel)$/;"	f	file:
hlua_channel_send	./src/hlua.c	/^__LJMP static int hlua_channel_send(lua_State *L)$/;"	f	file:
hlua_channel_send_yield	./src/hlua.c	/^__LJMP static int hlua_channel_send_yield(lua_State *L, int status, lua_KContext ctx)$/;"	f	file:
hlua_channel_set	./src/hlua.c	/^__LJMP static int hlua_channel_set(lua_State *L)$/;"	f	file:
hlua_check_proto	./src/hlua.c	/^static int hlua_check_proto(struct stream *stream, int dir)$/;"	f	file:
hlua_checkapplet_http	./src/hlua.c	/^__LJMP static struct hlua_appctx *hlua_checkapplet_http(lua_State *L, int ud)$/;"	f	file:
hlua_checkapplet_tcp	./src/hlua.c	/^__LJMP static struct hlua_appctx *hlua_checkapplet_tcp(lua_State *L, int ud)$/;"	f	file:
hlua_checkchannel	./src/hlua.c	/^__LJMP static struct channel *hlua_checkchannel(lua_State *L, int ud)$/;"	f	file:
hlua_checkconverters	./src/hlua.c	/^__LJMP static struct hlua_smp *hlua_checkconverters(lua_State *L, int ud)$/;"	f	file:
hlua_checkfetches	./src/hlua.c	/^__LJMP static struct hlua_smp *hlua_checkfetches(lua_State *L, int ud)$/;"	f	file:
hlua_checkfunction	./src/hlua.c	/^__LJMP unsigned int hlua_checkfunction(lua_State *L, int argno)$/;"	f
hlua_checkhttp	./src/hlua.c	/^__LJMP static struct hlua_txn *hlua_checkhttp(lua_State *L, int ud)$/;"	f	file:
hlua_checkmap	./src/hlua.c	/^__LJMP static struct map_descriptor *hlua_checkmap(lua_State *L, int ud)$/;"	f	file:
hlua_checksocket	./src/hlua.c	/^__LJMP static struct hlua_socket *hlua_checksocket(lua_State *L, int ud)$/;"	f	file:
hlua_checktxn	./src/hlua.c	/^__LJMP static struct hlua_txn *hlua_checktxn(lua_State *L, int ud)$/;"	f	file:
hlua_checkudata	./src/hlua.c	/^__LJMP static void *hlua_checkudata(lua_State *L, int ud, int class_ref)$/;"	f	file:
hlua_class_const_int	./src/hlua.c	/^__LJMP static inline void hlua_class_const_int(lua_State *L, const char *name,$/;"	f	file:
hlua_class_const_str	./src/hlua.c	/^__LJMP static inline void hlua_class_const_str(lua_State *L, const char *name,$/;"	f	file:
hlua_class_function	./src/hlua.c	/^__LJMP static inline void hlua_class_function(lua_State *L, const char *name,$/;"	f	file:
hlua_com	./include/types/hlua.h	/^struct hlua_com {$/;"	s
hlua_com_new	./src/hlua.c	/^static int hlua_com_new(struct hlua *lua, struct list *link)$/;"	f	file:
hlua_com_purge	./src/hlua.c	/^static void hlua_com_purge(struct hlua *lua)$/;"	f	file:
hlua_com_wake	./src/hlua.c	/^static void hlua_com_wake(struct list *wake)$/;"	f	file:
hlua_converters_new	./src/hlua.c	/^static int hlua_converters_new(lua_State *L, struct hlua_txn *txn, unsigned int flags)$/;"	f	file:
hlua_ctx_destroy	./include/proto/hlua.h	/^static inline void hlua_ctx_destroy(struct hlua *lua) { }$/;"	f
hlua_ctx_destroy	./src/hlua.c	/^void hlua_ctx_destroy(struct hlua *lua)$/;"	f
hlua_ctx_init	./src/hlua.c	/^int hlua_ctx_init(struct hlua *lua, struct task *task)$/;"	f
hlua_ctx_renew	./src/hlua.c	/^static int hlua_ctx_renew(struct hlua *lua, int keep_msg)$/;"	f	file:
hlua_ctx_resume	./src/hlua.c	/^static enum hlua_exec hlua_ctx_resume(struct hlua *lua, int yield_allowed)$/;"	f	file:
hlua_del_acl	./src/hlua.c	/^__LJMP static int hlua_del_acl(lua_State *L)$/;"	f	file:
hlua_del_map	./src/hlua.c	/^static int hlua_del_map(lua_State *L)$/;"	f	file:
hlua_done	./src/hlua.c	/^__LJMP static int hlua_done(lua_State *L)$/;"	f	file:
hlua_dump_object	./src/hlua.c	/^__LJMP static int hlua_dump_object(struct lua_State *L)$/;"	f	file:
hlua_exec	./include/types/hlua.h	/^enum hlua_exec {$/;"	g
hlua_fetches_new	./src/hlua.c	/^static int hlua_fetches_new(lua_State *L, struct hlua_txn *txn, unsigned int flags)$/;"	f	file:
hlua_forced_yield	./src/hlua.c	/^static int hlua_forced_yield(char **args, int section_type, struct proxy *curpx,$/;"	f	file:
hlua_function	./include/types/hlua.h	/^struct hlua_function {$/;"	s
hlua_get_priv	./src/hlua.c	/^__LJMP static int hlua_get_priv(lua_State *L)$/;"	f	file:
hlua_get_top_error_string	./src/hlua.c	/^const char *hlua_get_top_error_string(lua_State *L)$/;"	f
hlua_get_var	./src/hlua.c	/^__LJMP static int hlua_get_var(lua_State *L)$/;"	f	file:
hlua_gethlua	./src/hlua.c	/^static inline struct hlua *hlua_gethlua(lua_State *L)$/;"	f	file:
hlua_global_allocator	./src/hlua.c	/^static struct hlua_mem_allocator hlua_global_allocator;$/;"	v	typeref:struct:hlua_mem_allocator	file:
hlua_hook	./src/hlua.c	/^void hlua_hook(lua_State *L, lua_Debug *ar)$/;"	f
hlua_http_add_hdr	./src/hlua.c	/^__LJMP static inline int hlua_http_add_hdr(lua_State *L, struct hlua_txn *htxn, struct http_msg *msg)$/;"	f	file:
hlua_http_del_hdr	./src/hlua.c	/^__LJMP static inline int hlua_http_del_hdr(lua_State *L, struct hlua_txn *htxn, struct http_msg *msg)$/;"	f	file:
hlua_http_get_headers	./src/hlua.c	/^__LJMP static int hlua_http_get_headers(lua_State *L, struct hlua_txn *htxn, struct http_msg *msg)$/;"	f	file:
hlua_http_new	./src/hlua.c	/^static int hlua_http_new(lua_State *L, struct hlua_txn *txn)$/;"	f	file:
hlua_http_rep_hdr	./src/hlua.c	/^__LJMP static inline int hlua_http_rep_hdr(lua_State *L, struct hlua_txn *htxn,$/;"	f	file:
hlua_http_req_add_hdr	./src/hlua.c	/^__LJMP static int hlua_http_req_add_hdr(lua_State *L)$/;"	f	file:
hlua_http_req_del_hdr	./src/hlua.c	/^__LJMP static int hlua_http_req_del_hdr(lua_State *L)$/;"	f	file:
hlua_http_req_get_headers	./src/hlua.c	/^__LJMP static int hlua_http_req_get_headers(lua_State *L)$/;"	f	file:
hlua_http_req_rep_hdr	./src/hlua.c	/^__LJMP static int hlua_http_req_rep_hdr(lua_State *L)$/;"	f	file:
hlua_http_req_rep_val	./src/hlua.c	/^__LJMP static int hlua_http_req_rep_val(lua_State *L)$/;"	f	file:
hlua_http_req_set_hdr	./src/hlua.c	/^static int hlua_http_req_set_hdr(lua_State *L)$/;"	f	file:
hlua_http_req_set_meth	./src/hlua.c	/^static int hlua_http_req_set_meth(lua_State *L)$/;"	f	file:
hlua_http_req_set_path	./src/hlua.c	/^static int hlua_http_req_set_path(lua_State *L)$/;"	f	file:
hlua_http_req_set_query	./src/hlua.c	/^static int hlua_http_req_set_query(lua_State *L)$/;"	f	file:
hlua_http_req_set_uri	./src/hlua.c	/^static int hlua_http_req_set_uri(lua_State *L)$/;"	f	file:
hlua_http_res_add_hdr	./src/hlua.c	/^__LJMP static int hlua_http_res_add_hdr(lua_State *L)$/;"	f	file:
hlua_http_res_del_hdr	./src/hlua.c	/^__LJMP static int hlua_http_res_del_hdr(lua_State *L)$/;"	f	file:
hlua_http_res_get_headers	./src/hlua.c	/^__LJMP static int hlua_http_res_get_headers(lua_State *L)$/;"	f	file:
hlua_http_res_rep_hdr	./src/hlua.c	/^__LJMP static int hlua_http_res_rep_hdr(lua_State *L)$/;"	f	file:
hlua_http_res_rep_val	./src/hlua.c	/^__LJMP static int hlua_http_res_rep_val(lua_State *L)$/;"	f	file:
hlua_http_res_set_hdr	./src/hlua.c	/^static int hlua_http_res_set_hdr(lua_State *L)$/;"	f	file:
hlua_http_res_set_status	./src/hlua.c	/^static int hlua_http_res_set_status(lua_State *L)$/;"	f	file:
hlua_init	./include/proto/hlua.h	/^static inline void hlua_init() { }$/;"	f
hlua_init	./src/hlua.c	/^void hlua_init(void)$/;"	f
hlua_init_function	./include/types/hlua.h	/^struct hlua_init_function {$/;"	s
hlua_init_functions	./src/hlua.c	/^struct list hlua_init_functions = LIST_HEAD_INIT(hlua_init_functions);$/;"	v	typeref:struct:list
hlua_load	./src/hlua.c	/^static int hlua_load(char **args, int section_type, struct proxy *curpx,$/;"	f	file:
hlua_log	./src/hlua.c	/^__LJMP static int hlua_log(lua_State *L)$/;"	f	file:
hlua_log_alert	./src/hlua.c	/^__LJMP static int hlua_log_alert(lua_State *L)$/;"	f	file:
hlua_log_debug	./src/hlua.c	/^__LJMP static int hlua_log_debug(lua_State *L)$/;"	f	file:
hlua_log_info	./src/hlua.c	/^__LJMP static int hlua_log_info(lua_State *L)$/;"	f	file:
hlua_log_warning	./src/hlua.c	/^__LJMP static int hlua_log_warning(lua_State *L)$/;"	f	file:
hlua_lua2arg	./src/hlua.c	/^static int hlua_lua2arg(lua_State *L, int ud, struct arg *arg)$/;"	f	file:
hlua_lua2arg_check	./src/hlua.c	/^__LJMP int hlua_lua2arg_check(lua_State *L, int first, struct arg *argp,$/;"	f
hlua_lua2smp	./src/hlua.c	/^static int hlua_lua2smp(lua_State *L, int ud, struct sample *smp)$/;"	f	file:
hlua_map_lookup	./src/hlua.c	/^__LJMP static int hlua_map_lookup(struct lua_State *L)$/;"	f	file:
hlua_map_new	./src/hlua.c	/^__LJMP static int hlua_map_new(struct lua_State *L)$/;"	f	file:
hlua_map_slookup	./src/hlua.c	/^__LJMP static int hlua_map_slookup(struct lua_State *L)$/;"	f	file:
hlua_mem_allocator	./src/hlua.c	/^struct hlua_mem_allocator {$/;"	s	file:
hlua_metaistype	./src/hlua.c	/^static int hlua_metaistype(lua_State *L, int ud, int class_ref)$/;"	f	file:
hlua_msleep	./src/hlua.c	/^__LJMP static int hlua_msleep(lua_State *L)$/;"	f	file:
hlua_nb_instruction	./src/hlua.c	/^static unsigned int hlua_nb_instruction = 10000;$/;"	v	file:
hlua_panic_ljmp	./src/hlua.c	/^static int hlua_panic_ljmp(lua_State *L) { longjmp(safe_ljmp_env, 1); }$/;"	f	file:
hlua_panic_safe	./src/hlua.c	/^static int hlua_panic_safe(lua_State *L) { return 0; }$/;"	f	file:
hlua_parse_maxmem	./src/hlua.c	/^static int hlua_parse_maxmem(char **args, int section_type, struct proxy *curpx,$/;"	f	file:
hlua_post_init	./include/proto/hlua.h	/^static inline int hlua_post_init() { return 1; }$/;"	f
hlua_post_init	./src/hlua.c	/^int hlua_post_init()$/;"	f
hlua_process_task	./src/hlua.c	/^static struct task *hlua_process_task(struct task *task)$/;"	f	file:
hlua_pusherror	./src/hlua.c	/^static int hlua_pusherror(lua_State *L, const char *fmt, ...)$/;"	f	file:
hlua_read_timeout	./src/hlua.c	/^static int hlua_read_timeout(char **args, int section_type, struct proxy *curpx,$/;"	f	file:
hlua_register_action	./src/hlua.c	/^__LJMP static int hlua_register_action(lua_State *L)$/;"	f	file:
hlua_register_converters	./src/hlua.c	/^__LJMP static int hlua_register_converters(lua_State *L)$/;"	f	file:
hlua_register_fetches	./src/hlua.c	/^__LJMP static int hlua_register_fetches(lua_State *L)$/;"	f	file:
hlua_register_init	./src/hlua.c	/^__LJMP static int hlua_register_init(lua_State *L)$/;"	f	file:
hlua_register_service	./src/hlua.c	/^__LJMP static int hlua_register_service(lua_State *L)$/;"	f	file:
hlua_register_task	./src/hlua.c	/^static int hlua_register_task(lua_State *L)$/;"	f	file:
hlua_resynchonize_proto	./src/hlua.c	/^static void hlua_resynchonize_proto(struct stream *stream, int dir)$/;"	f	file:
hlua_rule	./include/types/action.h	/^		struct hlua_rule *hlua_rule;$/;"	m	union:act_rule::__anon9	typeref:struct:act_rule::__anon9::hlua_rule
hlua_rule	./include/types/hlua.h	/^struct hlua_rule { };$/;"	s
hlua_rule	./include/types/hlua.h	/^struct hlua_rule {$/;"	s
hlua_run_sample_conv	./src/hlua.c	/^__LJMP static int hlua_run_sample_conv(lua_State *L)$/;"	f	file:
hlua_run_sample_fetch	./src/hlua.c	/^__LJMP static int hlua_run_sample_fetch(lua_State *L)$/;"	f	file:
hlua_sample_conv_wrapper	./src/hlua.c	/^static int hlua_sample_conv_wrapper(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
hlua_sample_fetch_wrapper	./src/hlua.c	/^static int hlua_sample_fetch_wrapper(const struct arg *arg_p, struct sample *smp,$/;"	f	file:
hlua_sendlog	./src/hlua.c	/^static inline void hlua_sendlog(struct proxy *px, int level, const char *msg)$/;"	f	file:
hlua_session_timeout	./src/hlua.c	/^static int hlua_session_timeout(char **args, int section_type, struct proxy *curpx,$/;"	f	file:
hlua_set_map	./src/hlua.c	/^static int hlua_set_map(lua_State *L)$/;"	f	file:
hlua_set_nice	./src/hlua.c	/^__LJMP static int hlua_set_nice(lua_State *L)$/;"	f	file:
hlua_set_priv	./src/hlua.c	/^__LJMP static int hlua_set_priv(lua_State *L)$/;"	f	file:
hlua_set_var	./src/hlua.c	/^__LJMP static int hlua_set_var(lua_State *L)$/;"	f	file:
hlua_sethlua	./src/hlua.c	/^static inline void hlua_sethlua(struct hlua *hlua)$/;"	f	file:
hlua_sleep	./include/types/hlua.h	/^struct hlua_sleep {$/;"	s
hlua_sleep	./src/hlua.c	/^__LJMP static int hlua_sleep(lua_State *L)$/;"	f	file:
hlua_sleep_yield	./src/hlua.c	/^__LJMP static int hlua_sleep_yield(lua_State *L, int status, lua_KContext ctx)$/;"	f	file:
hlua_smp	./include/types/hlua.h	/^struct hlua_smp {$/;"	s
hlua_smp2lua	./src/hlua.c	/^static int hlua_smp2lua(lua_State *L, struct sample *smp)$/;"	f	file:
hlua_smp2lua_str	./src/hlua.c	/^static int hlua_smp2lua_str(lua_State *L, struct sample *smp)$/;"	f	file:
hlua_socket	./include/types/hlua.h	/^struct hlua_socket { };$/;"	s
hlua_socket	./include/types/hlua.h	/^struct hlua_socket {$/;"	s
hlua_socket_close	./src/hlua.c	/^__LJMP static int hlua_socket_close(lua_State *L)$/;"	f	file:
hlua_socket_connect	./src/hlua.c	/^__LJMP static int hlua_socket_connect(struct lua_State *L)$/;"	f	file:
hlua_socket_connect_ssl	./src/hlua.c	/^__LJMP static int hlua_socket_connect_ssl(struct lua_State *L)$/;"	f	file:
hlua_socket_connect_yield	./src/hlua.c	/^__LJMP static int hlua_socket_connect_yield(struct lua_State *L, int status, lua_KContext ctx)$/;"	f	file:
hlua_socket_gc	./src/hlua.c	/^__LJMP static int hlua_socket_gc(lua_State *L)$/;"	f	file:
hlua_socket_getpeername	./src/hlua.c	/^__LJMP static int hlua_socket_getpeername(struct lua_State *L)$/;"	f	file:
hlua_socket_getsockname	./src/hlua.c	/^static int hlua_socket_getsockname(struct lua_State *L)$/;"	f	file:
hlua_socket_handler	./src/hlua.c	/^static void hlua_socket_handler(struct appctx *appctx)$/;"	f	file:
hlua_socket_info	./src/hlua.c	/^__LJMP static inline int hlua_socket_info(struct lua_State *L, struct sockaddr_storage *addr)$/;"	f	file:
hlua_socket_new	./src/hlua.c	/^__LJMP static int hlua_socket_new(lua_State *L)$/;"	f	file:
hlua_socket_receive	./src/hlua.c	/^__LJMP static int hlua_socket_receive(struct lua_State *L)$/;"	f	file:
hlua_socket_receive_yield	./src/hlua.c	/^__LJMP static int hlua_socket_receive_yield(struct lua_State *L, int status, lua_KContext ctx)$/;"	f	file:
hlua_socket_release	./src/hlua.c	/^static void hlua_socket_release(struct appctx *appctx)$/;"	f	file:
hlua_socket_send	./src/hlua.c	/^static int hlua_socket_send(struct lua_State *L)$/;"	f	file:
hlua_socket_setoption	./src/hlua.c	/^__LJMP static int hlua_socket_setoption(struct lua_State *L)$/;"	f	file:
hlua_socket_settimeout	./src/hlua.c	/^__LJMP static int hlua_socket_settimeout(struct lua_State *L)$/;"	f	file:
hlua_socket_write_yield	./src/hlua.c	/^static int hlua_socket_write_yield(struct lua_State *L,int status, lua_KContext ctx)$/;"	f	file:
hlua_task_timeout	./src/hlua.c	/^static int hlua_task_timeout(char **args, int section_type, struct proxy *curpx,$/;"	f	file:
hlua_timeout_applet	./src/hlua.c	/^static unsigned int hlua_timeout_applet = 4000; \/* applet timeout. *\/$/;"	v	file:
hlua_timeout_session	./src/hlua.c	/^static unsigned int hlua_timeout_session = 4000; \/* session timeout. *\/$/;"	v	file:
hlua_timeout_task	./src/hlua.c	/^static unsigned int hlua_timeout_task = TICK_ETERNITY; \/* task timeout. *\/$/;"	v	file:
hlua_txn	./include/types/hlua.h	/^struct hlua_txn {$/;"	s
hlua_txn_deflog	./src/hlua.c	/^__LJMP static int hlua_txn_deflog(lua_State *L)$/;"	f	file:
hlua_txn_done	./src/hlua.c	/^__LJMP static int hlua_txn_done(lua_State *L)$/;"	f	file:
hlua_txn_log	./src/hlua.c	/^__LJMP static int hlua_txn_log(lua_State *L)$/;"	f	file:
hlua_txn_log_alert	./src/hlua.c	/^__LJMP static int hlua_txn_log_alert(lua_State *L)$/;"	f	file:
hlua_txn_log_debug	./src/hlua.c	/^__LJMP static int hlua_txn_log_debug(lua_State *L)$/;"	f	file:
hlua_txn_log_info	./src/hlua.c	/^__LJMP static int hlua_txn_log_info(lua_State *L)$/;"	f	file:
hlua_txn_log_warning	./src/hlua.c	/^__LJMP static int hlua_txn_log_warning(lua_State *L)$/;"	f	file:
hlua_txn_new	./src/hlua.c	/^static int hlua_txn_new(lua_State *L, struct stream *s, struct proxy *p, int dir)$/;"	f	file:
hlua_txn_set_loglevel	./src/hlua.c	/^__LJMP static int hlua_txn_set_loglevel(lua_State *L)$/;"	f	file:
hlua_txn_set_mark	./src/hlua.c	/^__LJMP static int hlua_txn_set_mark(lua_State *L)$/;"	f	file:
hlua_txn_set_tos	./src/hlua.c	/^__LJMP static int hlua_txn_set_tos(lua_State *L)$/;"	f	file:
hlua_yield	./src/hlua.c	/^__LJMP static int hlua_yield(lua_State *L)$/;"	f	file:
hlua_yield_yield	./src/hlua.c	/^__LJMP static int hlua_yield_yield(lua_State *L, int status, lua_KContext ctx)$/;"	f	file:
hlua_yieldk	./src/hlua.c	/^__LJMP void hlua_yieldk(lua_State *L, int nresults, int ctx,$/;"	f
hmac_key	./include/types/ssl_sock.h	/^	unsigned char hmac_key[16];$/;"	m	struct:tls_sess_key
hmask	./contrib/ip6range/ip6range.c	/^static inline struct in6_addr *hmask(unsigned int b, struct in6_addr *r)$/;"	f	file:
hold	./include/types/dns.h	/^	} hold;$/;"	m	struct:dns_resolvers	typeref:struct:dns_resolvers::__anon63
host	./include/common/standard.h	/^	const char *host;$/;"	m	struct:split_url
host_len	./include/common/standard.h	/^	int host_len;$/;"	m	struct:split_url
hostname	./include/types/server.h	/^	char *hostname;				\/* server hostname *\/$/;"	m	struct:server
hostname	./src/haproxy.c	/^char hostname[MAX_HOSTNAME_LEN];$/;"	v
hostname_dn	./include/types/dns.h	/^	char *hostname_dn;		\/* server hostname in domain name label format *\/$/;"	m	struct:dns_resolution
hostname_dn_len	./include/types/dns.h	/^	int hostname_dn_len;		\/* server domain name label len *\/$/;"	m	struct:dns_resolution
ht_auth_m	./include/types/proto_http.h	/^enum ht_auth_m {$/;"	g
ht_state	./include/types/proto_http.h	/^enum ht_state {$/;"	g
html_static_path	./doc/lua-api/conf.py	/^html_static_path = ['_static']$/;"	v
html_theme	./doc/lua-api/conf.py	/^html_theme = 'default'$/;"	v
htmlhelp_basename	./doc/lua-api/conf.py	/^htmlhelp_basename = 'haproxy-luadoc'$/;"	v
htonll	./include/common/standard.h	/^static inline unsigned long long htonll(unsigned long long a)$/;"	f
http	./include/types/action.h	/^		} http;$/;"	m	union:act_rule::__anon9	typeref:struct:act_rule::__anon9::__anon13
http	./include/types/counters.h	/^		} http;$/;"	m	union:pxcounters::__anon57	typeref:struct:pxcounters::__anon57::__anon58
http	./include/types/counters.h	/^		} http;$/;"	m	union:srvcounters::__anon59	typeref:struct:srvcounters::__anon59::__anon60
http_100_chunk	./src/proto_http.c	/^const struct chunk http_100_chunk = {$/;"	v	typeref:struct:chunk
http_action_req_capture	./src/proto_http.c	/^enum act_return http_action_req_capture(struct act_rule *rule, struct proxy *px,$/;"	f
http_action_req_capture_by_id	./src/proto_http.c	/^enum act_return http_action_req_capture_by_id(struct act_rule *rule, struct proxy *px,$/;"	f
http_action_res_capture_by_id	./src/proto_http.c	/^enum act_return http_action_res_capture_by_id(struct act_rule *rule, struct proxy *px,$/;"	f
http_action_set_req_line	./src/proto_http.c	/^enum act_return http_action_set_req_line(struct act_rule *rule, struct proxy *px,$/;"	f
http_adjust_conn_mode	./src/proto_http.c	/^void http_adjust_conn_mode(struct stream *s, struct http_txn *txn, struct http_msg *msg)$/;"	f
http_alloc_txn	./src/proto_http.c	/^struct http_txn *http_alloc_txn(struct stream *s)$/;"	f
http_apply_redirect_rule	./src/proto_http.c	/^static int http_apply_redirect_rule(struct redirect_rule *rule, struct stream *s, struct http_txn *txn)$/;"	f	file:
http_auth_data	./include/types/proto_http.h	/^struct http_auth_data {$/;"	s
http_body_bytes	./include/proto/proto_http.h	/^static inline int http_body_bytes(const struct http_msg *msg)$/;"	f
http_body_rewind	./include/proto/proto_http.h	/^static inline int http_body_rewind(const struct http_msg *msg)$/;"	f
http_capture_bad_message	./src/proto_http.c	/^void http_capture_bad_message(struct error_snapshot *es, struct stream *s,$/;"	f
http_change_connection_header	./src/proto_http.c	/^void http_change_connection_header(struct http_txn *txn, struct http_msg *msg, int wanted)$/;"	f
http_compression_buffer_add_data	./src/compression.c	/^int http_compression_buffer_add_data(struct stream *s, struct buffer *in, struct buffer *out)$/;"	f
http_compression_buffer_end	./src/compression.c	/^int http_compression_buffer_end(struct stream *s, struct buffer **in, struct buffer **out, int end)$/;"	f
http_compression_buffer_init	./src/compression.c	/^int http_compression_buffer_init(struct stream *s, struct buffer *in, struct buffer *out)$/;"	f
http_data_rewind	./include/proto/proto_http.h	/^static inline int http_data_rewind(const struct http_msg *msg)$/;"	f
http_emit_chunk_size	./src/compression.c	/^int http_emit_chunk_size(char *end, unsigned int chksz)$/;"	f
http_encode_map	./src/proto_http.c	/^fd_set http_encode_map[(sizeof(fd_set) > (256\/8)) ? 1 : ((256\/8) \/ sizeof(fd_set))];$/;"	v
http_end_txn	./src/proto_http.c	/^void http_end_txn(struct stream *s)$/;"	f
http_end_txn_clean_session	./src/proto_http.c	/^void http_end_txn_clean_session(struct stream *s)$/;"	f
http_err_chunks	./src/proto_http.c	/^struct chunk http_err_chunks[HTTP_ERR_SIZE];$/;"	v	typeref:struct:chunk
http_err_cnt	./include/types/stick_table.h	/^	unsigned int http_err_cnt;$/;"	m	union:stktable_data
http_err_codes	./src/proto_http.c	/^const int http_err_codes[HTTP_ERR_SIZE] = {$/;"	v
http_err_msgs	./src/proto_http.c	/^static const char *http_err_msgs[HTTP_ERR_SIZE] = {$/;"	v	file:
http_err_rate	./include/types/stick_table.h	/^	struct freq_ctr_period http_err_rate;$/;"	m	union:stktable_data	typeref:struct:stktable_data::freq_ctr_period
http_error_message	./src/proto_http.c	/^struct chunk *http_error_message(struct stream *s, int msgnum)$/;"	f
http_find_full_header2	./src/proto_http.c	/^int http_find_full_header2(const char *name, int len,$/;"	f
http_find_header	./src/proto_http.c	/^int http_find_header(const char *name,$/;"	f
http_find_header2	./src/proto_http.c	/^int http_find_header2(const char *name, int len,$/;"	f
http_find_next_header	./src/proto_http.c	/^int http_find_next_header(char *sol, struct hdr_idx *idx, struct hdr_ctx *ctx)$/;"	f
http_forward_trailers	./src/proto_http.c	/^static int http_forward_trailers(struct http_msg *msg)$/;"	f	file:
http_get_fhdr	./src/proto_http.c	/^unsigned int http_get_fhdr(const struct http_msg *msg, const char *hname, int hlen,$/;"	f
http_get_hdr	./src/proto_http.c	/^unsigned int http_get_hdr(const struct http_msg *msg, const char *hname, int hlen,$/;"	f
http_get_path	./src/proto_http.c	/^char *http_get_path(struct http_txn *txn)$/;"	f
http_get_path_from_string	./src/proto_http.c	/^http_get_path_from_string(char *str)$/;"	f	file:
http_handle_stats	./src/proto_http.c	/^int http_handle_stats(struct stream *s, struct channel *req)$/;"	f
http_hdr_rewind	./include/proto/proto_http.h	/^static inline int http_hdr_rewind(const struct http_msg *msg)$/;"	f
http_header_add_tail	./src/proto_http.c	/^int http_header_add_tail(struct http_msg *msg, struct hdr_idx *hdr_idx, const char *text)$/;"	f
http_header_add_tail2	./src/proto_http.c	/^int http_header_add_tail2(struct http_msg *msg,$/;"	f
http_header_match2	./src/proto_http.c	/^int http_header_match2(const char *hdr, const char *end,$/;"	f
http_init_txn	./src/proto_http.c	/^void http_init_txn(struct stream *s)$/;"	f
http_is_crlf	./src/proto_http.c	/^const char http_is_crlf[256] = {$/;"	v
http_is_ctl	./src/proto_http.c	/^const char http_is_ctl[256] = {$/;"	v
http_is_lws	./src/proto_http.c	/^const char http_is_lws[256] = {$/;"	v
http_is_sep	./src/proto_http.c	/^const char http_is_sep[256] = {$/;"	v
http_is_spht	./src/proto_http.c	/^const char http_is_spht[256] = {$/;"	v
http_is_token	./src/proto_http.c	/^const char http_is_token[256] = {$/;"	v
http_is_ver_token	./src/proto_http.c	/^const char http_is_ver_token[256] = {$/;"	v
http_known_methods	./src/proto_http.c	/^const struct http_method_name http_known_methods[HTTP_METH_OTHER] = {$/;"	v	typeref:struct:http_method_name
http_meth_t	./include/types/sample.h	/^enum http_meth_t {$/;"	g
http_method_desc	./src/proto_http.c	/^struct http_method_desc {$/;"	s	file:
http_method_name	./include/types/proto_http.h	/^struct http_method_name {$/;"	s
http_methods	./src/proto_http.c	/^const struct http_method_desc http_methods[26][3] = {$/;"	v	typeref:struct:http_method_desc
http_msg	./include/types/proto_http.h	/^struct http_msg {$/;"	s
http_msg_analyzer	./src/proto_http.c	/^void http_msg_analyzer(struct http_msg *msg, struct hdr_idx *idx)$/;"	f
http_msg_move_end	./include/proto/proto_http.h	/^#define http_msg_move_end(/;"	d
http_msg_state_str	./include/proto/proto_http.h	/^static inline const char *http_msg_state_str(int msg_state)$/;"	f
http_needed	./include/types/proxy.h	/^	unsigned int http_needed;               \/* non-null if HTTP analyser may be used *\/$/;"	m	struct:proxy
http_parse_chunk_size	./src/proto_http.c	/^static inline int http_parse_chunk_size(struct http_msg *msg)$/;"	f	file:
http_parse_connection_header	./src/proto_http.c	/^void http_parse_connection_header(struct http_txn *txn, struct http_msg *msg, int to_del)$/;"	f
http_parse_redirect_rule	./src/proto_http.c	/^struct redirect_rule *http_parse_redirect_rule(const char *file, int linenum, struct proxy *curproxy,$/;"	f
http_parse_reqline	./src/proto_http.c	/^const char *http_parse_reqline(struct http_msg *msg,$/;"	f
http_parse_stsline	./src/proto_http.c	/^const char *http_parse_stsline(struct http_msg *msg,$/;"	f
http_perform_server_redirect	./src/proto_http.c	/^void http_perform_server_redirect(struct stream *s, struct stream_interface *si)$/;"	f
http_process_req_common	./src/proto_http.c	/^int http_process_req_common(struct stream *s, struct channel *req, int an_bit, struct proxy *px)$/;"	f
http_process_request	./src/proto_http.c	/^int http_process_request(struct stream *s, struct channel *req, int an_bit)$/;"	f
http_process_res_common	./src/proto_http.c	/^int http_process_res_common(struct stream *s, struct channel *rep, int an_bit, struct proxy *px)$/;"	f
http_process_tarpit	./src/proto_http.c	/^int http_process_tarpit(struct stream *s, struct channel *req, int an_bit)$/;"	f
http_remove_header2	./src/proto_http.c	/^int http_remove_header2(struct http_msg *msg, struct hdr_idx *idx, struct hdr_ctx *ctx)$/;"	f
http_replace_req_line	./src/proto_http.c	/^int http_replace_req_line(int action, const char *replace, int len,$/;"	f
http_req_actions	./src/proto_http.c	/^struct action_kw_list http_req_actions = {$/;"	v	typeref:struct:action_kw_list
http_req_actions	./src/proto_tcp.c	/^static struct action_kw_list http_req_actions = {ILH, {$/;"	v	typeref:struct:action_kw_list	file:
http_req_cnt	./include/types/stick_table.h	/^	unsigned int http_req_cnt;$/;"	m	union:stktable_data
http_req_get_intercept_rule	./src/proto_http.c	/^http_req_get_intercept_rule(struct proxy *px, struct list *rules, struct stream *s)$/;"	f
http_req_keywords	./src/proto_http.c	/^struct action_kw_list http_req_keywords = {$/;"	v	typeref:struct:action_kw_list
http_req_keywords_register	./include/proto/proto_http.h	/^static inline void http_req_keywords_register(struct action_kw_list *kw_list)$/;"	f
http_req_kws	./src/stick_table.c	/^static struct action_kw_list http_req_kws = { { }, {$/;"	v	typeref:struct:action_kw_list	file:
http_req_kws	./src/vars.c	/^static struct action_kw_list http_req_kws = { { }, {$/;"	v	typeref:struct:action_kw_list	file:
http_req_rate	./include/types/stick_table.h	/^	struct freq_ctr_period http_req_rate;$/;"	m	union:stktable_data	typeref:struct:stktable_data::freq_ctr_period
http_req_rules	./include/common/uri_auth.h	/^	struct list http_req_rules;	\/* stats http-request rules : allow\/deny\/auth *\/$/;"	m	struct:uri_auth	typeref:struct:uri_auth::list
http_req_rules	./include/types/proxy.h	/^	struct list http_req_rules;		\/* HTTP request rules: allow\/deny\/... *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
http_req_trk_idx	./include/proto/proto_http.h	/^static inline int http_req_trk_idx(int trk_action)$/;"	f
http_request_forward_body	./src/proto_http.c	/^int http_request_forward_body(struct stream *s, struct channel *req, int an_bit)$/;"	f
http_res_actions	./src/proto_http.c	/^struct action_kw_list http_res_actions = {$/;"	v	typeref:struct:action_kw_list
http_res_actions	./src/proto_tcp.c	/^static struct action_kw_list http_res_actions = {ILH, {$/;"	v	typeref:struct:action_kw_list	file:
http_res_get_intercept_rule	./src/proto_http.c	/^http_res_get_intercept_rule(struct proxy *px, struct list *rules, struct stream *s)$/;"	f	file:
http_res_keywords	./src/proto_http.c	/^struct action_kw_list http_res_keywords = {$/;"	v	typeref:struct:action_kw_list
http_res_keywords_register	./include/proto/proto_http.h	/^static inline void http_res_keywords_register(struct action_kw_list *kw_list)$/;"	f
http_res_kws	./src/stick_table.c	/^static struct action_kw_list http_res_kws = { { }, {$/;"	v	typeref:struct:action_kw_list	file:
http_res_kws	./src/vars.c	/^static struct action_kw_list http_res_kws = { { }, {$/;"	v	typeref:struct:action_kw_list	file:
http_res_rules	./include/types/proxy.h	/^	struct list http_res_rules;		\/* HTTP response rules: allow\/deny\/... *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
http_reset_txn	./src/proto_http.c	/^void http_reset_txn(struct stream *s)$/;"	f
http_response_forward_body	./src/proto_http.c	/^int http_response_forward_body(struct stream *s, struct channel *res, int an_bit)$/;"	f
http_resync_states	./src/proto_http.c	/^int http_resync_states(struct stream *s)$/;"	f
http_return_srv_error	./src/proto_http.c	/^void http_return_srv_error(struct stream *s, struct stream_interface *si)$/;"	f
http_scheme	./include/common/standard.h	/^enum http_scheme {$/;"	g
http_send_name_header	./src/proto_http.c	/^int http_send_name_header(struct http_txn *txn, struct proxy* be, const char* srv_name) {$/;"	f
http_server_error	./src/proto_http.c	/^static void http_server_error(struct stream *s, struct stream_interface *si,$/;"	f	file:
http_set_realm	./src/uri_auth.c	/^struct uri_auth *http_set_realm(struct uri_auth **root, char *realm, char *default_uri)$/;"	f
http_set_refresh	./src/uri_auth.c	/^struct uri_auth *http_set_refresh(struct uri_auth **root, int interval, char *default_uri)$/;"	f
http_set_status	./src/proto_http.c	/^void http_set_status(unsigned int status, struct stream *s)$/;"	f
http_set_uri	./src/uri_auth.c	/^struct uri_auth *http_set_uri(struct uri_auth **root, char *uri,char *default_uri)$/;"	f
http_skip_chunk_crlf	./src/proto_http.c	/^static inline int http_skip_chunk_crlf(struct http_msg *msg)$/;"	f	file:
http_stats_applet	./src/dumpstats.c	/^struct applet http_stats_applet = {$/;"	v	typeref:struct:applet
http_stats_io_handler	./src/dumpstats.c	/^static void http_stats_io_handler(struct appctx *appctx)$/;"	f	file:
http_sync_req_state	./src/proto_http.c	/^int http_sync_req_state(struct stream *s)$/;"	f
http_sync_res_state	./src/proto_http.c	/^int http_sync_res_state(struct stream *s)$/;"	f
http_transform_header	./src/proto_http.c	/^static int http_transform_header(struct stream* s, struct http_msg *msg,$/;"	f	file:
http_transform_header_str	./src/proto_http.c	/^int http_transform_header_str(struct stream* s, struct http_msg *msg,$/;"	f
http_txn	./include/types/proto_http.h	/^struct http_txn {$/;"	s
http_txn_reset_req	./src/proto_http.c	/^void http_txn_reset_req(struct http_txn *txn)$/;"	f
http_txn_reset_res	./src/proto_http.c	/^void http_txn_reset_res(struct http_txn *txn)$/;"	f
http_upgrade_v09_to_v10	./src/proto_http.c	/^static int http_upgrade_v09_to_v10(struct http_txn *txn)$/;"	f	file:
http_uri_rewind	./include/proto/proto_http.h	/^static inline int http_uri_rewind(const struct http_msg *msg)$/;"	f
http_wait_for_request	./src/proto_http.c	/^int http_wait_for_request(struct stream *s, struct channel *req, int an_bit)$/;"	f
http_wait_for_request_body	./src/proto_http.c	/^int http_wait_for_request_body(struct stream *s, struct channel *req, int an_bit)$/;"	f
http_wait_for_response	./src/proto_http.c	/^int http_wait_for_response(struct stream *s, struct channel *rep, int an_bit)$/;"	f
httpchk_build_status_header	./src/checks.c	/^static int httpchk_build_status_header(struct server *s, char *buffer, int size)$/;"	f	file:
httpchk_expect	./src/checks.c	/^static int httpchk_expect(struct server *s, int done)$/;"	f	file:
httpka	./include/types/proxy.h	/^		int httpka;                     \/* maximum time for a new HTTP request when using keep-alive *\/$/;"	m	struct:proxy::__anon108
httpreq	./include/types/proxy.h	/^		int httpreq;                    \/* maximum time for complete HTTP request *\/$/;"	m	struct:proxy::__anon108
htxn	./include/types/hlua.h	/^	struct hlua_txn htxn;$/;"	m	struct:hlua_appctx	typeref:struct:hlua_appctx::hlua_txn
human_time	./src/standard.c	/^char *human_time(int t, short hz_div) {$/;"	f
i	./include/common/buffer.h	/^	unsigned int i;                 \/* number of input bytes pending for analysis in the buffer *\/$/;"	m	struct:buffer
i	./include/types/pattern.h	/^		int i;                          \/* integer value *\/$/;"	m	union:pattern::__anon87
i	./include/types/sample.h	/^	int i;          \/* any integer *\/$/;"	m	union:smp_ctx
i	./include/types/stick_table.h	/^		int i;$/;"	m	union:stktable::__anon128
id	./include/types/dns.h	/^	char *id;			\/* nameserver unique identifier *\/$/;"	m	struct:dns_nameserver
id	./include/types/dns.h	/^	char *id;			\/* resolvers unique identifier *\/$/;"	m	struct:dns_resolvers
id	./include/types/dns.h	/^	unsigned short	id:16;		\/* identifier *\/$/;"	m	struct:dns_header
id	./include/types/listener.h	/^		struct eb32_node id;	\/* place in the tree of used IDs *\/$/;"	m	struct:listener::__anon78	typeref:struct:listener::__anon78::eb32_node
id	./include/types/mailers.h	/^	char *id;			\/* mailers section name *\/$/;"	m	struct:mailers
id	./include/types/mailers.h	/^	char *id;$/;"	m	struct:mailer
id	./include/types/peers.h	/^	char *id;			 \/* peer section name *\/$/;"	m	struct:peers
id	./include/types/peers.h	/^	char *id;$/;"	m	struct:peer
id	./include/types/proxy.h	/^		struct eb32_node id;		\/* place in the tree of used IDs *\/$/;"	m	struct:proxy::__anon109	typeref:struct:proxy::__anon109::eb32_node
id	./include/types/proxy.h	/^	char *id, *desc;			\/* proxy id (name) and description *\/$/;"	m	struct:proxy
id	./include/types/server.h	/^		struct eb32_node id;		\/* place in the tree of used IDs *\/$/;"	m	struct:server::__anon123	typeref:struct:server::__anon123::eb32_node
id	./include/types/server.h	/^	char *id;				\/* just for identification *\/$/;"	m	struct:server
id	./include/types/stick_table.h	/^	char *id;		  \/* table id name *\/$/;"	m	struct:stktable
id	./src/shctx.c	/^	unsigned char id[SSL_MAX_SSL_SESSION_ID_LENGTH];$/;"	m	struct:shsess_packet_hdr	file:
identity_add_data	./src/compression.c	/^static int identity_add_data(struct comp_ctx *comp_ctx, const char *in_data, int in_len, struct buffer *out)$/;"	f	file:
identity_end	./src/compression.c	/^static int identity_end(struct comp_ctx **comp_ctx)$/;"	f	file:
identity_finish	./src/compression.c	/^static int identity_finish(struct comp_ctx *comp_ctx, struct buffer *out)$/;"	f	file:
identity_flush	./src/compression.c	/^static int identity_flush(struct comp_ctx *comp_ctx, struct buffer *out)$/;"	f	file:
identity_init	./src/compression.c	/^static int identity_init(struct comp_ctx **comp_ctx, int level)$/;"	f	file:
idle_conns	./include/types/server.h	/^	struct list idle_conns;			\/* sharable idle connections attached or not to a stream interface *\/$/;"	m	struct:server	typeref:struct:server::list
idle_pct	./src/time.c	/^unsigned int   idle_pct;        \/* idle to total ratio over last sample (percent) *\/$/;"	v
idle_time	./src/time.c	/^unsigned int   idle_time;       \/* total idle time over current sample *\/$/;"	v
idle_timer	./include/types/global.h	/^		unsigned short idle_timer; \/* how long before an empty buffer is considered idle (ms) *\/$/;"	m	struct:global::__anon72
idx	./include/types/action.h	/^			int idx;$/;"	m	struct:act_rule::__anon9::__anon16
idx	./include/types/proto_http.h	/^	int  idx;$/;"	m	struct:hdr_ctx
iface_len	./include/types/connection.h	/^	int iface_len;                       \/* bind interface name length *\/$/;"	m	struct:conn_src
iface_name	./include/types/connection.h	/^	char *iface_name;                    \/* bind interface name or NULL *\/$/;"	m	struct:conn_src
ignore_implicit	./Makefile	/^ignore_implicit = $(patsubst %=implicit,,$(1)=$($(1)))$/;"	m
iid	./include/types/applet.h	/^			int iid, type, sid;	\/* proxy id, type and service id if bounding of stats is enabled *\/$/;"	m	struct:appctx::__anon21::__anon22
iid	./include/types/applet.h	/^			int iid;		\/* if >= 0, ID of the proxy to filter on *\/$/;"	m	struct:appctx::__anon21::__anon24
in6_bswap	./contrib/ip6range/ip6range.c	/^static inline void in6_bswap(struct in6_addr *a)$/;"	f	file:
in_net_ipv4	./src/standard.c	/^int in_net_ipv4(struct in_addr *addr, struct in_addr *mask, struct in_addr *net)$/;"	f
in_net_ipv6	./src/standard.c	/^int in_net_ipv6(struct in6_addr *addr, struct in6_addr *mask, struct in6_addr *net)$/;"	f
in_type	./include/types/sample.h	/^	unsigned int in_type;                     \/* expected input sample type *\/$/;"	m	struct:sample_conv
indent_msg	./src/standard.c	/^char *indent_msg(char **out, int level)$/;"	f
index	./include/types/acl.h	/^	int (*index)(struct pattern_expr *expr, struct pattern *pattern, char **err);$/;"	m	struct:acl_keyword
index	./include/types/capture.h	/^    int index;				\/* index in the output array *\/$/;"	m	struct:cap_hdr
index	./include/types/pattern.h	/^	int (*index)(struct pattern_expr *, struct pattern *, char **);$/;"	m	struct:pattern_head
inet_set_tos	./src/proto_http.c	/^void inet_set_tos(int fd, struct sockaddr_storage from, int tos)$/;"	f
inetaddr_host	./src/standard.c	/^unsigned int inetaddr_host(const char *text)$/;"	f
inetaddr_host_lim	./src/standard.c	/^unsigned int inetaddr_host_lim(const char *text, const char *stop)$/;"	f
inetaddr_host_lim_ret	./src/standard.c	/^unsigned int inetaddr_host_lim_ret(char *text, char *stop, char **ret)$/;"	f
info	./include/types/checks.h	/^	char *info;			\/* human readable short info *\/$/;"	m	struct:check_status
init	./include/types/applet.h	/^	int (*init)(struct appctx *, struct proxy *px, struct stream *strm);   \/* callback to init ressources, may be NULL.$/;"	m	struct:applet
init	./include/types/compression.h	/^	int (*init)(struct comp_ctx **comp_ctx, int level);$/;"	m	struct:comp_algo
init	./include/types/connection.h	/^	int  (*init)(struct connection *conn);      \/* initialize the transport layer *\/$/;"	m	struct:xprt_ops
init	./include/types/connection.h	/^	int  (*init)(struct connection *conn);  \/* data-layer initialization *\/$/;"	m	struct:data_cb
init	./include/types/fd.h	/^	int  REGPRM1   (*init)(struct poller *p);            \/* poller initialization *\/$/;"	m	struct:poller
init	./include/types/lb_fwrr.h	/^	struct eb_root *init;   \/* servers waiting to be placed *\/$/;"	m	struct:fwrr_group	typeref:struct:fwrr_group::eb_root
init	./src/haproxy-systemd-wrapper.c	/^static void init(int argc, char **argv)$/;"	f	file:
init	./src/haproxy.c	/^void init(int argc, char **argv)$/;"	f
init_51degrees	./src/51d.c	/^int init_51degrees(void)$/;"	f
init_acl	./src/acl.c	/^int init_acl()$/;"	f
init_buffer	./src/buffer.c	/^int init_buffer()$/;"	f
init_check	./src/checks.c	/^const char *init_check(struct check *check, int type)$/;"	f
init_comp_ctx	./src/compression.c	/^static inline int init_comp_ctx(struct comp_ctx **comp_ctx)$/;"	f	file:
init_connection	./src/connection.c	/^int init_connection()$/;"	f
init_default_instance	./src/cfgparse.c	/^void init_default_instance()$/;"	f
init_default_namespace	./src/namespace.c	/^static int init_default_namespace()$/;"	f	file:
init_deviceatlas	./src/da.c	/^int init_deviceatlas(void)$/;"	f
init_email_alert_checks	./src/checks.c	/^static int init_email_alert_checks(struct server *s)$/;"	f	file:
init_new_proxy	./src/proxy.c	/^void init_new_proxy(struct proxy *p)$/;"	f
init_pendconn	./src/queue.c	/^int init_pendconn()$/;"	f
init_pid_list	./src/checks.c	/^static int init_pid_list(void) {$/;"	f	file:
init_pipe	./src/pipe.c	/^static void init_pipe()$/;"	f	file:
init_pollers	./src/fd.c	/^int init_pollers()$/;"	f
init_proto_http	./src/proto_http.c	/^void init_proto_http()$/;"	f
init_server_map	./src/lb_map.c	/^void init_server_map(struct proxy *p)$/;"	f
init_session	./src/session.c	/^int init_session()$/;"	f
init_stream	./src/stream.c	/^int init_stream()$/;"	f
init_task	./src/task.c	/^int init_task()$/;"	f
init_tree	./tests/filltab25.c	/^struct eb_root *init_tree; \/* receives positions 0..sw-1 *\/$/;"	v	typeref:struct:eb_root
input_type	./src/sample.c	/^enum input_type {$/;"	g	file:
insert_timer	./contrib/halog/halog.c	/^struct timer *insert_timer(struct eb_root *r, struct timer **alloc, int v)$/;"	f
insert_value	./contrib/halog/halog.c	/^struct timer *insert_value(struct eb_root *r, struct timer **alloc, int v)$/;"	f
inspect_delay	./include/types/proxy.h	/^		unsigned int inspect_delay;     \/* inspection delay *\/$/;"	m	struct:proxy::__anon106
inspect_delay	./include/types/proxy.h	/^		unsigned int inspect_delay;     \/* inspection delay *\/$/;"	m	struct:proxy::__anon107
inspect_rules	./include/types/proxy.h	/^		struct list inspect_rules;      \/* inspection rules *\/$/;"	m	struct:proxy::__anon106	typeref:struct:proxy::__anon106::list
inspect_rules	./include/types/proxy.h	/^		struct list inspect_rules;      \/* inspection rules *\/$/;"	m	struct:proxy::__anon107	typeref:struct:proxy::__anon107::list
intdecode	./src/peers.c	/^uint64_t intdecode(char **str, char *end) {$/;"	f
intencode	./src/peers.c	/^int intencode(uint64_t i, char **str) {$/;"	f
inter	./include/types/checks.h	/^	int inter, fastinter, downinter;        \/* checks: time in milliseconds *\/$/;"	m	struct:check
intercepted_req	./include/types/counters.h	/^	long long intercepted_req;              \/* number of monitoring or stats requests intercepted by the frontend *\/$/;"	m	struct:pxcounters
interface	./include/types/listener.h	/^	char *interface;		\/* interface name or NULL *\/$/;"	m	struct:listener
invalid	./include/types/dns.h	/^		long int invalid;	\/* - malformed DNS response *\/$/;"	m	struct:dns_nameserver::__anon65
invalid_char	./src/standard.c	/^const char *invalid_char(const char *name)$/;"	f
invalid_domainchar	./src/standard.c	/^const char *invalid_domainchar(const char *name) {$/;"	f
invalid_rep	./include/types/proxy.h	/^	struct error_snapshot invalid_req, invalid_rep; \/* captures of last errors *\/$/;"	m	struct:proxy	typeref:struct:proxy::
invalid_req	./include/types/proxy.h	/^	struct error_snapshot invalid_req, invalid_rep; \/* captures of last errors *\/$/;"	m	struct:proxy	typeref:struct:proxy::error_snapshot
inverse	./include/types/checks.h	/^	int inverse;                            \/* 0 = regular match, 1 = inverse match *\/$/;"	m	struct:tcpcheck_rule
iocb	./include/types/fd.h	/^	int (*iocb)(int fd);                 \/* I\/O handler, returns FD_WAIT_* *\/$/;"	m	struct:fdtab
ip4	./include/types/connection.h	/^		} ip4;$/;"	m	union:proxy_hdr_v2::__anon53	typeref:struct:proxy_hdr_v2::__anon53::__anon54
ip6	./include/types/connection.h	/^		} ip6;$/;"	m	union:proxy_hdr_v2::__anon53	typeref:struct:proxy_hdr_v2::__anon53::__anon55
ipv4	./include/types/arg.h	/^	struct in_addr ipv4;$/;"	m	union:arg_data	typeref:struct:arg_data::in_addr
ipv4	./include/types/pattern.h	/^		} ipv4;                         \/* IPv4 address *\/$/;"	m	union:pattern::__anon87	typeref:struct:pattern::__anon87::__anon89
ipv4	./include/types/sample.h	/^	struct in_addr  ipv4;  \/* used for ipv4 addresses *\/$/;"	m	union:sample_value	typeref:struct:sample_value::in_addr
ipv6	./include/types/arg.h	/^	struct in6_addr ipv6;$/;"	m	union:arg_data	typeref:struct:arg_data::in6_addr
ipv6	./include/types/pattern.h	/^		} ipv6;                         \/* IPv6 address\/mask *\/$/;"	m	union:pattern::__anon87	typeref:struct:pattern::__anon87::__anon90
ipv6	./include/types/sample.h	/^	struct in6_addr ipv6;  \/* used for ipv6 addresses *\/$/;"	m	union:sample_value	typeref:struct:sample_value::in6_addr
is_addr	./include/common/standard.h	/^static inline int is_addr(const struct sockaddr_storage *addr)$/;"	f
is_delimiter	./src/pattern.c	/^static inline unsigned int is_delimiter(unsigned char c, unsigned int mask)$/;"	f	file:
is_inet_addr	./include/common/standard.h	/^static inline int is_inet_addr(const struct sockaddr_storage *addr)$/;"	f
is_param_delimiter	./src/proto_http.c	/^static inline int is_param_delimiter(char c, char delim)$/;"	f	file:
is_set	./contrib/ip6range/ip6range.c	/^int is_set(struct in6_addr *a)$/;"	f
is_ssl	./include/types/listener.h	/^	int is_ssl;                \/* SSL is required for these listeners *\/$/;"	m	struct:bind_conf
ishex	./src/standard.c	/^int ishex(char s)$/;"	f
itoa_idx	./src/standard.c	/^int itoa_idx = 0; \/* index of next itoa_str to use *\/$/;"	v
itoa_str	./src/standard.c	/^char itoa_str[NB_ITOA_STR][171];$/;"	v
iweight	./include/types/server.h	/^	unsigned iweight,uweight, eweight;	\/* initial weight, user-specified weight, and effective weight *\/$/;"	m	struct:server
jobs	./src/haproxy.c	/^int jobs = 0;   \/* number of active jobs (conns, listeners, active tasks, ...) *\/$/;"	v
jsonpath	./include/types/global.h	/^		char *jsonpath;$/;"	m	struct:global::__anon75
kev	./src/ev_kqueue.c	/^static struct kevent *kev = NULL;$/;"	v	typeref:struct:kevent	file:
key	./ebtree/eb32tree.h	/^	u32 key;$/;"	m	struct:eb32_node
key	./ebtree/eb64tree.h	/^	u64 key;$/;"	m	struct:eb64_node
key	./ebtree/ebmbtree.h	/^	unsigned char key[0]; \/* the key, its size depends on the application *\/$/;"	m	struct:ebmb_node
key	./ebtree/ebpttree.h	/^	void *key;$/;"	m	struct:ebpt_node
key	./include/types/action.h	/^			struct list key;       \/* pattern to retrieve MAP or ACL key *\/$/;"	m	struct:act_rule::__anon9::__anon12	typeref:struct:act_rule::__anon9::__anon12::list
key	./include/types/stick_table.h	/^	struct ebmb_node key;     \/* ebtree node used to hold the session in table *\/$/;"	m	struct:stksess	typeref:struct:stksess::ebmb_node
key	./include/types/stick_table.h	/^	void *key;                      \/* pointer on key buffer *\/$/;"	m	struct:stktable_key
key	./src/shctx.c	/^	struct ebmb_node key;$/;"	m	struct:shared_session	typeref:struct:shared_session::ebmb_node	file:
key	./src/ssl_sock.c	/^	struct ebmb_node key;$/;"	m	struct:certificate_ocsp	typeref:struct:certificate_ocsp::ebmb_node	file:
key_data	./src/shctx.c	/^	unsigned char key_data[SSL_MAX_SSL_SESSION_ID_LENGTH];$/;"	m	struct:shared_session	file:
key_data	./src/ssl_sock.c	/^	unsigned char key_data[OCSP_MAX_CERTID_ASN1_LENGTH];$/;"	m	struct:certificate_ocsp	file:
key_len	./include/types/stick_table.h	/^	size_t key_len;                 \/* data len to read in buff in case of null terminated string *\/$/;"	m	struct:stktable_key
key_size	./include/types/stick_table.h	/^	size_t key_size;          \/* size of a key, maximum size in case of string *\/$/;"	m	struct:stktable
keys	./include/import/lru.h	/^	struct eb_root keys;$/;"	m	struct:lru64_head	typeref:struct:lru64_head::eb_root
keys	./include/types/stick_table.h	/^	struct eb_root keys;      \/* head of sticky session tree *\/$/;"	m	struct:stktable	typeref:struct:stktable::eb_root
keys_ref	./include/types/listener.h	/^	struct tls_keys_ref *keys_ref; \/* TLS ticket keys reference *\/$/;"	m	struct:bind_conf	typeref:struct:bind_conf::tls_keys_ref
kill_pipe	./src/pipe.c	/^void kill_pipe(struct pipe *p)$/;"	f
kqueue_fd	./src/ev_kqueue.c	/^static int kqueue_fd;$/;"	v	file:
kr_hash	./tests/test_hashes.c	/^unsigned kr_hash(char *s){$/;"	f
kw	./include/common/cfgparse.h	/^	const char *kw;                         \/* the keyword itself *\/$/;"	m	struct:cfg_keyword
kw	./include/common/cfgparse.h	/^	struct cfg_keyword kw[VAR_ARRAY];$/;"	m	struct:cfg_kw_list	typeref:struct:cfg_kw_list::cfg_keyword
kw	./include/types/acl.h	/^	const char *kw;               \/* points to the ACL kw's name or fetch's name (must not free) *\/$/;"	m	struct:acl_expr
kw	./include/types/acl.h	/^	const char *kw;$/;"	m	struct:acl_keyword
kw	./include/types/acl.h	/^	struct acl_keyword kw[VAR_ARRAY];$/;"	m	struct:acl_kw_list	typeref:struct:acl_kw_list::acl_keyword
kw	./include/types/action.h	/^	const char *kw;$/;"	m	struct:action_kw
kw	./include/types/action.h	/^	struct action_kw *kw;$/;"	m	struct:act_rule	typeref:struct:act_rule::action_kw
kw	./include/types/action.h	/^	struct action_kw kw[VAR_ARRAY];$/;"	m	struct:action_kw_list	typeref:struct:action_kw_list::action_kw
kw	./include/types/arg.h	/^	const char *kw;           \/* keyword making use of these args *\/$/;"	m	struct:arg_list
kw	./include/types/listener.h	/^	const char *kw;$/;"	m	struct:bind_kw
kw	./include/types/listener.h	/^	struct bind_kw kw[VAR_ARRAY];$/;"	m	struct:bind_kw_list	typeref:struct:bind_kw_list::bind_kw
kw	./include/types/sample.h	/^	const char *kw;                           \/* configuration keyword  *\/$/;"	m	struct:sample_conv
kw	./include/types/sample.h	/^	const char *kw;                           \/* configuration keyword *\/$/;"	m	struct:sample_fetch
kw	./include/types/sample.h	/^	struct sample_conv kw[VAR_ARRAY];         \/* array of sample conversion descriptors *\/$/;"	m	struct:sample_conv_kw_list	typeref:struct:sample_conv_kw_list::sample_conv
kw	./include/types/sample.h	/^	struct sample_fetch kw[VAR_ARRAY];        \/* array of sample fetch descriptors *\/$/;"	m	struct:sample_fetch_kw_list	typeref:struct:sample_fetch_kw_list::sample_fetch
kw	./include/types/server.h	/^	const char *kw;$/;"	m	struct:srv_kw
kw	./include/types/server.h	/^	struct srv_kw kw[VAR_ARRAY];$/;"	m	struct:srv_kw_list	typeref:struct:srv_kw_list::srv_kw
kw	./include/types/stick_table.h	/^	const char *kw;           \/* keyword string *\/$/;"	m	struct:stktable_type
kw_mod	./src/cfgparse.c	/^enum kw_mod {$/;"	g	file:
l	./include/types/applet.h	/^			void *l;$/;"	m	struct:appctx::__anon21::__anon22
l	./include/types/hlua.h	/^	struct list l;$/;"	m	struct:hlua_init_function	typeref:struct:hlua_init_function::list
l	./include/types/proto_http.h	/^			int l;                 \/* request line length (not including CR) *\/$/;"	m	struct:http_msg::__anon99::__anon100
l	./include/types/proto_http.h	/^			int l;                 \/* status line length (not including CR) *\/$/;"	m	struct:http_msg::__anon99::__anon101
l	./include/types/vars.h	/^	struct list l; \/* Used for chaining vars. *\/$/;"	m	struct:var	typeref:struct:var::list
l3_addrlen	./include/types/protocol.h	/^	int l3_addrlen;					\/* layer3 address length, used by hashes *\/$/;"	m	struct:protocol
l4_rules	./include/types/proxy.h	/^		struct list l4_rules;           \/* layer4 rules *\/$/;"	m	struct:proxy::__anon106	typeref:struct:proxy::__anon106::list
language_range_match	./src/proto_http.c	/^static inline int language_range_match(const char *range, int range_len,$/;"	f	file:
last	./include/types/hdr_idx.h	/^	short last;                 \/* length of the allocated area (1..size) *\/$/;"	m	struct:hdr_idx
last	./include/types/lb_chash.h	/^	struct eb32_node *last;	\/* last node found in case of round robin (or NULL) *\/$/;"	m	struct:lb_chash	typeref:struct:lb_chash::eb32_node
last	./tests/filltab25.c	/^	int next, last;$/;"	m	struct:srv	file:
last_acked	./include/types/peers.h	/^	unsigned int last_acked;$/;"	m	struct:shared_table
last_change	./include/types/peers.h	/^	time_t last_change;$/;"	m	struct:peer
last_change	./include/types/peers.h	/^	time_t last_change;$/;"	m	struct:peers
last_change	./include/types/proxy.h	/^	time_t last_change;			\/* last time, when the state was changed *\/$/;"	m	struct:proxy
last_change	./include/types/server.h	/^	time_t last_change;			\/* last time, when the state was changed *\/$/;"	m	struct:server
last_checks	./include/types/global.h	/^	int last_checks;$/;"	m	struct:global
last_get	./include/types/peers.h	/^	unsigned int last_get;$/;"	m	struct:shared_table
last_local_table	./include/types/peers.h	/^	struct shared_table *last_local_table;$/;"	m	struct:peer	typeref:struct:peer::shared_table
last_pushed	./include/types/peers.h	/^	unsigned int last_pushed;$/;"	m	struct:shared_table
last_read	./include/types/channel.h	/^	unsigned short last_read;       \/* 16 lower bits of last read date (max pause=65s) *\/$/;"	m	struct:channel
last_resolution	./include/types/dns.h	/^	unsigned int last_resolution;	\/* time of the lastest valid resolution *\/$/;"	m	struct:dns_resolution
last_sent_packet	./include/types/dns.h	/^	unsigned int last_sent_packet;	\/* time of the latest DNS packet sent *\/$/;"	m	struct:dns_resolution
last_sess	./include/types/counters.h	/^	unsigned long last_sess;                 \/* last session time *\/$/;"	m	struct:srvcounters
last_sess	./include/types/counters.h	/^	unsigned long last_sess;                \/* last session time *\/$/;"	m	struct:pxcounters
last_started_step	./include/types/checks.h	/^	struct tcpcheck_rule *last_started_step;\/* pointer to latest tcpcheck rule started *\/$/;"	m	struct:check	typeref:struct:check::tcpcheck_rule
last_status_change	./include/types/dns.h	/^	unsigned int last_status_change;	\/* time of the latest DNS resolution status change *\/$/;"	m	struct:dns_resolution
last_timer	./src/task.c	/^struct eb32_node *last_timer = NULL;  \/* optimization: last queued timer *\/$/;"	v	typeref:struct:eb32_node
latex_documents	./doc/lua-api/conf.py	/^latex_documents = [$/;"	v
latex_elements	./doc/lua-api/conf.py	/^latex_elements = {$/;"	v
lb_chash	./include/types/lb_chash.h	/^struct lb_chash {$/;"	s
lb_fas	./include/types/lb_fas.h	/^struct lb_fas {$/;"	s
lb_fwlc	./include/types/lb_fwlc.h	/^struct lb_fwlc {$/;"	s
lb_fwrr	./include/types/lb_fwrr.h	/^struct lb_fwrr {$/;"	s
lb_map	./include/types/lb_map.h	/^struct lb_map {$/;"	s
lb_node	./include/types/server.h	/^	struct eb32_node lb_node;               \/* node used for tree-based load balancing *\/$/;"	m	struct:server	typeref:struct:server::eb32_node
lb_nodes	./include/types/server.h	/^	struct tree_occ *lb_nodes;              \/* lb_nodes_tot * struct tree_occ *\/$/;"	m	struct:server	typeref:struct:server::tree_occ
lb_nodes_now	./include/types/server.h	/^	unsigned lb_nodes_now;                  \/* number of lb_nodes placed in the tree (C-HASH) *\/$/;"	m	struct:server
lb_nodes_tot	./include/types/server.h	/^	unsigned lb_nodes_tot;                  \/* number of allocated lb_nodes (C-HASH) *\/$/;"	m	struct:server
lb_tree	./include/types/server.h	/^	struct eb_root *lb_tree;                \/* we want to know in what tree the server is *\/$/;"	m	struct:server	typeref:struct:server::eb_root
lbprm	./include/types/backend.h	/^struct lbprm {$/;"	s
lbprm	./include/types/proxy.h	/^	struct lbprm lbprm;			\/* load-balancing parameters *\/$/;"	m	struct:proxy	typeref:struct:proxy::lbprm
leaf_p	./ebtree/ebtree.h	/^	eb_troot_t    *leaf_p;  \/* leaf node's parent *\/$/;"	m	struct:eb_node
left_bytes	./include/types/applet.h	/^			int left_bytes; \/* The max amount of bytes that we can read. *\/$/;"	m	struct:appctx::__anon21::__anon32
len	./include/common/chunk.h	/^	int len;	\/* current size of the string from first to last char. <0 = uninit. *\/$/;"	m	struct:chunk
len	./include/types/capture.h	/^    int len;				\/* capture length, not including terminal zero *\/$/;"	m	struct:cap_hdr
len	./include/types/connection.h	/^	uint16_t len;      \/* number of following bytes part of the header *\/$/;"	m	struct:proxy_hdr_v2
len	./include/types/hdr_idx.h	/^        unsigned len  :16; \/* length of this header not counting CRLF. 0=unused entry. *\/$/;"	m	struct:hdr_idx_elem
len	./include/types/pattern.h	/^	int len;                        \/* data length when required  *\/$/;"	m	struct:pattern
len	./include/types/proto_http.h	/^	int len;$/;"	m	struct:http_method_name
len	./include/types/proxy.h	/^	unsigned int len;		\/* original length of the last invalid request\/response *\/$/;"	m	struct:error_snapshot
len	./src/proto_http.c	/^	int len;$/;"	m	struct:http_method_desc	file:
length_hi	./include/types/connection.h	/^	uint8_t length_hi;$/;"	m	struct:tlv
length_lo	./include/types/connection.h	/^	uint8_t length_lo;$/;"	m	struct:tlv
level	./include/types/listener.h	/^	int level;                 \/* stats access level (ACCESS_LVL_*) *\/$/;"	m	struct:bind_conf
level	./include/types/log.h	/^	int level;$/;"	m	struct:logsrv
level	./include/types/proxy.h	/^		int level;			\/* Maximum syslog level of messages to send$/;"	m	struct:proxy::__anon110
level	./include/types/stream.h	/^	int level;                      \/* log level to force + 1 if > 0, -1 = no log *\/$/;"	m	struct:strm_logs
level	./src/trace.c	/^static int level;$/;"	v	file:
lf_ip	./src/log.c	/^char *lf_ip(char *dst, struct sockaddr *sockaddr, size_t size, struct logformat_node *node)$/;"	f
lf_port	./src/log.c	/^char *lf_port(char *dst, struct sockaddr *sockaddr, size_t size, struct logformat_node *node)$/;"	f
lf_text	./src/log.c	/^static inline char *lf_text(char *dst, const char *src, size_t size, struct logformat_node *node)$/;"	f	file:
lf_text_len	./src/log.c	/^char *lf_text_len(char *dst, const char *src, size_t len, size_t size, struct logformat_node *node)$/;"	f
lfs_file	./include/types/proxy.h	/^		char *lfs_file;                 \/* file name where the logformat string appears (strdup) *\/$/;"	m	struct:proxy::__anon109
lfs_line	./include/types/proxy.h	/^		int   lfs_line;                 \/* file name where the logformat string appears *\/$/;"	m	struct:proxy::__anon109
lfsd_file	./include/types/proxy.h	/^		char *lfsd_file;		\/* file name where the structured-data logformat string for RFC5424 appears (strdup) *\/$/;"	m	struct:proxy::__anon109
lfsd_line	./include/types/proxy.h	/^		int  lfsd_line;			\/* file name where the structured-data logformat string for RFC5424 appears *\/$/;"	m	struct:proxy::__anon109
li_state	./include/types/listener.h	/^enum li_state {$/;"	g
licounters	./include/types/counters.h	/^struct licounters {$/;"	s
likely	./include/common/compiler.h	/^#define likely(/;"	d
limit	./include/common/memory.h	/^	unsigned int limit;	\/* hard limit on the number of chunks *\/$/;"	m	struct:pool_head
limit	./src/hlua.c	/^	size_t limit;$/;"	m	struct:hlua_mem_allocator	file:
limit_listener	./src/listener.c	/^void limit_listener(struct listener *l, struct list *list)$/;"	f
limit_r	./src/standard.c	/^const char *limit_r(unsigned long n, char *buffer, int size, const char *alt)$/;"	f
line	./contrib/halog/halog.c	/^const char *line;$/;"	v
line	./include/types/acl.h	/^	int line;                   \/* line in the config file where the condition is declared *\/$/;"	m	struct:acl_cond
line	./include/types/arg.h	/^	int line;                 \/* line number where the args are referenced *\/$/;"	m	struct:arg_list
line	./include/types/dns.h	/^		int line;		\/* line where the section appears *\/$/;"	m	struct:dns_nameserver::__anon64
line	./include/types/dns.h	/^		int line;		\/* line where the section appears *\/$/;"	m	struct:dns_resolvers::__anon61
line	./include/types/listener.h	/^	int line;                  \/* line where the section appears *\/$/;"	m	struct:bind_conf
line	./include/types/mailers.h	/^		int line;		\/* line where the section appears *\/$/;"	m	struct:mailer::__anon82
line	./include/types/mailers.h	/^		int line;		\/* line where the section appears *\/$/;"	m	struct:mailers::__anon83
line	./include/types/pattern.h	/^	int line;$/;"	m	struct:pat_ref_elt
line	./include/types/peers.h	/^		int line;		 \/* line where the section appears *\/$/;"	m	struct:peers::__anon93
line	./include/types/peers.h	/^		int line;	  \/* line where the section appears *\/$/;"	m	struct:peer::__anon92
line	./include/types/proto_http.h	/^	char *line;$/;"	m	struct:hdr_ctx
line	./include/types/proxy.h	/^		int line;			\/* line where the section appears *\/$/;"	m	struct:proxy::__anon109
line	./include/types/server.h	/^		int line;			\/* line where the section appears *\/$/;"	m	struct:server::__anon123
line	./src/trace.c	/^static char line[128]; \/* more than enough for a message (9+1+6+1+3+1+18+1+1+18+1+1) *\/$/;"	v	file:
line	./tests/uri_hash.c	/^char line[MAXLINE];$/;"	v
linenum	./contrib/halog/halog.c	/^int linenum = 0;$/;"	v
lines_max	./contrib/halog/halog.c	/^int lines_max = -1;$/;"	v
lines_out	./contrib/halog/halog.c	/^int lines_out = 0;$/;"	v
linger_risk	./include/types/fd.h	/^	unsigned char linger_risk:1;         \/* 1 if we must kill lingering before closing *\/$/;"	m	struct:fdtab
list	./include/common/cfgparse.h	/^	struct list list;$/;"	m	struct:cfg_kw_list	typeref:struct:cfg_kw_list::list
list	./include/common/memory.h	/^	struct list list;	\/* list of all known pools *\/$/;"	m	struct:pool_head	typeref:struct:pool_head::list
list	./include/common/mini-clist.h	/^	struct list list;$/;"	m	struct:cond_wordlist	typeref:struct:cond_wordlist::list
list	./include/common/mini-clist.h	/^	struct list list;$/;"	m	struct:wordlist	typeref:struct:wordlist::list
list	./include/common/mini-clist.h	/^struct list {$/;"	s
list	./include/common/uri_auth.h	/^	struct list list;	\/* list linked to from the proxy *\/$/;"	m	struct:dbmanage_admin_rule	typeref:struct:dbmanage_admin_rule::list
list	./include/common/uri_auth.h	/^	struct list list;	\/* list linked to from the proxy *\/$/;"	m	struct:stats_admin_rule	typeref:struct:stats_admin_rule::list
list	./include/import/lru.h	/^	struct lru64_list list;$/;"	m	struct:lru64_head	typeref:struct:lru64_head::lru64_list
list	./include/types/acl.h	/^	struct list list;             \/* chaining *\/$/;"	m	struct:acl_expr	typeref:struct:acl_expr::list
list	./include/types/acl.h	/^	struct list list;           \/* Some specific tests may use multiple conditions *\/$/;"	m	struct:acl_cond	typeref:struct:acl_cond::list
list	./include/types/acl.h	/^	struct list list;           \/* chaining *\/$/;"	m	struct:acl	typeref:struct:acl::list
list	./include/types/acl.h	/^	struct list list;           \/* chaining *\/$/;"	m	struct:acl_term	typeref:struct:acl_term::list
list	./include/types/acl.h	/^	struct list list;           \/* chaining of term suites *\/$/;"	m	struct:acl_term_suite	typeref:struct:acl_term_suite::list
list	./include/types/acl.h	/^	struct list list;$/;"	m	struct:acl_kw_list	typeref:struct:acl_kw_list::list
list	./include/types/action.h	/^	struct list list;$/;"	m	struct:act_rule	typeref:struct:act_rule::list
list	./include/types/action.h	/^	struct list list;$/;"	m	struct:action_kw_list	typeref:struct:action_kw_list::list
list	./include/types/arg.h	/^	struct list list;         \/* chaining with other arg_list, or list head *\/$/;"	m	struct:arg_list	typeref:struct:arg_list::list
list	./include/types/checks.h	/^	struct list list;                       \/* list linked to from the proxy *\/$/;"	m	struct:tcpcheck_rule	typeref:struct:tcpcheck_rule::list
list	./include/types/connection.h	/^	struct list list;             \/* attach point to various connection lists (idle, ...) *\/$/;"	m	struct:connection	typeref:struct:connection::list
list	./include/types/dns.h	/^	struct list list;		\/* nameserver chained list *\/$/;"	m	struct:dns_nameserver	typeref:struct:dns_nameserver::list
list	./include/types/dns.h	/^	struct list list;		\/* resolution list *\/$/;"	m	struct:dns_resolution	typeref:struct:dns_resolution::list
list	./include/types/dns.h	/^	struct list list;		\/* resolvers list *\/$/;"	m	struct:dns_resolvers	typeref:struct:dns_resolvers::list
list	./include/types/listener.h	/^	struct list list;$/;"	m	struct:bind_kw_list	typeref:struct:bind_kw_list::list
list	./include/types/log.h	/^	struct list list;$/;"	m	struct:logformat_node	typeref:struct:logformat_node::list
list	./include/types/log.h	/^	struct list list;$/;"	m	struct:logsrv	typeref:struct:logsrv::list
list	./include/types/map.h	/^	struct list list;              \/* used for listing *\/$/;"	m	struct:map_descriptor	typeref:struct:map_descriptor::list
list	./include/types/pattern.h	/^	struct list list; \/* Used for chaining pattern_expr in pat_ref. *\/$/;"	m	struct:pattern_expr	typeref:struct:pattern_expr::list
list	./include/types/pattern.h	/^	struct list list; \/* Used for chaining pattern_expr in pattern_head. *\/$/;"	m	struct:pattern_expr_list	typeref:struct:pattern_expr_list::list
list	./include/types/pattern.h	/^	struct list list; \/* Used to chain elements. *\/$/;"	m	struct:pat_ref_elt	typeref:struct:pat_ref_elt::list
list	./include/types/pattern.h	/^	struct list list; \/* Used to chain refs. *\/$/;"	m	struct:pat_ref	typeref:struct:pat_ref::list
list	./include/types/pattern.h	/^	struct list list;$/;"	m	struct:pattern_list	typeref:struct:pattern_list::list
list	./include/types/protocol.h	/^	struct list list;				\/* list of registered protocols *\/$/;"	m	struct:protocol	typeref:struct:protocol::list
list	./include/types/proxy.h	/^	struct list list;			\/* list linked to from the proxy *\/$/;"	m	struct:persist_rule	typeref:struct:persist_rule::list
list	./include/types/proxy.h	/^	struct list list;			\/* list linked to from the proxy *\/$/;"	m	struct:server_rule	typeref:struct:server_rule::list
list	./include/types/proxy.h	/^	struct list list;			\/* list linked to from the proxy *\/$/;"	m	struct:switching_rule	typeref:struct:switching_rule::list
list	./include/types/proxy.h	/^	struct list list;                       \/* list linked to from the proxy *\/$/;"	m	struct:redirect_rule	typeref:struct:redirect_rule::list
list	./include/types/proxy.h	/^	struct list list;                       \/* list linked to from the proxy *\/$/;"	m	struct:sticking_rule	typeref:struct:sticking_rule::list
list	./include/types/proxy.h	/^	struct list list;$/;"	m	struct:email_alert	typeref:struct:email_alert::list
list	./include/types/queue.h	/^	struct list list;		\/* chaining ... *\/$/;"	m	struct:pendconn	typeref:struct:pendconn::list
list	./include/types/sample.h	/^	struct list list;                         \/* head of sample conversion keyword list *\/$/;"	m	struct:sample_conv_kw_list	typeref:struct:sample_conv_kw_list::list
list	./include/types/sample.h	/^	struct list list;                         \/* head of sample fetch keyword list *\/$/;"	m	struct:sample_fetch_kw_list	typeref:struct:sample_fetch_kw_list::list
list	./include/types/sample.h	/^	struct list list;                         \/* member of a sample_expr *\/$/;"	m	struct:sample_conv_expr	typeref:struct:sample_conv_expr::list
list	./include/types/sample.h	/^	struct list list;                         \/* member of list of sample, currently not used *\/$/;"	m	struct:sample_expr	typeref:struct:sample_expr::list
list	./include/types/server.h	/^	struct list list;$/;"	m	struct:pid_list	typeref:struct:pid_list::list
list	./include/types/server.h	/^	struct list list;$/;"	m	struct:srv_kw_list	typeref:struct:srv_kw_list::list
list	./include/types/signal.h	/^	struct list list;$/;"	m	struct:sig_handler	typeref:struct:sig_handler::list
list	./include/types/ssl_sock.h	/^	struct list list; \/* Used to chain refs. *\/$/;"	m	struct:tls_keys_ref	typeref:struct:tls_keys_ref::list
list	./include/types/stream.h	/^	struct list list;               \/* position in global streams list *\/$/;"	m	struct:stream	typeref:struct:stream::list
list	./src/51d.c	/^	struct list list;$/;"	m	struct:_51d_property_names	typeref:struct:_51d_property_names::list	file:
list	./src/cfgparse.c	/^	struct list list;$/;"	m	struct:cfg_section	typeref:struct:cfg_section::list	file:
list_for_each_entry	./include/common/mini-clist.h	/^#define list_for_each_entry(/;"	d
list_for_each_entry_safe	./include/common/mini-clist.h	/^#define list_for_each_entry_safe(/;"	d
list_pollers	./src/fd.c	/^int list_pollers(FILE *out)$/;"	f
listen_default_ciphers	./include/types/global.h	/^	char *listen_default_ciphers;$/;"	m	struct:global
listen_default_ssloptions	./include/types/global.h	/^	int listen_default_ssloptions;$/;"	m	struct:global
listener	./include/types/listener.h	/^struct listener {$/;"	s
listener	./include/types/session.h	/^	struct listener *listener;      \/* the listener by which the request arrived *\/$/;"	m	struct:session	typeref:struct:session::listener
listener_accept	./src/listener.c	/^void listener_accept(int fd)$/;"	f
listener_full	./src/listener.c	/^void listener_full(struct listener *l)$/;"	f
listener_queue	./include/types/proxy.h	/^	struct list listener_queue;		\/* list of the temporarily limited listeners because of lack of a proxy resource *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
listeners	./include/types/listener.h	/^	struct list listeners;     \/* list of listeners using this bind config *\/$/;"	m	struct:bind_conf	typeref:struct:bind_conf::list
listeners	./include/types/protocol.h	/^	struct list listeners;				\/* list of listeners using this protocol *\/$/;"	m	struct:protocol	typeref:struct:protocol::list
listeners	./include/types/proxy.h	/^		struct list listeners;		\/* list of listeners belonging to this frontend *\/$/;"	m	struct:proxy::__anon109	typeref:struct:proxy::__anon109::list
listeners	./src/proxy.c	/^int listeners;	\/* # of proxy listeners, set by cfgparse *\/$/;"	v
ll	./include/import/xxhash.h	/^typedef struct { long long ll[ 6]; } XXH32_state_t;$/;"	m	struct:__anon6
ll	./include/import/xxhash.h	/^typedef struct { long long ll[11]; } XXH64_state_t;$/;"	m	struct:__anon7
ll	./include/types/sample.h	/^	long long ll;   \/* any long long or smaller *\/$/;"	m	union:smp_ctx
lltoa	./src/standard.c	/^char *lltoa(long long n, char *dst, size_t size)$/;"	f
lltoa_r	./src/standard.c	/^char *lltoa_r(long long int in, char *buffer, int size)$/;"	f
load_server_state_from_file	./include/types/proxy.h	/^	int load_server_state_from_file;	\/* location of the file containing server state.$/;"	m	struct:proxy
local	./include/types/peers.h	/^	int local;		  \/* proxy state *\/$/;"	m	struct:peer
local	./include/types/peers.h	/^	struct peer *local;		 \/* local peer list *\/$/;"	m	struct:peers	typeref:struct:peers::peer
local_dh_1024	./src/ssl_sock.c	/^static DH *local_dh_1024 = NULL;$/;"	v	file:
local_dh_2048	./src/ssl_sock.c	/^static DH *local_dh_2048 = NULL;$/;"	v	file:
local_dh_4096	./src/ssl_sock.c	/^static DH *local_dh_4096 = NULL;$/;"	v	file:
local_id	./include/types/peers.h	/^	int local_id;$/;"	m	struct:shared_table
local_port	./include/types/fd.h	/^	int local_port;                      \/* optional local port *\/$/;"	m	struct:fdinfo
localdate2str_log	./src/standard.c	/^char *localdate2str_log(char *dst, struct tm *tm, size_t size)$/;"	f
localpeer	./src/haproxy.c	/^char localpeer[MAX_HOSTNAME_LEN];$/;"	v
localtimezone	./include/common/standard.h	/^char localtimezone[6];$/;"	v
localupdate	./include/types/stick_table.h	/^	unsigned int localupdate;$/;"	m	struct:stktable
locate_haproxy	./src/haproxy-systemd-wrapper.c	/^static void locate_haproxy(char *buffer, size_t buffer_size)$/;"	f	file:
log	./src/trace.c	/^static FILE *log;$/;"	v	file:
log_count	./include/types/proxy.h	/^	unsigned int log_count;			\/* number of logs produced by the frontend *\/$/;"	m	struct:proxy
log_facilities	./src/log.c	/^const char *log_facilities[NB_LOG_FACILITIES] = {$/;"	v
log_fmt	./src/log.c	/^struct log_fmt {$/;"	s	file:
log_format	./src/log.c	/^char *log_format = NULL;$/;"	v
log_formats	./src/log.c	/^static const struct log_fmt log_formats[LOG_FORMATS] = {$/;"	v	typeref:struct:log_fmt	file:
log_levels	./src/log.c	/^const char *log_levels[NB_LOG_LEVELS] = {$/;"	v
log_send_hostname	./include/types/global.h	/^	char *log_send_hostname;   \/* set hostname in syslog header *\/$/;"	m	struct:global
log_tag	./include/types/global.h	/^	struct chunk log_tag;           \/* name for syslog *\/$/;"	m	struct:global	typeref:struct:global::chunk
log_tag	./include/types/proxy.h	/^	struct chunk log_tag;                   \/* override default syslog tag *\/$/;"	m	struct:proxy	typeref:struct:proxy::chunk
logfmt	./include/types/action.h	/^			struct list logfmt;$/;"	m	struct:act_rule::__anon9::__anon13	typeref:struct:act_rule::__anon9::__anon13::list
logformat	./include/types/proxy.h	/^	struct list logformat; 			\/* log_format linked list *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
logformat_keywords	./src/log.c	/^static const struct logformat_type logformat_keywords[] = {$/;"	v	typeref:struct:logformat_type	file:
logformat_node	./include/types/log.h	/^struct logformat_node {$/;"	s
logformat_sd	./include/types/proxy.h	/^	struct list logformat_sd;		\/* log_format linked list for the RFC5424 structured-data part *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
logformat_sd_string	./include/types/proxy.h	/^		char *logformat_sd_string;	\/* log format string for the RFC5424 structured-data part *\/$/;"	m	struct:proxy::__anon109
logformat_string	./include/types/proxy.h	/^		char *logformat_string;		\/* log format string *\/$/;"	m	struct:proxy::__anon109
logformat_type	./src/log.c	/^struct logformat_type {$/;"	s	file:
logformat_var_args	./src/log.c	/^struct logformat_var_args {$/;"	s	file:
logheader	./src/log.c	/^char *logheader = NULL;$/;"	v
logheader_rfc5424	./src/log.c	/^char *logheader_rfc5424 = NULL;$/;"	v
loglevel	./include/types/action.h	/^		int loglevel;                  \/* log-level value for ACT_HTTP_SET_LOGL *\/$/;"	m	union:act_rule::__anon9
loglevel	./include/types/global.h	/^		da_severity_t loglevel;$/;"	m	struct:global::__anon75
logline	./src/log.c	/^char *logline = NULL;$/;"	v
logline_rfc5424	./src/log.c	/^char *logline_rfc5424 = NULL;$/;"	v
logs	./include/types/stream.h	/^	struct strm_logs logs;                  \/* logs for this stream *\/$/;"	m	struct:stream	typeref:struct:stream::strm_logs
logsrv	./include/types/log.h	/^struct logsrv {$/;"	s
logsrvs	./include/types/global.h	/^	struct list logsrvs;$/;"	m	struct:global	typeref:struct:global::list
logsrvs	./include/types/proxy.h	/^	struct list logsrvs;$/;"	m	struct:proxy	typeref:struct:proxy::list
logwait	./include/types/stream.h	/^	int logwait;                    \/* log fields waiting to be collected : LW_* *\/$/;"	m	struct:strm_logs
lpos	./include/types/server.h	/^	unsigned npos, lpos;			\/* next and last positions in the LB tree *\/$/;"	m	struct:server
lr	./include/types/checks.h	/^	unsigned char lr[HANA_OBS_SIZE];	\/* result for l4\/l7: 0 = ignore, 1 - error, 2 - OK *\/$/;"	m	struct:analyze_status
lru	./include/import/lru.h	/^	struct lru64_list lru;        \/* LRU list *\/$/;"	m	struct:lru64	typeref:struct:lru64::lru64_list
lru64	./include/import/lru.h	/^struct lru64 {$/;"	s
lru64_commit	./src/lru.c	/^void lru64_commit(struct lru64 *elem, void *data, void *domain,$/;"	f
lru64_destroy	./src/lru.c	/^int lru64_destroy(struct lru64_head *lru)$/;"	f
lru64_get	./src/lru.c	/^struct lru64 *lru64_get(unsigned long long key, struct lru64_head *lru,$/;"	f
lru64_head	./include/import/lru.h	/^struct lru64_head {$/;"	s
lru64_list	./include/import/lru.h	/^struct lru64_list {$/;"	s
lru64_lookup	./src/lru.c	/^struct lru64 *lru64_lookup(unsigned long long key, struct lru64_head *lru,$/;"	f
lru64_new	./src/lru.c	/^struct lru64_head *lru64_new(int size)$/;"	f
ltoa_o	./src/standard.c	/^char *ltoa_o(long int n, char *dst, size_t size)$/;"	f
ltrim	./include/common/standard.h	/^static inline char *ltrim(char *s, char c) {$/;"	f
luid	./include/types/listener.h	/^	int luid;			\/* listener universally unique ID, used for SNMP *\/$/;"	m	struct:listener
lw	./src/log.c	/^	int lw; \/* logwait bitsfield *\/$/;"	m	struct:logformat_type	file:
m	./include/types/proxy.h	/^			struct mailers *m;	\/* Mailer to send email alerts via *\/$/;"	m	union:proxy::__anon110::__anon111	typeref:struct:proxy::__anon110::__anon111::mailers
m1	./include/types/pattern.h	/^	int h1:5, m1:6;         \/* 0..24:0..60. Use 0:0 for all day. *\/$/;"	m	struct:pat_time
m2	./include/types/pattern.h	/^	int h2:5, m2:6;         \/* 0..24:0..60. Use 24:0 for all day. *\/$/;"	m	struct:pat_time
m_blen	./include/types/proxy.h	/^	unsigned long long m_blen;	\/* body len for this message *\/$/;"	m	struct:error_snapshot
m_clen	./include/types/proxy.h	/^	unsigned long long m_clen;	\/* chunk len for this message *\/$/;"	m	struct:error_snapshot
m_flags	./include/types/proxy.h	/^	unsigned int m_flags;		\/* message flags *\/$/;"	m	struct:error_snapshot
m_l	./include/types/proto_http.h	/^			int m_l;               \/* METHOD length (method starts at buf->p) *\/$/;"	m	struct:http_msg::__anon99::__anon100
mailer	./include/types/mailers.h	/^struct mailer {$/;"	s
mailer_list	./include/types/mailers.h	/^	struct mailer *mailer_list;	\/* mailers in this mailers section *\/$/;"	m	struct:mailers	typeref:struct:mailers::mailer
mailers	./include/types/mailers.h	/^	struct mailers *mailers;$/;"	m	struct:mailer	typeref:struct:mailer::mailers
mailers	./include/types/mailers.h	/^struct mailers {$/;"	s
mailers	./include/types/proxy.h	/^		} mailers;$/;"	m	struct:proxy::__anon110	typeref:union:proxy::__anon110::__anon111
mailers	./src/mailers.c	/^struct mailers *mailers = NULL;$/;"	v	typeref:struct:mailers
main	./contrib/base64/base64rev-gen.c	/^int main() {$/;"	f
main	./contrib/halog/fgets2.c	/^int main() {$/;"	f
main	./contrib/halog/halog.c	/^int main(int argc, char **argv)$/;"	f
main	./contrib/ip6range/ip6range.c	/^main(int argc, char **argv)$/;"	f
main	./contrib/iprange/iprange.c	/^main(int argc, char **argv)$/;"	f
main	./src/haproxy-systemd-wrapper.c	/^int main(int argc, char **argv)$/;"	f
main	./src/haproxy.c	/^int main(int argc, char **argv)$/;"	f
main	./src/lru.c	/^int main(int argc, char **argv)$/;"	f
main	./tests/filltab25.c	/^main(int argc, char **argv) {$/;"	f
main	./tests/ip-hash.c	/^int main() {$/;"	f
main	./tests/reset.c	/^int main(int argc, char **argv) {$/;"	f
main	./tests/test-arg.c	/^int main(int argc, char **argv)$/;"	f
main	./tests/test.c	/^main() {$/;"	f
main	./tests/test_hashes.c	/^int main(){$/;"	f
main	./tests/test_pools.c	/^int main(void)$/;"	f
main	./tests/testinet.c	/^main() {$/;"	f
main	./tests/uri_hash.c	/^int main() {$/;"	f
make_4delim	./src/pattern.c	/^static inline unsigned int make_4delim(unsigned char d1, unsigned char d2, unsigned char d3, unsigned char d4)$/;"	f	file:
make_arg_list	./src/arg.c	/^int make_arg_list(const char *in, int len, unsigned int mask, struct arg **argp,$/;"	f
make_line	./src/trace.c	/^static void make_line(void *from, void *to, int level, char dir)$/;"	f	file:
make_proxy_line	./src/connection.c	/^int make_proxy_line(char *buf, int buf_len, struct server *srv, struct connection *remote)$/;"	f
make_proxy_line_v1	./src/connection.c	/^int make_proxy_line_v1(char *buf, int buf_len, struct sockaddr_storage *src, struct sockaddr_storage *dst)$/;"	f
make_proxy_line_v2	./src/connection.c	/^int make_proxy_line_v2(char *buf, int buf_len, struct server *srv, struct connection *remote)$/;"	f
make_tlv	./src/connection.c	/^static int make_tlv(char *dest, int dest_len, char type, uint16_t length, const char *value)$/;"	f	file:
man_pages	./doc/lua-api/conf.py	/^man_pages = [$/;"	v
manage_client_side_cookies	./src/proto_http.c	/^void manage_client_side_cookies(struct stream *s, struct channel *req)$/;"	f
manage_global_listener_queue	./src/haproxy.c	/^static struct task *manage_global_listener_queue(struct task *t)$/;"	f	file:
manage_proxy	./src/proxy.c	/^struct task *manage_proxy(struct task *t)$/;"	f
manage_server_side_cookies	./src/proto_http.c	/^void manage_server_side_cookies(struct stream *s, struct channel *res)$/;"	f
map	./include/types/action.h	/^		} map;$/;"	m	union:act_rule::__anon9	typeref:struct:act_rule::__anon9::__anon12
map	./include/types/applet.h	/^		} map;$/;"	m	union:appctx::__anon21	typeref:struct:appctx::__anon21::__anon28
map	./include/types/arg.h	/^	struct map_descriptor *map;$/;"	m	union:arg_data	typeref:struct:arg_data::map_descriptor
map	./include/types/backend.h	/^	struct lb_map map;		\/* LB parameters for map-based algorithms *\/$/;"	m	struct:lbprm	typeref:struct:lbprm::lb_map
map_create_descriptor	./src/map.c	/^static struct map_descriptor *map_create_descriptor(struct sample_conv *conv)$/;"	f	file:
map_descriptor	./include/types/map.h	/^struct map_descriptor {$/;"	s
map_get_server_hash	./src/lb_map.c	/^struct server *map_get_server_hash(struct proxy *px, unsigned int hash)$/;"	f
map_get_server_rr	./src/lb_map.c	/^struct server *map_get_server_rr(struct proxy *px, struct server *srvtoavoid)$/;"	f
map_parse_int	./src/map.c	/^int map_parse_int(const char *text, struct sample_data *data)$/;"	f
map_parse_ip	./src/map.c	/^int map_parse_ip(const char *text, struct sample_data *data)$/;"	f
map_parse_str	./src/map.c	/^int map_parse_str(const char *text, struct sample_data *data)$/;"	f
map_set_server_status_down	./src/lb_map.c	/^static void map_set_server_status_down(struct server *srv)$/;"	f	file:
map_set_server_status_up	./src/lb_map.c	/^static void map_set_server_status_up(struct server *srv)$/;"	f	file:
mark	./include/types/action.h	/^		int mark;                      \/* nfmark value for ACT_HTTP_SET_MARK *\/$/;"	m	union:act_rule::__anon9
mask	./include/types/pattern.h	/^			struct in_addr mask;$/;"	m	struct:pattern::__anon87::__anon89	typeref:struct:pattern::__anon87::__anon89::in_addr
mask	./include/types/pattern.h	/^			unsigned char mask;     \/* number of bits *\/$/;"	m	struct:pattern::__anon87::__anon90
mask	./src/log.c	/^	int mask;$/;"	m	struct:logformat_var_args	file:
master_doc	./doc/lua-api/conf.py	/^master_doc = 'index'$/;"	v
match	./include/types/acl.h	/^	struct pattern *(*match)(struct sample *smp, struct pattern_expr *expr, int fill);$/;"	m	struct:acl_keyword	typeref:struct:acl_keyword::match
match	./include/types/pattern.h	/^	struct pattern *(*match)(struct sample *, struct pattern_expr *, int);$/;"	m	struct:pattern_head	typeref:struct:pattern_head::match
match_pfx	./include/types/action.h	/^	int match_pfx;$/;"	m	struct:action_kw
match_type	./include/types/acl.h	/^	int match_type; \/* Contain PAT_MATCH_* *\/$/;"	m	struct:acl_keyword
match_word	./src/pattern.c	/^static int match_word(struct sample *smp, struct pattern *pattern, int mflags, unsigned int delimiters)$/;"	f	file:
max	./include/types/pattern.h	/^			signed long long min, max;$/;"	m	struct:pattern::__anon87::__anon88
max_http_hdr	./include/types/global.h	/^		int max_http_hdr;  \/* max number of HTTP headers, use MAX_HTTP_HDR if zero *\/$/;"	m	struct:global::__anon72
max_ka_queue	./include/types/proxy.h	/^	int max_ka_queue;			\/* 1+maximum requests in queue accepted for reusing a K-A conn (0=none) *\/$/;"	m	struct:proxy
max_set	./include/types/pattern.h	/^			int max_set :1;$/;"	m	struct:pattern::__anon87::__anon88
max_spread_checks	./include/types/global.h	/^	int max_spread_checks;$/;"	m	struct:global
max_syslog_len	./include/types/global.h	/^	int max_syslog_len;$/;"	m	struct:global
max_time	./include/types/hlua.h	/^	unsigned int max_time; \/* The max amount of execution time for an Lua process, in ms. *\/$/;"	m	struct:hlua
maxaccept	./include/types/global.h	/^		int maxaccept;     \/* max number of consecutive accept() *\/$/;"	m	struct:global::__anon72
maxaccept	./include/types/listener.h	/^	unsigned int maxaccept;         \/* if set, max number of connections accepted at once *\/$/;"	m	struct:listener
maxconn	./include/types/global.h	/^	int maxconn, hardmaxconn;$/;"	m	struct:global
maxconn	./include/types/listener.h	/^	int maxconn;			\/* maximum connections allowed on this listener *\/$/;"	m	struct:listener
maxconn	./include/types/proxy.h	/^	unsigned int maxconn;                   \/* max # of active streams on the frontend *\/$/;"	m	struct:proxy
maxconn	./include/types/server.h	/^	unsigned maxconn, minconn;		\/* max # of active sessions (0 = unlimited), min# for dynamic limit. *\/$/;"	m	struct:server
maxfd	./src/fd.c	/^int maxfd;                      \/* # of the highest fd + 1 *\/$/;"	v
maxlen	./include/types/log.h	/^	int maxlen;$/;"	m	struct:logsrv
maxpipes	./include/types/global.h	/^	int maxpipes;		\/* max # of pipes *\/$/;"	m	struct:global
maxpollevents	./include/types/global.h	/^		int maxpollevents; \/* max number of poll events at once *\/$/;"	m	struct:global::__anon72
maxqueue	./include/types/server.h	/^	int maxqueue;				\/* maximum number of pending connections allowed *\/$/;"	m	struct:server
maxrewrite	./include/types/global.h	/^		int maxrewrite;    \/* buffer max rewrite size in bytes, defaults to MAXREWRITE *\/$/;"	m	struct:global::__anon72
maxseg	./include/types/listener.h	/^	int maxseg;			\/* for TCP, advertised MSS *\/$/;"	m	struct:listener
maxsock	./include/types/global.h	/^	int maxsock;		\/* max # of sockets *\/$/;"	m	struct:global
maxsslconn	./include/types/global.h	/^	int maxsslconn;$/;"	m	struct:global
maxzlibmem	./include/types/global.h	/^	long maxzlibmem;        \/* max RAM for zlib in bytes *\/$/;"	m	struct:global
may_dequeue_tasks	./include/proto/queue.h	/^static inline int may_dequeue_tasks(const struct server *s, const struct proxy *p) {$/;"	f
measure_idle	./include/common/time.h	/^static inline void measure_idle()$/;"	f
mem32	./src/xxhash.c	/^    U32 mem32[4];   \/* defined as U32 for alignment *\/$/;"	m	struct:__anon148	file:
mem64	./src/xxhash.c	/^    U64 mem64[4];   \/* defined as U64 for alignment *\/$/;"	m	struct:__anon149	file:
mem_poison_byte	./src/memory.c	/^int mem_poison_byte = -1;$/;"	v
memprintf	./src/standard.c	/^char *memprintf(char **out, const char *format, ...)$/;"	f
memsize	./src/xxhash.c	/^    U32 memsize;$/;"	m	struct:__anon148	file:
memsize	./src/xxhash.c	/^    U32 memsize;$/;"	m	struct:__anon149	file:
meth	./include/types/proto_http.h	/^	enum http_meth_t meth;          \/* HTTP method *\/$/;"	m	struct:http_txn	typeref:enum:http_txn::http_meth_t
meth	./include/types/sample.h	/^	enum http_meth_t meth;$/;"	m	struct:meth	typeref:enum:meth::http_meth_t
meth	./include/types/sample.h	/^	struct meth     meth;  \/* used for http method *\/$/;"	m	union:sample_value	typeref:struct:sample_value::meth
meth	./include/types/sample.h	/^struct meth {$/;"	s
meth	./src/proto_http.c	/^	enum http_meth_t meth;$/;"	m	struct:http_method_desc	typeref:enum:http_method_desc::http_meth_t	file:
method	./include/types/proto_http.h	/^	enum ht_auth_m method;                \/* one of HTTP_AUTH_* *\/$/;"	m	struct:http_auth_data	typeref:enum:http_auth_data::ht_auth_m
method_data	./include/types/proto_http.h	/^	struct chunk method_data;             \/* points to the creditial part from 'Authorization:' header *\/$/;"	m	struct:http_auth_data	typeref:struct:http_auth_data::chunk
mflags	./include/types/pattern.h	/^	int mflags;                     \/* flags relative to the parsing or matching method. *\/$/;"	m	struct:pattern_expr
min	./include/types/pattern.h	/^			signed long long min, max;$/;"	m	struct:pattern::__anon87::__anon88
min_set	./include/types/pattern.h	/^			int min_set :1;$/;"	m	struct:pattern::__anon87::__anon88
minavail	./include/common/memory.h	/^	unsigned int minavail;	\/* how many chunks are expected to be used *\/$/;"	m	struct:pool_head
minconn	./include/types/server.h	/^	unsigned maxconn, minconn;		\/* max # of active sessions (0 = unlimited), min# for dynamic limit. *\/$/;"	m	struct:server
minlvl	./include/types/log.h	/^	int minlvl;$/;"	m	struct:logsrv
misses	./src/lru.c	/^static unsigned int misses;$/;"	v	file:
mix	./tests/test_hashes.c	/^#define mix(/;"	d	file:
mode	./include/types/global.h	/^			mode_t mode;    \/* 0 to leave unchanged *\/$/;"	m	struct:global::__anon73::__anon74
mode	./include/types/global.h	/^	int mode;$/;"	m	struct:global
mode	./include/types/listener.h	/^		mode_t mode;       \/* 0 to leave unchanged *\/$/;"	m	struct:bind_conf::__anon77
mode	./include/types/proxy.h	/^	enum pr_mode mode;                      \/* mode = PR_MODE_TCP, PR_MODE_HTTP or PR_MODE_HEALTH *\/$/;"	m	struct:proxy	typeref:enum:proxy::pr_mode
mode	./src/cfgparse.c	/^	unsigned int mode;$/;"	m	struct:cfg_opt	file:
mode	./src/log.c	/^	int mode;$/;"	m	struct:logformat_type	file:
mon_fail_cond	./include/types/proxy.h	/^	struct list mon_fail_cond;              \/* list of conditions to fail monitoring requests (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
mon_mask	./include/types/proxy.h	/^	struct in_addr mon_net, mon_mask;	\/* don't forward connections from this net (network order) FIXME: should support IPv6 *\/$/;"	m	struct:proxy	typeref:struct:proxy::
mon_net	./include/types/proxy.h	/^	struct in_addr mon_net, mon_mask;	\/* don't forward connections from this net (network order) FIXME: should support IPv6 *\/$/;"	m	struct:proxy	typeref:struct:proxy::in_addr
monitor_uri	./include/types/proxy.h	/^	char *monitor_uri;			\/* a special URI to which we respond with HTTP\/200 OK *\/$/;"	m	struct:proxy
monitor_uri_len	./include/types/proxy.h	/^	int monitor_uri_len;			\/* length of the string above. 0 if unused *\/$/;"	m	struct:proxy
monthname	./src/standard.c	/^const char *monthname[12] = {$/;"	v
ms_left_scaled	./src/time.c	/^unsigned int   ms_left_scaled;  \/* milliseconds left for current second (0..2^32-1) *\/$/;"	v
msg	./include/types/applet.h	/^			const char *msg;	\/* pointer to a persistent message to be returned in PRINT state *\/$/;"	m	struct:appctx::__anon21::__anon26
msg_state	./include/types/proto_http.h	/^	enum ht_state msg_state;               \/* where we are in the current message parsing *\/$/;"	m	struct:http_msg	typeref:enum:http_msg::ht_state
mul32hi	./include/common/standard.h	/^static inline unsigned int mul32hi(unsigned int a, unsigned int b)$/;"	f
mutex	./src/shctx.c	/^	pthread_mutex_t mutex;$/;"	m	struct:shared_context	file:
my_memmem	./src/standard.c	/^const void *my_memmem(const void *haystack, size_t haystacklen, const void *needle, size_t needlelen)$/;"	f
my_popcountl	./include/common/standard.h	/^static inline unsigned int my_popcountl(unsigned long a)$/;"	f
my_regex	./include/common/regex.h	/^struct my_regex {$/;"	s
my_socketat	./src/namespace.c	/^int my_socketat(const struct netns_entry *ns, int domain, int type, int protocol)$/;"	f
my_strndup	./src/standard.c	/^char *my_strndup(const char *src, int n)$/;"	f
myhostname	./include/types/proxy.h	/^		char *myhostname;		\/* Identity to use in HELO command sent to mailer *\/$/;"	m	struct:proxy::__anon110
n	./include/common/mini-clist.h	/^    struct list *n;	\/* next *\/$/;"	m	struct:list	typeref:struct:list::list
n	./include/import/lru.h	/^	struct lru64_list *n;$/;"	m	struct:lru64_list	typeref:struct:lru64_list::lru64_list
n	./include/types/stick_table.h	/^		char *n;			\/* or its name during parsing. *\/$/;"	m	union:track_ctr_prm::__anon129
n	./src/shctx.c	/^	struct shared_block *n;$/;"	m	struct:shared_block	typeref:struct:shared_block::shared_block	file:
name	./include/common/memory.h	/^	char name[12];		\/* name of the pool *\/$/;"	m	struct:pool_head
name	./include/types/acl.h	/^	char *name;		    \/* acl name *\/$/;"	m	struct:acl
name	./include/types/action.h	/^			char *name;            \/* header name *\/$/;"	m	struct:act_rule::__anon9::__anon11
name	./include/types/action.h	/^			const char *name;$/;"	m	struct:act_rule::__anon9::__anon17
name	./include/types/applet.h	/^	char *name;                        \/* applet's name to report in logs *\/$/;"	m	struct:applet
name	./include/types/auth.h	/^	char *name;$/;"	m	struct:auth_groups
name	./include/types/auth.h	/^	char *name;$/;"	m	struct:userlist
name	./include/types/capture.h	/^    char *name;				\/* header name, case insensitive, NULL if not header *\/$/;"	m	struct:cap_hdr
name	./include/types/checks.h	/^	char *name;	\/* environment variable name *\/$/;"	m	struct:extcheck_env
name	./include/types/compression.h	/^	char *name;$/;"	m	struct:comp_type
name	./include/types/fd.h	/^	const char   *name;                                  \/* poller name *\/$/;"	m	struct:poller
name	./include/types/hlua.h	/^	char *name;$/;"	m	struct:hlua_function
name	./include/types/listener.h	/^	char *name;			\/* listener's name *\/$/;"	m	struct:listener
name	./include/types/proto_http.h	/^	char *name;$/;"	m	struct:http_method_name
name	./include/types/protocol.h	/^	char name[PROTO_NAME_LEN];			\/* protocol name, zero-terminated *\/$/;"	m	struct:protocol
name	./include/types/proxy.h	/^			char *name;$/;"	m	union:proxy::__anon110::__anon111
name	./include/types/proxy.h	/^		char *name;			\/* default backend name during config parse *\/$/;"	m	union:proxy::__anon105
name	./include/types/proxy.h	/^		char *name;			\/* target backend name during config parsing *\/$/;"	m	union:switching_rule::__anon112
name	./include/types/proxy.h	/^		char *name;			\/* target server name during config parsing *\/$/;"	m	union:server_rule::__anon113
name	./include/types/proxy.h	/^		char *name;                     \/* target table name during config parsing *\/$/;"	m	union:sticking_rule::__anon114
name	./include/types/ssl_sock.h	/^	struct ebmb_node name;    \/* node holding the servername value *\/$/;"	m	struct:sni_ctx	typeref:struct:sni_ctx::ebmb_node
name	./include/types/ssl_sock.h	/^	unsigned char name[16];$/;"	m	struct:tls_sess_key
name	./include/types/stick_table.h	/^		char *name;$/;"	m	union:stktable::__anon127
name	./include/types/stick_table.h	/^	const char *name; \/* name of the data type *\/$/;"	m	struct:stktable_data_type
name	./include/types/vars.h	/^	const char *name; \/* Contains the normalized variable name. *\/$/;"	m	struct:var_desc
name	./include/types/vars.h	/^	const char *name; \/* Contains the variable name. *\/$/;"	m	struct:var
name	./src/51d.c	/^	char *name;$/;"	m	struct:_51d_property_names	file:
name	./src/acl.c	/^	const char *name;$/;"	m	struct:__anon133	file:
name	./src/cfgparse.c	/^	const char *name;$/;"	m	struct:cfg_opt	file:
name	./src/log.c	/^	char *name;$/;"	m	struct:log_fmt	file:
name	./src/log.c	/^	char *name;$/;"	m	struct:logformat_type	file:
name	./src/log.c	/^	char *name;$/;"	m	struct:logformat_var_args	file:
name_len	./include/common/namespace.h	/^	size_t name_len;$/;"	m	struct:netns_entry
name_len	./include/types/action.h	/^			int name_len;          \/* header name's length *\/$/;"	m	struct:act_rule::__anon9::__anon11
name_len	./include/types/compression.h	/^	int name_len;$/;"	m	struct:comp_type
namelen	./include/types/capture.h	/^    int namelen;			\/* length of the header name, to speed-up lookups, 0 if !name *\/$/;"	m	struct:cap_hdr
nameserver_list	./include/types/dns.h	/^	struct list nameserver_list;	\/* dns server list *\/$/;"	m	struct:dns_resolvers	typeref:struct:dns_resolvers::list
namespace_tree_root	./src/namespace.c	/^static struct eb_root namespace_tree_root = EB_ROOT;$/;"	v	typeref:struct:eb_root	file:
nargs	./include/types/hlua.h	/^	int nargs; \/* The number of arguments in the stack at the start of execution. *\/$/;"	m	struct:hlua
nb_ct	./contrib/halog/halog.c	/^	unsigned int nb_ct, nb_rt, nb_ok;$/;"	m	struct:srv_st	file:
nb_err	./contrib/halog/halog.c	/^	unsigned int nb_err, nb_req;$/;"	m	struct:url_stat	file:
nb_listeners	./include/types/protocol.h	/^	int nb_listeners;				\/* number of listeners *\/$/;"	m	struct:protocol
nb_ok	./contrib/halog/halog.c	/^	unsigned int nb_ct, nb_rt, nb_ok;$/;"	m	struct:srv_st	file:
nb_oldpids	./src/haproxy.c	/^int nb_oldpids = 0;$/;"	v
nb_req	./contrib/halog/halog.c	/^	unsigned int nb_err, nb_req;$/;"	m	struct:url_stat	file:
nb_req_cap	./include/types/proxy.h	/^	int nb_req_cap, nb_rsp_cap;		\/* # of headers to be captured *\/$/;"	m	struct:proxy
nb_responses	./include/types/dns.h	/^	int nb_responses;		\/* count number of responses received *\/$/;"	m	struct:dns_resolution
nb_rsp_cap	./include/types/proxy.h	/^	int nb_req_cap, nb_rsp_cap;		\/* # of headers to be captured *\/$/;"	m	struct:proxy
nb_rt	./contrib/halog/halog.c	/^	unsigned int nb_ct, nb_rt, nb_ok;$/;"	m	struct:srv_st	file:
nb_tasks	./src/task.c	/^unsigned int nb_tasks = 0;$/;"	v
nb_tasks_cur	./src/task.c	/^unsigned int nb_tasks_cur = 0;     \/* copy of the tasks count *\/$/;"	v
nbconn	./include/types/listener.h	/^	int nbconn;			\/* current number of connections on this listener *\/$/;"	m	struct:listener
nbits	./include/common/standard.h	/^static inline unsigned long nbits(int bits)$/;"	f
nbpend	./include/types/proxy.h	/^	int nbpend;				\/* number of pending connections with no server assigned yet *\/$/;"	m	struct:proxy
nbpend	./include/types/server.h	/^	int nbpend;				\/* number of pending connections *\/$/;"	m	struct:server
nbpend_max	./include/types/counters.h	/^	unsigned int nbpend_max;		\/* max number of pending connections reached *\/$/;"	m	struct:srvcounters
nbpend_max	./include/types/counters.h	/^	unsigned int nbpend_max;                \/* max number of pending connections with no server assigned yet (BE only) *\/$/;"	m	struct:pxcounters
nbpollers	./src/fd.c	/^int nbpollers = 0;$/;"	v
nbproc	./include/types/global.h	/^	int nbproc;$/;"	m	struct:global
neg	./include/types/acl.h	/^	int neg;                    \/* 1 if the ACL result must be negated *\/$/;"	m	struct:acl_term
neg	./include/types/ssl_sock.h	/^	int neg;                  \/* reject if match *\/$/;"	m	struct:sni_ctx
netns	./include/types/listener.h	/^	const struct netns_entry *netns; \/* network namespace of the listener*\/$/;"	m	struct:listener	typeref:struct:listener::netns_entry
netns	./include/types/server.h	/^	const struct netns_entry *netns;        \/* contains network namespace name or NULL. Network namespace comes from configuration *\/$/;"	m	struct:server	typeref:struct:server::netns_entry
netns_entry	./include/common/namespace.h	/^struct netns_entry$/;"	s
netns_init	./src/namespace.c	/^int netns_init(void)$/;"	f
netns_store_insert	./src/namespace.c	/^struct netns_entry* netns_store_insert(const char *ns_name)$/;"	f
netns_store_lookup	./src/namespace.c	/^const struct netns_entry* netns_store_lookup(const char *ns_name, size_t ns_name_len)$/;"	f
next	./include/common/regex.h	/^    struct hdr_exp *next;$/;"	m	struct:hdr_exp	typeref:struct:hdr_exp::hdr_exp
next	./include/common/uri_auth.h	/^	struct uri_auth *next;		\/* Used at deinit() to build a list of unique elements *\/$/;"	m	struct:uri_auth	typeref:struct:uri_auth::uri_auth
next	./include/common/uri_auth.h	/^	struct uri_scope *next;	\/* next entry, NULL if none *\/$/;"	m	struct:uri_scope	typeref:struct:uri_scope::uri_scope
next	./include/types/auth.h	/^	struct auth_groups *next;$/;"	m	struct:auth_groups	typeref:struct:auth_groups::auth_groups
next	./include/types/auth.h	/^	struct auth_groups_list *next;$/;"	m	struct:auth_groups_list	typeref:struct:auth_groups_list::auth_groups_list
next	./include/types/auth.h	/^	struct auth_users *next;$/;"	m	struct:auth_users	typeref:struct:auth_users::auth_users
next	./include/types/auth.h	/^	struct userlist *next;$/;"	m	struct:userlist	typeref:struct:userlist::userlist
next	./include/types/capture.h	/^    struct cap_hdr *next;$/;"	m	struct:cap_hdr	typeref:struct:cap_hdr::cap_hdr
next	./include/types/compression.h	/^	struct comp_algo *next;$/;"	m	struct:comp_algo	typeref:struct:comp_algo::comp_algo
next	./include/types/compression.h	/^	struct comp_type *next;$/;"	m	struct:comp_type	typeref:struct:comp_type::comp_type
next	./include/types/hdr_idx.h	/^        unsigned next :15; \/* offset of next header if len>0. 0=end of list. *\/$/;"	m	struct:hdr_idx_elem
next	./include/types/lb_fwrr.h	/^	struct eb_root *next;   \/* servers to be placed at next run *\/$/;"	m	struct:fwrr_group	typeref:struct:fwrr_group::eb_root
next	./include/types/mailers.h	/^	struct mailer *next;		\/* next mailer in the list *\/$/;"	m	struct:mailer	typeref:struct:mailer::mailer
next	./include/types/mailers.h	/^	struct mailers *next;	        \/* next mailers section *\/$/;"	m	struct:mailers	typeref:struct:mailers::mailers
next	./include/types/peers.h	/^	struct peer *next;	  \/* next peer in the list *\/$/;"	m	struct:peer	typeref:struct:peer::peer
next	./include/types/peers.h	/^	struct peers *next;		 \/* next peer section *\/$/;"	m	struct:peers	typeref:struct:peers::peers
next	./include/types/peers.h	/^	struct shared_table *next;	    \/* next shared table in list *\/$/;"	m	struct:shared_table	typeref:struct:shared_table::shared_table
next	./include/types/pipe.h	/^	struct pipe *next;$/;"	m	struct:pipe	typeref:struct:pipe::pipe
next	./include/types/proto_http.h	/^	unsigned int next;                     \/* pointer to next byte to parse, relative to buf->p *\/$/;"	m	struct:http_msg
next	./include/types/proxy.h	/^	struct proxy *next;$/;"	m	struct:proxy	typeref:struct:proxy::proxy
next	./include/types/server.h	/^	struct server *next;$/;"	m	struct:server	typeref:struct:server::server
next	./tests/filltab25.c	/^	int next, last;$/;"	m	struct:srv	file:
next_event_delay	./src/freq_ctr.c	/^unsigned int next_event_delay(struct freq_ctr *ctr, unsigned int freq, unsigned int pend)$/;"	f
next_full	./include/types/server.h	/^	struct server *next_full;               \/* next server in the temporary full list *\/$/;"	m	struct:server	typeref:struct:server::server
next_tree	./tests/filltab25.c	/^struct eb_root *next_tree; \/* receives positions >= 2sw *\/$/;"	v	typeref:struct:eb_root
next_weight	./include/types/lb_fwrr.h	/^	int next_weight;        \/* total weight of the next time range *\/$/;"	m	struct:fwrr_group
nice	./include/types/action.h	/^		int nice;                      \/* nice value for ACT_HTTP_SET_NICE *\/$/;"	m	union:act_rule::__anon9
nice	./include/types/listener.h	/^	short int nice;                 \/* nice value to assign to the instanciated tasks *\/$/;"	m	struct:listener
nice	./include/types/task.h	/^	short nice;			\/* the task's current nice value from -1024 to +1024 *\/$/;"	m	struct:task
niced_tasks	./src/task.c	/^unsigned int niced_tasks = 0;      \/* number of niced tasks in the run queue *\/$/;"	v
no_options	./include/types/proxy.h	/^	int no_options;				\/* PR_O_REDISP, PR_O_TRANSP, ... *\/$/;"	m	struct:proxy
no_options2	./include/types/proxy.h	/^	int no_options2;			\/* PR_O2_* *\/$/;"	m	struct:proxy
node	./contrib/halog/halog.c	/^	struct eb32_node node;$/;"	m	struct:timer	typeref:struct:timer::eb32_node	file:
node	./contrib/halog/halog.c	/^	struct ebmb_node node;$/;"	m	struct:srv_st	typeref:struct:srv_st::ebmb_node	file:
node	./contrib/halog/halog.c	/^	} node;$/;"	m	struct:url_stat	typeref:union:url_stat::__anon1	file:
node	./ebtree/eb32tree.h	/^	struct eb_node node; \/* the tree node, must be at the beginning *\/$/;"	m	struct:eb32_node	typeref:struct:eb32_node::eb_node
node	./ebtree/eb64tree.h	/^	struct eb_node node; \/* the tree node, must be at the beginning *\/$/;"	m	struct:eb64_node	typeref:struct:eb64_node::eb_node
node	./ebtree/ebmbtree.h	/^	struct eb_node node; \/* the tree node, must be at the beginning *\/$/;"	m	struct:ebmb_node	typeref:struct:ebmb_node::eb_node
node	./ebtree/ebpttree.h	/^	struct eb_node node; \/* the tree node, must be at the beginning *\/$/;"	m	struct:ebpt_node	typeref:struct:ebpt_node::eb_node
node	./include/common/namespace.h	/^	struct ebpt_node node;$/;"	m	struct:netns_entry	typeref:struct:netns_entry::ebpt_node
node	./include/common/uri_auth.h	/^	char *node, *desc;		\/* node name & description reported in this stats *\/$/;"	m	struct:uri_auth
node	./include/import/lru.h	/^	struct eb64_node node;        \/* indexing key, typically a hash64 *\/$/;"	m	struct:lru64	typeref:struct:lru64::eb64_node
node	./include/types/global.h	/^	char *node, *desc;		\/* node name & description *\/$/;"	m	struct:global
node	./include/types/hlua.h	/^	struct ebpt_node node;$/;"	m	struct:hlua	typeref:struct:hlua::ebpt_node
node	./include/types/pattern.h	/^	struct ebmb_node node;$/;"	m	struct:pattern_tree	typeref:struct:pattern_tree::ebmb_node
node	./include/types/server.h	/^	struct eb32_node node;$/;"	m	struct:tree_occ	typeref:struct:tree_occ::eb32_node
node	./tests/filltab25.c	/^	struct eb32_node node;$/;"	m	struct:srv	typeref:struct:srv::eb32_node	file:
node_p	./ebtree/ebtree.h	/^	eb_troot_t    *node_p;  \/* link node's parent *\/$/;"	m	struct:eb_node
nolinger	./src/haproxy.c	/^const struct linger nolinger = { .l_onoff = 1, .l_linger = 0 };$/;"	v	typeref:struct:linger
nopurge	./include/types/stick_table.h	/^	int nopurge;              \/* if non-zero, don't purge sticky sessions when full *\/$/;"	m	struct:stktable
now	./src/time.c	/^struct timeval now;             \/* internal date is a monotonic function of real clock *\/$/;"	v	typeref:struct:timeval
now_ms	./src/time.c	/^unsigned int   now_ms;          \/* internal date in milliseconds (may wrap) *\/$/;"	v
now_ptr	./src/trace.c	/^static struct timeval *now_ptr;$/;"	v	typeref:struct:timeval	file:
npn_len	./include/types/listener.h	/^	int npn_len;               \/* NPN protocol string length *\/$/;"	m	struct:bind_conf
npn_str	./include/types/listener.h	/^	char *npn_str;             \/* NPN protocol string *\/$/;"	m	struct:bind_conf
npos	./include/types/server.h	/^	unsigned npos, lpos;			\/* next and last positions in the LB tree *\/$/;"	m	struct:server
nscount	./include/types/dns.h	/^	unsigned short	nscount :16;	\/* authority count *\/$/;"	m	struct:dns_header
nsrv	./tests/filltab25.c	/^int nsrv;       \/* # of servers *\/$/;"	v
nsw	./tests/filltab25.c	/^int nsw, sw;    \/* sum of weights *\/$/;"	v
ntohll	./include/common/standard.h	/^static inline unsigned long long ntohll(unsigned long long a)$/;"	f
num	./tests/filltab25.c	/^	int num;$/;"	m	struct:srv	file:
nx	./include/types/dns.h	/^		long int nx;		\/* - NX response *\/$/;"	m	struct:dns_nameserver::__anon65
o	./include/common/buffer.h	/^	unsigned int o;                 \/* number of out bytes the sender can consume from this buffer *\/$/;"	m	struct:buffer
oat_hash	./tests/test_hashes.c	/^unsigned oat_hash ( void *key, int len )$/;"	f
obj_base_ptr	./include/proto/obj_type.h	/^static inline void *obj_base_ptr(enum obj_type *t)$/;"	f
obj_type	./include/proto/obj_type.h	/^static inline enum obj_type obj_type(enum obj_type *t)$/;"	f
obj_type	./include/types/applet.h	/^	enum obj_type obj_type;            \/* object type = OBJ_TYPE_APPLET *\/$/;"	m	struct:applet	typeref:enum:applet::obj_type
obj_type	./include/types/applet.h	/^	enum obj_type obj_type;    \/* OBJ_TYPE_APPCTX *\/$/;"	m	struct:appctx	typeref:enum:appctx::obj_type
obj_type	./include/types/connection.h	/^	enum obj_type obj_type;       \/* differentiates connection from applet context *\/$/;"	m	struct:connection	typeref:enum:connection::obj_type
obj_type	./include/types/listener.h	/^	enum obj_type obj_type;         \/* object type = OBJ_TYPE_LISTENER *\/$/;"	m	struct:listener	typeref:enum:listener::obj_type
obj_type	./include/types/obj_type.h	/^enum obj_type {$/;"	g
obj_type	./include/types/proxy.h	/^	enum obj_type obj_type;                 \/* object type == OBJ_TYPE_PROXY *\/$/;"	m	struct:proxy	typeref:enum:proxy::obj_type
obj_type	./include/types/server.h	/^	enum obj_type obj_type;                 \/* object type == OBJ_TYPE_SERVER *\/$/;"	m	struct:server	typeref:enum:server::obj_type
obj_type_name	./include/proto/obj_type.h	/^static inline const char *obj_type_name(enum obj_type *t)$/;"	f
objt_appctx	./include/proto/obj_type.h	/^static inline struct appctx *objt_appctx(enum obj_type *t)$/;"	f
objt_applet	./include/proto/obj_type.h	/^static inline struct applet *objt_applet(enum obj_type *t)$/;"	f
objt_conn	./include/proto/obj_type.h	/^static inline struct connection *objt_conn(enum obj_type *t)$/;"	f
objt_listener	./include/proto/obj_type.h	/^static inline struct listener *objt_listener(enum obj_type *t)$/;"	f
objt_proxy	./include/proto/obj_type.h	/^static inline struct proxy *objt_proxy(enum obj_type *t)$/;"	f
objt_server	./include/proto/obj_type.h	/^static inline struct server *objt_server(enum obj_type *t)$/;"	f
observe	./include/types/server.h	/^	short observe, onerror;			\/* observing mode: one of HANA_OBS_*; what to do on error: on of ANA_ONERR_* *\/$/;"	m	struct:server
oe	./include/types/proxy.h	/^	struct proxy *oe;		\/* other end = frontend or backend involved *\/$/;"	m	struct:error_snapshot	typeref:struct:error_snapshot::proxy
offload	./include/types/compression.h	/^	unsigned int offload;$/;"	m	struct:comp
offsetof	./include/common/rbtree.h	/^#define offsetof(/;"	d
oldpids	./src/haproxy.c	/^static int *oldpids = NULL;$/;"	v	file:
oldpids_sig	./src/haproxy.c	/^static int oldpids_sig; \/* use USR1 or TERM *\/$/;"	v	file:
one	./contrib/ip6range/ip6range.c	/^static struct in6_addr one = { .in6_u.u6_addr32 = {0, 0, 0, 1} };$/;"	v	typeref:struct:in6_addr	file:
one	./src/haproxy.c	/^const int one = 1;$/;"	v
one	./src/xxhash.c	/^static const int one = 1;$/;"	v	file:
one_ls_b	./contrib/ip6range/ip6range.c	/^static inline struct in6_addr *one_ls_b(unsigned int b, struct in6_addr *r)$/;"	f	file:
onerror	./include/types/server.h	/^	short observe, onerror;			\/* observing mode: one of HANA_OBS_*; what to do on error: on of ANA_ONERR_* *\/$/;"	m	struct:server
onmarkeddown	./include/types/server.h	/^	short onmarkeddown;			\/* what to do when marked down: one of HANA_ONMARKEDDOWN_* *\/$/;"	m	struct:server
onmarkedup	./include/types/server.h	/^	short onmarkedup;			\/* what to do when marked up: one of HANA_ONMARKEDUP_* *\/$/;"	m	struct:server
opcode	./include/types/dns.h	/^	unsigned char	opcode :4;	\/* operation code *\/$/;"	m	struct:dns_header
open_named_namespace	./src/namespace.c	/^static int open_named_namespace(const char *ns_name)$/;"	f	file:
open_trace	./src/trace.c	/^static int open_trace()$/;"	f	file:
ops	./include/types/stream_interface.h	/^	struct si_ops *ops;     \/* general operations at the stream interface layer *\/$/;"	m	struct:stream_interface	typeref:struct:stream_interface::si_ops
opt	./include/types/sample.h	/^	unsigned int opt; \/* fetch options (SMP_OPT_*) *\/$/;"	m	struct:sample
options	./include/types/global.h	/^		int options;       \/* various tuning options *\/$/;"	m	struct:global::__anon72
options	./include/types/listener.h	/^	int options;			\/* socket options : LI_O_* *\/$/;"	m	struct:listener
options	./include/types/log.h	/^	int options;   \/\/ LOG_OPT_*$/;"	m	struct:logformat_node
options	./include/types/proxy.h	/^	int options;				\/* PR_O_REDISP, PR_O_TRANSP, ... *\/$/;"	m	struct:proxy
options	./include/types/server.h	/^		int options;			\/* ssl options *\/$/;"	m	struct:server::__anon122
options2	./include/types/proxy.h	/^	int options2;				\/* PR_O2_* *\/$/;"	m	struct:proxy
opts	./include/types/connection.h	/^	unsigned int opts;                   \/* CO_SRC_* *\/$/;"	m	struct:conn_src
order	./include/types/ssl_sock.h	/^	int order;                \/* load order for the certificate *\/$/;"	m	struct:sni_ctx
orgto_hdr_len	./include/types/proxy.h	/^	int orgto_hdr_len;			\/* length of "x-original-to" header *\/$/;"	m	struct:proxy
orgto_hdr_name	./include/types/proxy.h	/^	char *orgto_hdr_name;			\/* header to use - default: "x-original-to" *\/$/;"	m	struct:proxy
origin	./include/types/session.h	/^	enum obj_type *origin;          \/* the connection \/ applet which initiated this session *\/$/;"	m	struct:session	typeref:enum:session::obj_type
os	./doc/lua-api/conf.py	/^import sys, os$/;"	i
other	./include/types/dns.h	/^		long int other;		\/* - other type of response *\/$/;"	m	struct:dns_nameserver::__anon65
out_type	./include/types/sample.h	/^	unsigned int out_type;                    \/* output sample type *\/$/;"	m	struct:sample_conv
out_type	./include/types/sample.h	/^	unsigned long out_type;                   \/* output sample type *\/$/;"	m	struct:sample_fetch
outdated	./include/types/dns.h	/^		long int outdated;	\/* - outdated response (server slower than the other ones) *\/$/;"	m	struct:dns_nameserver::__anon65
owner	./include/types/applet.h	/^	void *owner;               \/* pointer to upper layer's entity (eg: stream interface) *\/$/;"	m	struct:appctx
owner	./include/types/connection.h	/^	void *owner;                  \/* pointer to upper layer's entity (eg: stream interface) *\/$/;"	m	struct:connection
owner	./include/types/fd.h	/^	void *owner;                         \/* the connection or listener associated with this fd, NULL if closed *\/$/;"	m	struct:fdtab
owner	./include/types/proto_udp.h	/^	void *owner;				\/* pointer to upper layer's entity *\/$/;"	m	struct:dgram_conn
p	./include/common/buffer.h	/^	char *p;                        \/* buffer's start pointer, separates in and out data *\/$/;"	m	struct:buffer
p	./include/common/mini-clist.h	/^    struct list *p;	\/* prev *\/$/;"	m	struct:list	typeref:struct:list::list
p	./include/import/lru.h	/^	struct lru64_list *p;$/;"	m	struct:lru64_list	typeref:struct:lru64_list::lru64_list
p	./include/types/action.h	/^			void *p[4];$/;"	m	struct:act_rule::__anon9::__anon20
p	./include/types/counters.h	/^	} p;                                    \/* protocol-specific stats *\/$/;"	m	struct:pxcounters	typeref:union:pxcounters::__anon57
p	./include/types/counters.h	/^	} p;$/;"	m	struct:srvcounters	typeref:union:srvcounters::__anon59
p	./include/types/hlua.h	/^	struct proxy *p;$/;"	m	struct:hlua_smp	typeref:struct:hlua_smp::proxy
p	./include/types/hlua.h	/^	struct proxy *p;$/;"	m	struct:hlua_txn	typeref:struct:hlua_txn::proxy
p	./include/types/sample.h	/^	void *p;        \/* any pointer *\/$/;"	m	union:smp_ctx
p	./include/types/stick_table.h	/^		struct peers *p; \/* sync peers *\/$/;"	m	union:stktable::__anon127	typeref:struct:stktable::__anon127::peers
p	./include/types/stick_table.h	/^		void *p;$/;"	m	union:stktable::__anon128
p	./src/shctx.c	/^	struct shared_block *p;$/;"	m	struct:shared_block	typeref:struct:shared_block::shared_block	file:
p	./tests/filltab25.c	/^int p;          \/* current position, between sw..2sw-1 *\/$/;"	v
p_malloc	./include/common/debug.h	/^static inline void *p_malloc(size_t size)$/;"	f
parent	./include/types/proxy.h	/^	void *parent;				\/* parent of the proxy when applicable *\/$/;"	m	struct:proxy
parse	./include/common/cfgparse.h	/^	int (*parse)(                           \/* 0=OK, <0=Alert, >0=Warning *\/$/;"	m	struct:cfg_keyword
parse	./include/types/acl.h	/^	int (*parse)(const char *text, struct pattern *pattern, int flags, char **err);$/;"	m	struct:acl_keyword
parse	./include/types/action.h	/^	enum act_parse_ret (*parse)(const char **args, int *cur_arg, struct proxy *px,$/;"	m	struct:action_kw	typeref:enum:action_kw::parse
parse	./include/types/listener.h	/^	int (*parse)(char **args, int cur_arg, struct proxy *px, struct bind_conf *conf, char **err);$/;"	m	struct:bind_kw
parse	./include/types/pattern.h	/^	int (*parse)(const char *text, struct pattern *pattern, int flags, char **err);$/;"	m	struct:pattern_head
parse	./include/types/server.h	/^	int (*parse)(char **args, int *cur_arg, struct proxy *px, struct server *srv, char **err);$/;"	m	struct:srv_kw
parse_acl	./src/acl.c	/^struct acl *parse_acl(const char **args, struct list *known_acl, char **err, struct arg_list *al,$/;"	f
parse_acl_cond	./src/acl.c	/^struct acl_cond *parse_acl_cond(const char **args, struct list *known_acl,$/;"	f
parse_acl_expr	./src/acl.c	/^struct acl_expr *parse_acl_expr(const char **args, char **err, struct arg_list *al,$/;"	f
parse_binary	./src/standard.c	/^int parse_binary(const char *source, char **binstr, int *binstrlen, char **err)$/;"	f
parse_conf	./examples/check	/^sub parse_conf$/;"	s
parse_err	./contrib/halog/halog.c	/^int parse_err = 0;$/;"	v
parse_http_req_capture	./src/proto_http.c	/^enum act_parse_ret parse_http_req_capture(const char **args, int *orig_arg, struct proxy *px,$/;"	f
parse_http_req_cond	./src/proto_http.c	/^struct act_rule *parse_http_req_cond(const char **args, const char *file, int linenum, struct proxy *proxy)$/;"	f
parse_http_res_capture	./src/proto_http.c	/^enum act_parse_ret parse_http_res_capture(const char **args, int *orig_arg, struct proxy *px,$/;"	f
parse_http_res_cond	./src/proto_http.c	/^struct act_rule *parse_http_res_cond(const char **args, const char *file, int linenum, struct proxy *proxy)$/;"	f
parse_http_set_status	./src/proto_http.c	/^enum act_parse_ret parse_http_set_status(const char **args, int *orig_arg, struct proxy *px,$/;"	f
parse_inc_gpc0	./src/stick_table.c	/^static enum act_parse_ret parse_inc_gpc0(const char **args, int *arg, struct proxy *px,$/;"	f	file:
parse_logformat_string	./src/log.c	/^void parse_logformat_string(const char *fmt, struct proxy *curproxy, struct list *list_format, int options, int cap, const char *file, int line)$/;"	f
parse_logformat_var	./src/log.c	/^int parse_logformat_var(char *arg, int arg_len, char *var, int var_len, struct proxy *curproxy, struct list *list_format, int *defoptions)$/;"	f
parse_logformat_var_args	./src/log.c	/^int parse_logformat_var_args(char *args, struct logformat_node *node)$/;"	f
parse_qvalue	./src/proto_http.c	/^int parse_qvalue(const char *qvalue, const char **end)$/;"	f
parse_server	./src/server.c	/^int parse_server(const char *file, int linenum, char **args, struct proxy *curproxy, struct proxy *defproxy)$/;"	f
parse_set_gpt0	./src/stick_table.c	/^static enum act_parse_ret parse_set_gpt0(const char **args, int *arg, struct proxy *px,$/;"	f	file:
parse_set_req_line	./src/proto_http.c	/^enum act_parse_ret parse_set_req_line(const char **args, int *orig_arg, struct proxy *px,$/;"	f
parse_size_err	./src/standard.c	/^const char *parse_size_err(const char *text, unsigned *ret) {$/;"	f
parse_smp	./include/types/pattern.h	/^	int (*parse_smp)(const char *text, struct sample_data *data);$/;"	m	struct:pattern_head
parse_store	./src/vars.c	/^static enum act_parse_ret parse_store(const char **args, int *arg, struct proxy *px,$/;"	f	file:
parse_time_err	./src/standard.c	/^const char *parse_time_err(const char *text, unsigned *ret, unsigned unit_flags)$/;"	f
pass	./include/types/auth.h	/^	char *user, *pass;$/;"	m	struct:auth_users
pass	./include/types/proto_http.h	/^	char *user, *pass;                    \/* extracted username & password *\/$/;"	m	struct:http_auth_data
pat	./include/types/acl.h	/^	struct pattern_head pat;      \/* the pattern matching expression *\/$/;"	m	struct:acl_expr	typeref:struct:acl_expr::pattern_head
pat	./include/types/map.h	/^	struct pattern_head pat;       \/* the pattern matching associated to the map *\/$/;"	m	struct:map_descriptor	typeref:struct:map_descriptor::pattern_head
pat	./include/types/pattern.h	/^	struct list pat; \/* The head of the list of struct pattern_expr. *\/$/;"	m	struct:pat_ref	typeref:struct:pat_ref::list
pat	./include/types/pattern.h	/^	struct pattern pat;$/;"	m	struct:pattern_list	typeref:struct:pattern_list::pattern
pat2acl	./src/acl.c	/^static inline enum acl_test_res pat2acl(struct pattern *pat)$/;"	f	file:
pat_del_list_ptr	./src/pattern.c	/^void pat_del_list_ptr(struct pattern_expr *expr, struct pat_ref_elt *ref)$/;"	f
pat_del_list_reg	./src/pattern.c	/^void pat_del_list_reg(struct pattern_expr *expr, struct pat_ref_elt *ref)$/;"	f
pat_del_list_val	./src/pattern.c	/^void pat_del_list_val(struct pattern_expr *expr, struct pat_ref_elt *ref)$/;"	f
pat_del_tree_ip	./src/pattern.c	/^void pat_del_tree_ip(struct pattern_expr *expr, struct pat_ref_elt *ref)$/;"	f
pat_del_tree_str	./src/pattern.c	/^void pat_del_tree_str(struct pattern_expr *expr, struct pat_ref_elt *ref)$/;"	f
pat_delete_fcts	./src/pattern.c	/^void (*pat_delete_fcts[PAT_MATCH_NUM])(struct pattern_expr *, struct pat_ref_elt *) = {$/;"	v
pat_expr_get_next	./src/dumpstats.c	/^struct pattern_expr *pat_expr_get_next(struct pattern_expr *getnext, struct list *end)$/;"	f	file:
pat_find_match_name	./include/proto/pattern.h	/^static inline int pat_find_match_name(const char *name)$/;"	f
pat_head	./include/types/pattern.h	/^	struct pattern_head *pat_head; \/* Point to the pattern_head that contain manipulation functions.$/;"	m	struct:pattern_expr	typeref:struct:pattern_expr::pattern_head
pat_idx_list_ptr	./src/pattern.c	/^int pat_idx_list_ptr(struct pattern_expr *expr, struct pattern *pat, char **err)$/;"	f
pat_idx_list_reg	./src/pattern.c	/^int pat_idx_list_reg(struct pattern_expr *expr, struct pattern *pat, char **err)$/;"	f
pat_idx_list_str	./src/pattern.c	/^int pat_idx_list_str(struct pattern_expr *expr, struct pattern *pat, char **err)$/;"	f
pat_idx_list_val	./src/pattern.c	/^int pat_idx_list_val(struct pattern_expr *expr, struct pattern *pat, char **err)$/;"	f
pat_idx_tree_ip	./src/pattern.c	/^int pat_idx_tree_ip(struct pattern_expr *expr, struct pattern *pat, char **err)$/;"	f
pat_idx_tree_pfx	./src/pattern.c	/^int pat_idx_tree_pfx(struct pattern_expr *expr, struct pattern *pat, char **err)$/;"	f
pat_idx_tree_str	./src/pattern.c	/^int pat_idx_tree_str(struct pattern_expr *expr, struct pattern *pat, char **err)$/;"	f
pat_index_fcts	./src/pattern.c	/^int (*pat_index_fcts[PAT_MATCH_NUM])(struct pattern_expr *, struct pattern *, char **) = {$/;"	v
pat_list_get_next	./src/dumpstats.c	/^struct pat_ref *pat_list_get_next(struct pat_ref *getnext, struct list *end,$/;"	f	file:
pat_lru_seed	./src/pattern.c	/^static unsigned long long pat_lru_seed;$/;"	v	file:
pat_lru_tree	./src/pattern.c	/^static struct lru64_head *pat_lru_tree;$/;"	v	typeref:struct:lru64_head	file:
pat_match_auth	./src/auth.c	/^pat_match_auth(struct sample *smp, struct pattern_expr *expr, int fill)$/;"	f
pat_match_beg	./src/pattern.c	/^struct pattern *pat_match_beg(struct sample *smp, struct pattern_expr *expr, int fill)$/;"	f
pat_match_bin	./src/pattern.c	/^struct pattern *pat_match_bin(struct sample *smp, struct pattern_expr *expr, int fill)$/;"	f
pat_match_dir	./src/pattern.c	/^struct pattern *pat_match_dir(struct sample *smp, struct pattern_expr *expr, int fill)$/;"	f
pat_match_dom	./src/pattern.c	/^struct pattern *pat_match_dom(struct sample *smp, struct pattern_expr *expr, int fill)$/;"	f
pat_match_end	./src/pattern.c	/^struct pattern *pat_match_end(struct sample *smp, struct pattern_expr *expr, int fill)$/;"	f
pat_match_fcts	./src/pattern.c	/^struct pattern *(*pat_match_fcts[PAT_MATCH_NUM])(struct sample *, struct pattern_expr *, int) = {$/;"	v	typeref:struct:pat_match_fcts
pat_match_int	./src/pattern.c	/^struct pattern *pat_match_int(struct sample *smp, struct pattern_expr *expr, int fill)$/;"	f
pat_match_ip	./src/pattern.c	/^struct pattern *pat_match_ip(struct sample *smp, struct pattern_expr *expr, int fill)$/;"	f
pat_match_len	./src/pattern.c	/^struct pattern *pat_match_len(struct sample *smp, struct pattern_expr *expr, int fill)$/;"	f
pat_match_meth	./src/proto_http.c	/^static struct pattern *pat_match_meth(struct sample *smp, struct pattern_expr *expr, int fill)$/;"	f	file:
pat_match_names	./src/pattern.c	/^char *pat_match_names[PAT_MATCH_NUM] = {$/;"	v
pat_match_nothing	./src/pattern.c	/^struct pattern *pat_match_nothing(struct sample *smp, struct pattern_expr *expr, int fill)$/;"	f
pat_match_reg	./src/pattern.c	/^struct pattern *pat_match_reg(struct sample *smp, struct pattern_expr *expr, int fill)$/;"	f
pat_match_res	./include/types/pattern.h	/^enum pat_match_res {$/;"	g
pat_match_str	./src/pattern.c	/^struct pattern *pat_match_str(struct sample *smp, struct pattern_expr *expr, int fill)$/;"	f
pat_match_sub	./src/pattern.c	/^struct pattern *pat_match_sub(struct sample *smp, struct pattern_expr *expr, int fill)$/;"	f
pat_match_types	./src/pattern.c	/^int pat_match_types[PAT_MATCH_NUM] = {$/;"	v
pat_parse_bin	./src/pattern.c	/^int pat_parse_bin(const char *text, struct pattern *pattern, int mflags, char **err)$/;"	f
pat_parse_dotted_ver	./src/pattern.c	/^int pat_parse_dotted_ver(const char *text, struct pattern *pattern, int mflags, char **err)$/;"	f
pat_parse_fcts	./src/pattern.c	/^int (*pat_parse_fcts[PAT_MATCH_NUM])(const char *, struct pattern *, int, char **) = {$/;"	v
pat_parse_int	./src/pattern.c	/^int pat_parse_int(const char *text, struct pattern *pattern, int mflags, char **err)$/;"	f
pat_parse_ip	./src/pattern.c	/^int pat_parse_ip(const char *text, struct pattern *pattern, int mflags, char **err)$/;"	f
pat_parse_meth	./src/proto_http.c	/^static int pat_parse_meth(const char *text, struct pattern *pattern, int mflags, char **err)$/;"	f	file:
pat_parse_nothing	./src/pattern.c	/^int pat_parse_nothing(const char *text, struct pattern *pattern, int mflags, char **err)$/;"	f
pat_parse_reg	./src/pattern.c	/^int pat_parse_reg(const char *text, struct pattern *pattern, int mflags, char **err)$/;"	f
pat_parse_str	./src/pattern.c	/^int pat_parse_str(const char *text, struct pattern *pattern, int mflags, char **err)$/;"	f
pat_prune_fcts	./src/pattern.c	/^void (*pat_prune_fcts[PAT_MATCH_NUM])(struct pattern_expr *) = {$/;"	v
pat_prune_ptr	./src/pattern.c	/^void pat_prune_ptr(struct pattern_expr *expr)$/;"	f
pat_prune_reg	./src/pattern.c	/^void pat_prune_reg(struct pattern_expr *expr)$/;"	f
pat_prune_val	./src/pattern.c	/^void pat_prune_val(struct pattern_expr *expr)$/;"	f
pat_ref	./include/types/pattern.h	/^struct pat_ref {$/;"	s
pat_ref_add	./src/pattern.c	/^int pat_ref_add(struct pat_ref *ref,$/;"	f
pat_ref_append	./src/pattern.c	/^int pat_ref_append(struct pat_ref *ref, char *pattern, char *sample, int line)$/;"	f
pat_ref_delete	./src/pattern.c	/^int pat_ref_delete(struct pat_ref *ref, const char *key)$/;"	f
pat_ref_delete_by_id	./src/pattern.c	/^int pat_ref_delete_by_id(struct pat_ref *ref, struct pat_ref_elt *refelt)$/;"	f
pat_ref_elt	./include/types/pattern.h	/^struct pat_ref_elt {$/;"	s
pat_ref_find_elt	./src/pattern.c	/^struct pat_ref_elt *pat_ref_find_elt(struct pat_ref *ref, const char *key)$/;"	f
pat_ref_lookup	./src/pattern.c	/^struct pat_ref *pat_ref_lookup(const char *reference)$/;"	f
pat_ref_lookup_ref	./src/dumpstats.c	/^struct pat_ref *pat_ref_lookup_ref(const char *reference)$/;"	f	file:
pat_ref_lookupid	./src/pattern.c	/^struct pat_ref *pat_ref_lookupid(int unique_id)$/;"	f
pat_ref_new	./src/pattern.c	/^struct pat_ref *pat_ref_new(const char *reference, const char *display, unsigned int flags)$/;"	f
pat_ref_newid	./src/pattern.c	/^struct pat_ref *pat_ref_newid(int unique_id, const char *display, unsigned int flags)$/;"	f
pat_ref_prune	./src/pattern.c	/^void pat_ref_prune(struct pat_ref *ref)$/;"	f
pat_ref_push	./src/pattern.c	/^int pat_ref_push(struct pat_ref_elt *elt, struct pattern_expr *expr,$/;"	f	file:
pat_ref_read_from_file	./src/pattern.c	/^int pat_ref_read_from_file(struct pat_ref *ref, const char *filename, char **err)$/;"	f
pat_ref_read_from_file_smp	./src/pattern.c	/^int pat_ref_read_from_file_smp(struct pat_ref *ref, const char *filename, char **err)$/;"	f
pat_ref_reload	./src/pattern.c	/^void pat_ref_reload(struct pat_ref *ref, struct pat_ref *replace)$/;"	f
pat_ref_set	./src/pattern.c	/^int pat_ref_set(struct pat_ref *ref, const char *key, const char *value, char **err)$/;"	f
pat_ref_set_by_id	./src/pattern.c	/^int pat_ref_set_by_id(struct pat_ref *ref, struct pat_ref_elt *refelt, const char *value, char **err)$/;"	f
pat_ref_set_elt	./src/pattern.c	/^static inline int pat_ref_set_elt(struct pat_ref *ref, struct pat_ref_elt *elt,$/;"	f	file:
pat_time	./include/types/pattern.h	/^struct pat_time {$/;"	s
pattern	./include/types/pattern.h	/^	char *pattern;$/;"	m	struct:pat_ref_elt
pattern	./include/types/pattern.h	/^struct pattern {$/;"	s
pattern_cache	./include/types/global.h	/^		int pattern_cache; \/* max number of entries in the pattern cache. *\/$/;"	m	struct:global::__anon72
pattern_delete	./src/pattern.c	/^int pattern_delete(struct pattern_expr *expr, struct pat_ref_elt *ref)$/;"	f
pattern_exec_match	./src/pattern.c	/^struct pattern *pattern_exec_match(struct pattern_head *head, struct sample *smp, int fill)$/;"	f
pattern_expr	./include/types/pattern.h	/^struct pattern_expr {$/;"	s
pattern_expr_list	./include/types/pattern.h	/^struct pattern_expr_list {$/;"	s
pattern_finalize_config	./src/pattern.c	/^void pattern_finalize_config(void)$/;"	f
pattern_find_smp	./src/pattern.c	/^struct sample_data **pattern_find_smp(struct pattern_expr *expr, struct pat_ref_elt *ref)$/;"	f
pattern_head	./include/types/pattern.h	/^struct pattern_head {$/;"	s
pattern_init_expr	./src/pattern.c	/^void pattern_init_expr(struct pattern_expr *expr)$/;"	f
pattern_init_head	./src/pattern.c	/^void pattern_init_head(struct pattern_head *head)$/;"	f
pattern_list	./include/types/pattern.h	/^struct pattern_list {$/;"	s
pattern_lookup_expr	./src/pattern.c	/^struct pattern_expr *pattern_lookup_expr(struct pattern_head *head, struct pat_ref *ref)$/;"	f
pattern_new_expr	./src/pattern.c	/^struct pattern_expr *pattern_new_expr(struct pattern_head *head, struct pat_ref *ref,$/;"	f
pattern_prune	./src/pattern.c	/^void pattern_prune(struct pattern_head *head)$/;"	f
pattern_read_from_file	./src/pattern.c	/^int pattern_read_from_file(struct pattern_head *head, unsigned int refflags,$/;"	f
pattern_reference	./src/pattern.c	/^struct list pattern_reference = LIST_HEAD_INIT(pattern_reference);$/;"	v	typeref:struct:list
pattern_tree	./include/types/pattern.h	/^	struct eb_root pattern_tree;  \/* may be used for lookup in large datasets *\/$/;"	m	struct:pattern_expr	typeref:struct:pattern_expr::eb_root
pattern_tree	./include/types/pattern.h	/^struct pattern_tree {$/;"	s
pattern_tree_2	./include/types/pattern.h	/^	struct eb_root pattern_tree_2;  \/* may be used for different types *\/$/;"	m	struct:pattern_expr	typeref:struct:pattern_expr::eb_root
patterns	./include/types/pattern.h	/^	struct list patterns;         \/* list of acl_patterns *\/$/;"	m	struct:pattern_expr	typeref:struct:pattern_expr::list
pause	./include/types/protocol.h	/^	int (*pause)(struct listener *l);               \/* temporarily pause this listener for a soft restart *\/$/;"	m	struct:protocol
pause_listener	./src/listener.c	/^int pause_listener(struct listener *l)$/;"	f
pause_proxies	./src/proxy.c	/^void pause_proxies(void)$/;"	f
pause_proxy	./src/proxy.c	/^int pause_proxy(struct proxy *p)$/;"	f
peer	./include/types/peers.h	/^struct peer {$/;"	s
peer_applet	./src/peers.c	/^static struct applet peer_applet = {$/;"	v	typeref:struct:applet	file:
peer_io_handler	./src/peers.c	/^static void peer_io_handler(struct appctx *appctx)$/;"	f	file:
peer_prepare_ackmsg	./src/peers.c	/^static int peer_prepare_ackmsg(struct shared_table *st, char *msg, size_t size)$/;"	f	file:
peer_prepare_switchmsg	./src/peers.c	/^static int peer_prepare_switchmsg(struct shared_table *st, char *msg, size_t size)$/;"	f	file:
peer_prepare_updatemsg	./src/peers.c	/^static int peer_prepare_updatemsg(struct stksess *ts, struct shared_table *st, char *msg, size_t size, int use_identifier)$/;"	f	file:
peer_session_create	./src/peers.c	/^static struct stream *peer_session_create(struct peers *peers, struct peer *peer)$/;"	f	file:
peer_session_forceshutdown	./src/peers.c	/^static void peer_session_forceshutdown(struct stream * stream)$/;"	f	file:
peer_session_release	./src/peers.c	/^static void peer_session_release(struct appctx *appctx)$/;"	f	file:
peers	./include/types/applet.h	/^		} peers;$/;"	m	union:appctx::__anon21	typeref:struct:appctx::__anon21::__anon27
peers	./include/types/peers.h	/^struct peers {$/;"	s
peers	./include/types/stick_table.h	/^	} peers;$/;"	m	struct:stktable	typeref:union:stktable::__anon127
peers	./src/peers.c	/^struct peers *peers = NULL;$/;"	v	typeref:struct:peers
peers_fe	./include/types/peers.h	/^	struct proxy *peers_fe;		 \/* peer frontend *\/$/;"	m	struct:peers	typeref:struct:peers::proxy
peers_init_sync	./src/peers.c	/^void peers_init_sync(struct peers *peers)$/;"	f
peers_register_table	./src/peers.c	/^void peers_register_table(struct peers *peers, struct stktable *table)$/;"	f
peers_setup_frontend	./src/peers.c	/^void peers_setup_frontend(struct proxy *fe)$/;"	f
pend_pos	./include/types/stream.h	/^	struct pendconn *pend_pos;      \/* if not NULL, points to the position in the pending queue *\/$/;"	m	struct:stream	typeref:struct:stream::pendconn
pendconn	./include/types/queue.h	/^struct pendconn {$/;"	s
pendconn_add	./src/queue.c	/^struct pendconn *pendconn_add(struct stream *strm)$/;"	f
pendconn_free	./src/queue.c	/^void pendconn_free(struct pendconn *p)$/;"	f
pendconn_from_px	./include/proto/queue.h	/^static inline struct pendconn *pendconn_from_px(const struct proxy *px) {$/;"	f
pendconn_from_srv	./include/proto/queue.h	/^static inline struct pendconn *pendconn_from_srv(const struct server *s) {$/;"	f
pendconn_get_next_strm	./src/queue.c	/^struct stream *pendconn_get_next_strm(struct server *srv, struct proxy *px)$/;"	f
pendconn_grab_from_px	./src/queue.c	/^int pendconn_grab_from_px(struct server *s)$/;"	f
pendconn_redistribute	./src/queue.c	/^int pendconn_redistribute(struct server *s)$/;"	f
pendconns	./include/types/proxy.h	/^	struct list pendconns;			\/* pending connections with no server assigned yet *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
pendconns	./include/types/server.h	/^	struct list pendconns;			\/* pending connections *\/$/;"	m	struct:server	typeref:struct:server::list
persist_rule	./include/types/proxy.h	/^struct persist_rule {$/;"	s
persist_rules	./include/types/proxy.h	/^	struct list persist_rules;		\/* 'force-persist' and 'ignore-persist' rules (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
pfx	./ebtree/ebtree.h	/^	short unsigned int pfx; \/* data prefix length, always related to leaf *\/$/;"	m	struct:eb_node
pid	./include/types/server.h	/^	pid_t pid;$/;"	m	struct:pid_list
pid	./src/haproxy.c	/^int  pid;			\/* current process id *\/$/;"	v
pid	./src/log.c	/^	} pid;$/;"	m	struct:log_fmt	typeref:struct:log_fmt::__anon138	file:
pid_file	./src/haproxy-systemd-wrapper.c	/^static char *pid_file = "\/run\/haproxy.pid";$/;"	v	file:
pid_list	./include/types/server.h	/^struct pid_list {$/;"	s
pid_list	./src/checks.c	/^static struct list pid_list = LIST_HEAD_INIT(pid_list);$/;"	v	typeref:struct:list	file:
pid_list_add	./src/checks.c	/^static struct pid_list *pid_list_add(pid_t pid, struct task *t)$/;"	f	file:
pid_list_del	./src/checks.c	/^static void pid_list_del(struct pid_list *elem)$/;"	f	file:
pid_list_expire	./src/checks.c	/^static void pid_list_expire(pid_t pid, int status)$/;"	f	file:
pidfile	./include/types/global.h	/^	char *pidfile;$/;"	m	struct:global
pipe	./include/types/channel.h	/^	struct pipe *pipe;		\/* non-NULL only when data present *\/$/;"	m	struct:channel	typeref:struct:channel::pipe
pipe	./include/types/pipe.h	/^struct pipe {$/;"	s
pipes_free	./src/pipe.c	/^int pipes_free = 0;             \/* # of pipes unused *\/$/;"	v
pipes_live	./src/pipe.c	/^struct pipe *pipes_live = NULL; \/* pipes which are still ready to use *\/$/;"	v	typeref:struct:pipe
pipes_used	./src/pipe.c	/^int pipes_used = 0;             \/* # of pipes in use (2 fds each) *\/$/;"	v
pipesize	./include/types/global.h	/^		int pipesize;      \/* pipe size in bytes, system defaults if zero *\/$/;"	m	struct:global::__anon72
pmatch	./src/regex.c	/^regmatch_t pmatch[MAX_MATCH];  \/* rm_so, rm_eo for regular expressions *\/$/;"	v
pol	./include/types/acl.h	/^	enum acl_cond_pol pol;      \/* polarity: ACL_COND_IF \/ ACL_COND_UNLESS *\/$/;"	m	struct:acl_cond	typeref:enum:acl_cond::acl_cond_pol
poll	./include/types/fd.h	/^    	void REGPRM2   (*poll)(struct poller *p, int exp);   \/* the poller itself *\/$/;"	m	struct:poller
poll_events	./src/ev_poll.c	/^static struct pollfd *poll_events = NULL;$/;"	v	typeref:struct:pollfd	file:
poller	./include/types/fd.h	/^struct poller {$/;"	s
pollers	./src/fd.c	/^struct poller pollers[MAX_POLLERS];$/;"	v	typeref:struct:poller
pool	./include/types/capture.h	/^    struct pool_head *pool;		\/* pool of pre-allocated memory area of (len+1) bytes *\/$/;"	m	struct:cap_hdr	typeref:struct:cap_hdr::pool_head
pool	./include/types/global.h	/^		fiftyoneDegreesWorksetPool *pool; \/* pool of worksets to avoid creating a new one for each request. *\/$/;"	m	struct:global::__anon76
pool	./include/types/stick_table.h	/^	struct pool_head *pool;   \/* pool used to allocate sticky sessions *\/$/;"	m	struct:stktable	typeref:struct:stktable::pool_head
pool2_buffer	./src/buffer.c	/^struct pool_head *pool2_buffer;$/;"	v	typeref:struct:pool_head
pool2_capture	./src/proto_http.c	/^struct pool_head *pool2_capture = NULL;$/;"	v	typeref:struct:pool_head
pool2_connection	./src/connection.c	/^struct pool_head *pool2_connection;$/;"	v	typeref:struct:pool_head
pool2_hdr_idx	./src/hdr_idx.c	/^struct pool_head *pool2_hdr_idx = NULL;$/;"	v	typeref:struct:pool_head
pool2_hlua_com	./src/hlua.c	/^struct pool_head *pool2_hlua_com;$/;"	v	typeref:struct:pool_head
pool2_http_txn	./src/proto_http.c	/^struct pool_head *pool2_http_txn;$/;"	v	typeref:struct:pool_head
pool2_pendconn	./src/queue.c	/^struct pool_head *pool2_pendconn;$/;"	v	typeref:struct:pool_head
pool2_pid_list	./src/checks.c	/^static struct pool_head *pool2_pid_list;$/;"	v	typeref:struct:pool_head	file:
pool2_pipe	./src/pipe.c	/^struct pool_head *pool2_pipe = NULL;$/;"	v	typeref:struct:pool_head
pool2_requri	./src/proto_http.c	/^struct pool_head *pool2_requri;$/;"	v	typeref:struct:pool_head
pool2_session	./src/session.c	/^struct pool_head *pool2_session;$/;"	v	typeref:struct:pool_head
pool2_sig_handlers	./src/signal.c	/^struct pool_head *pool2_sig_handlers = NULL;$/;"	v	typeref:struct:pool_head
pool2_stream	./src/stream.c	/^struct pool_head *pool2_stream;$/;"	v	typeref:struct:pool_head
pool2_task	./src/task.c	/^struct pool_head *pool2_task;$/;"	v	typeref:struct:pool_head
pool2_uniqueid	./src/proto_http.c	/^struct pool_head *pool2_uniqueid;$/;"	v	typeref:struct:pool_head
pool_alloc	./tests/test_pools.c	/^#define pool_alloc(/;"	d	file:
pool_alloc2	./include/common/memory.h	/^static inline void *pool_alloc2(struct pool_head *pool)$/;"	f
pool_alloc_dirty	./include/common/memory.h	/^static inline void *pool_alloc_dirty(struct pool_head *pool)$/;"	f
pool_alloc_from	./tests/test_pools.c	/^#define pool_alloc_from(/;"	d	file:
pool_comp_ctx	./src/compression.c	/^static struct pool_head *pool_comp_ctx = NULL;$/;"	v	typeref:struct:pool_head	file:
pool_destroy	./include/common/memory.h	/^static inline void pool_destroy(void **pool)$/;"	f
pool_destroy	./tests/test_pools.c	/^static inline void pool_destroy(void **pool)$/;"	f	file:
pool_destroy2	./src/memory.c	/^void *pool_destroy2(struct pool_head *pool)$/;"	f
pool_flush2	./src/memory.c	/^void pool_flush2(struct pool_head *pool)$/;"	f
pool_free	./tests/test_pools.c	/^#define pool_free(/;"	d	file:
pool_free2	./include/common/memory.h	/^static inline void pool_free2(struct pool_head *pool, void *ptr)$/;"	f
pool_free_to	./tests/test_pools.c	/^#define pool_free_to(/;"	d	file:
pool_gc2	./src/memory.c	/^void pool_gc2()$/;"	f
pool_get_first	./include/common/memory.h	/^static inline void *pool_get_first(struct pool_head *pool)$/;"	f
pool_head	./include/common/memory.h	/^struct pool_head {$/;"	s
pool_refill_alloc	./src/memory.c	/^void *pool_refill_alloc(struct pool_head *pool, unsigned int avail)$/;"	f
pools	./src/memory.c	/^static struct list pools = LIST_HEAD_INIT(pools);$/;"	v	typeref:struct:list	file:
port	./include/types/checks.h	/^	unsigned short port;			\/* the port to use for the health checks *\/$/;"	m	struct:check
port	./include/types/checks.h	/^	unsigned short port;                    \/* port to connect to *\/$/;"	m	struct:tcpcheck_rule
port_range	./include/types/fd.h	/^	struct port_range *port_range;       \/* optional port range to bind to *\/$/;"	m	struct:fdinfo	typeref:struct:fdinfo::port_range
port_range	./include/types/port_range.h	/^struct port_range {$/;"	s
port_range_alloc_port	./include/proto/port_range.h	/^static inline int port_range_alloc_port(struct port_range *range)$/;"	f
port_range_alloc_range	./include/proto/port_range.h	/^static inline struct port_range *port_range_alloc_range(int n)$/;"	f
port_range_release_port	./include/proto/port_range.h	/^static inline void port_range_release_port(struct port_range *range, int port)$/;"	f
port_to_str	./src/standard.c	/^int port_to_str(struct sockaddr_storage *addr, char *str, int size)$/;"	f
ports	./include/types/port_range.h	/^	uint16_t ports[0];		\/* array of <size> ports, in host byte order *\/$/;"	m	struct:port_range
pos	./include/types/applet.h	/^			int pos;		\/* last position of the current session's buffer *\/$/;"	m	struct:appctx::__anon21::__anon23
pos	./include/types/proxy.h	/^	unsigned int pos;		\/* position of the first invalid character *\/$/;"	m	struct:error_snapshot
pp_opts	./include/types/server.h	/^	int pp_opts;				\/* proxy protocol options (SRV_PP_*) *\/$/;"	m	struct:server
pr_mode	./include/types/proxy.h	/^enum pr_mode {$/;"	g
pr_state	./include/types/proxy.h	/^enum pr_state {$/;"	g
pref	./include/types/fd.h	/^	int    pref;                                         \/* try pollers with higher preference first *\/$/;"	m	struct:poller
prefix	./include/types/global.h	/^		char *prefix;           \/* path prefix of unix bind socket *\/$/;"	m	struct:global::__anon73
preg	./include/common/regex.h	/^    struct my_regex *preg;		\/* expression to look for *\/$/;"	m	struct:hdr_exp	typeref:struct:hdr_exp::my_regex
prepare_addrsource	./src/log.c	/^int prepare_addrsource(struct logformat_node *node, struct proxy *curproxy)$/;"	f
prepare_external_check	./src/checks.c	/^static int prepare_external_check(struct check *check)$/;"	f	file:
prev	./include/types/proto_http.h	/^	int  prev; \/* index of previous header *\/$/;"	m	struct:hdr_ctx
prev_admin	./include/types/server.h	/^	enum srv_admin admin, prev_admin;       \/* server maintenance status : SRV_ADMF_* *\/$/;"	m	struct:server	typeref:enum:server::
prev_ctr	./include/types/freq_ctr.h	/^	unsigned int prev_ctr;  \/* value for last period *\/$/;"	m	struct:freq_ctr_period
prev_ctr	./include/types/freq_ctr.h	/^	unsigned int prev_ctr; \/* value for last period *\/$/;"	m	struct:freq_ctr
prev_eweight	./include/types/server.h	/^	unsigned prev_eweight;			\/* eweight before last change *\/$/;"	m	struct:server
prev_state	./include/types/server.h	/^	enum srv_state state, prev_state;       \/* server state among SRV_ST_* *\/$/;"	m	struct:server	typeref:enum:server::
prev_state	./include/types/stream_interface.h	/^	enum si_state prev_state;\/* SI_ST*, copy of previous state *\/$/;"	m	struct:stream_interface	typeref:enum:stream_interface::si_state
printUsage	./examples/stats_haproxy.sh	/^printUsage ()$/;"	f
priv_conns	./include/types/server.h	/^	struct list priv_conns;			\/* private idle connections attached to stream interfaces *\/$/;"	m	struct:server	typeref:struct:server::list
process	./include/types/sample.h	/^	int (*process)(const struct arg *arg_p,$/;"	m	struct:sample_conv
process	./include/types/sample.h	/^	int (*process)(const struct arg *arg_p,$/;"	m	struct:sample_fetch
process	./include/types/task.h	/^	struct task * (*process)(struct task *t);  \/* the function which processes the task *\/$/;"	m	struct:task	typeref:struct:task::process
process_chk	./src/checks.c	/^static struct task *process_chk(struct task *t)$/;"	f	file:
process_chk_conn	./src/checks.c	/^static struct task *process_chk_conn(struct task *t)$/;"	f	file:
process_chk_proc	./src/checks.c	/^static struct task *process_chk_proc(struct task *t)$/;"	f	file:
process_email_alert	./src/checks.c	/^static struct task *process_email_alert(struct task *t)$/;"	f	file:
process_peer_sync	./src/peers.c	/^static struct task *process_peer_sync(struct task * task)$/;"	f	file:
process_request	./examples/check	/^sub process_request$/;"	s
process_runnable_tasks	./src/task.c	/^void process_runnable_tasks()$/;"	f
process_server_rules	./src/stream.c	/^static int process_server_rules(struct stream *s, struct channel *req, int an_bit)$/;"	f	file:
process_srv_queue	./src/queue.c	/^void process_srv_queue(struct server *s)$/;"	f
process_sticking_rules	./src/stream.c	/^static int process_sticking_rules(struct stream *s, struct channel *req, int an_bit)$/;"	f	file:
process_store_rules	./src/stream.c	/^static int process_store_rules(struct stream *s, struct channel *rep, int an_bit)$/;"	f	file:
process_stream	./src/stream.c	/^struct task *process_stream(struct task *t)$/;"	f
process_switching_rules	./src/stream.c	/^static int process_switching_rules(struct stream *s, struct channel *req, int an_bit)$/;"	f	file:
process_table_expire	./src/stick_table.c	/^static struct task *process_table_expire(struct task *task)$/;"	f	file:
process_use_service	./src/stream.c	/^enum act_return process_use_service(struct act_rule *rule, struct proxy *px,$/;"	f
prod	./include/types/pipe.h	/^	int prod;	\/* FD the producer must write to ; -1 if none *\/$/;"	m	struct:pipe
project	./doc/lua-api/conf.py	/^project = u'haproxy-lua'$/;"	v
propagate_processes	./src/cfgparse.c	/^void propagate_processes(struct proxy *from, struct proxy *to)$/;"	f
property_names	./include/types/global.h	/^		struct list property_names; \/* list of properties to load into the data set. this is taken from 51degrees-property-name-list from config. *\/$/;"	m	struct:global::__anon76	typeref:struct:global::__anon76::list
property_separator	./include/types/global.h	/^		char property_separator;    \/* the separator to use in the response for the values. this is taken from 51degrees-property-separator from config. *\/$/;"	m	struct:global::__anon76
proto	./include/types/listener.h	/^	struct protocol *proto;		\/* protocol this listener belongs to *\/$/;"	m	struct:listener	typeref:struct:listener::protocol
proto	./include/types/mailers.h	/^	struct protocol *proto;		\/* SMTP server address's protocol *\/$/;"	m	struct:mailer	typeref:struct:mailer::protocol
proto	./include/types/peers.h	/^	struct protocol *proto;	       \/* peer address protocol *\/$/;"	m	struct:peer	typeref:struct:peer::protocol
proto_list	./include/types/listener.h	/^	struct list proto_list;         \/* list in the protocol header *\/$/;"	m	struct:listener	typeref:struct:listener::list
proto_tcpv4	./src/proto_tcp.c	/^static struct protocol proto_tcpv4 = {$/;"	v	typeref:struct:protocol	file:
proto_tcpv6	./src/proto_tcp.c	/^static struct protocol proto_tcpv6 = {$/;"	v	typeref:struct:protocol	file:
proto_unix	./src/proto_uxst.c	/^static struct protocol proto_unix = {$/;"	v	typeref:struct:protocol	file:
protocol	./include/types/protocol.h	/^struct protocol {$/;"	s
protocol_bind_all	./src/protocol.c	/^int protocol_bind_all(char *errmsg, int errlen)$/;"	f
protocol_by_family	./include/proto/protocol.h	/^static inline struct protocol *protocol_by_family(int family)$/;"	f
protocol_disable_all	./src/protocol.c	/^int protocol_disable_all(void)$/;"	f
protocol_enable_all	./src/protocol.c	/^int protocol_enable_all(void)$/;"	f
protocol_register	./src/protocol.c	/^void protocol_register(struct protocol *proto)$/;"	f
protocol_unbind_all	./src/protocol.c	/^int protocol_unbind_all(void)$/;"	f
protocol_unregister	./src/protocol.c	/^void protocol_unregister(struct protocol *proto)$/;"	f
protocols	./src/protocol.c	/^static struct list protocols = LIST_HEAD_INIT(protocols);$/;"	v	typeref:struct:list	file:
proxy	./include/types/applet.h	/^			struct proxy *proxy;	\/* table being currently dumped (first if NULL) *\/$/;"	m	struct:appctx::__anon21::__anon25	typeref:struct:appctx::__anon21::__anon25::proxy
proxy	./include/types/proxy.h	/^struct proxy {$/;"	s
proxy	./include/types/server.h	/^	struct proxy *proxy;			\/* the proxy this server belongs to *\/$/;"	m	struct:server	typeref:struct:server::proxy
proxy	./src/proxy.c	/^struct proxy *proxy  = NULL;	\/* list of all existing proxies *\/$/;"	v	typeref:struct:proxy
proxy_be_by_name	./include/proto/proxy.h	/^static inline struct proxy *proxy_be_by_name(const char *name)$/;"	f
proxy_by_name	./src/proxy.c	/^struct eb_root proxy_by_name = EB_ROOT; \/* tree of proxies sorted by name *\/$/;"	v	typeref:struct:eb_root
proxy_cap_str	./src/proxy.c	/^const char *proxy_cap_str(int cap)$/;"	f
proxy_cfg_ensure_no_http	./src/proxy.c	/^int proxy_cfg_ensure_no_http(struct proxy *curproxy)$/;"	f
proxy_fe_by_name	./include/proto/proxy.h	/^static inline struct proxy *proxy_fe_by_name(const char *name)$/;"	f
proxy_find_best_match	./src/proxy.c	/^struct proxy *proxy_find_best_match(int cap, const char *name, int id, int *diff)$/;"	f
proxy_find_by_id	./src/proxy.c	/^struct proxy *proxy_find_by_id(int id, int cap, int table)$/;"	f
proxy_find_by_name	./src/proxy.c	/^struct proxy *proxy_find_by_name(const char *name, int cap, int table)$/;"	f
proxy_hdr_v2	./include/types/connection.h	/^struct proxy_hdr_v2 {$/;"	s
proxy_inc_be_ctr	./include/proto/proxy.h	/^static void inline proxy_inc_be_ctr(struct proxy *be)$/;"	f
proxy_inc_fe_conn_ctr	./include/proto/proxy.h	/^static void inline proxy_inc_fe_conn_ctr(struct listener *l, struct proxy *fe)$/;"	f
proxy_inc_fe_req_ctr	./include/proto/proxy.h	/^static void inline proxy_inc_fe_req_ctr(struct proxy *fe)$/;"	f
proxy_inc_fe_sess_ctr	./include/proto/proxy.h	/^static void inline proxy_inc_fe_sess_ctr(struct listener *l, struct proxy *fe)$/;"	f
proxy_mode_str	./src/proxy.c	/^const char *proxy_mode_str(int mode) {$/;"	f
proxy_netns	./include/types/connection.h	/^	const struct netns_entry *proxy_netns;$/;"	m	struct:connection	typeref:struct:connection::netns_entry
proxy_parse_declare	./src/proxy.c	/^static int proxy_parse_declare(char **args, int section, struct proxy *curpx,$/;"	f	file:
proxy_parse_max_ka_queue	./src/proxy.c	/^static int proxy_parse_max_ka_queue(char **args, int section, struct proxy *proxy,$/;"	f	file:
proxy_parse_rate_limit	./src/proxy.c	/^static int proxy_parse_rate_limit(char **args, int section, struct proxy *proxy,$/;"	f	file:
proxy_parse_timeout	./src/proxy.c	/^static int proxy_parse_timeout(char **args, int section, struct proxy *proxy,$/;"	f	file:
proxy_reset_timeouts	./include/proto/proxy.h	/^static inline void proxy_reset_timeouts(struct proxy *proxy)$/;"	f
proxy_store_name	./src/proxy.c	/^void proxy_store_name(struct proxy *px)$/;"	f
proxy_tbl_by_name	./include/proto/proxy.h	/^static inline struct proxy *proxy_tbl_by_name(const char *name)$/;"	f
proxy_type_str	./include/proto/proxy.h	/^static inline const char *proxy_type_str(struct proxy *proxy)$/;"	f
prune	./include/types/acl.h	/^	void (*prune)(struct pattern_expr *expr);$/;"	m	struct:acl_keyword
prune	./include/types/pattern.h	/^	void (*prune)(struct pattern_expr *);$/;"	m	struct:pattern_head
prune_acl	./src/acl.c	/^struct acl *prune_acl(struct acl *acl) {$/;"	f
prune_acl_cond	./src/acl.c	/^struct acl_cond *prune_acl_cond(struct acl_cond *cond)$/;"	f
prune_acl_expr	./src/acl.c	/^static struct acl_expr *prune_acl_expr(struct acl_expr *expr)$/;"	f	file:
prx	./include/types/arg.h	/^	struct proxy *prx; \/* used for fe, be, tables *\/$/;"	m	union:arg_data	typeref:struct:arg_data::proxy
prx_queue_size	./include/types/stream.h	/^	unsigned long prx_queue_size;   \/* overall number of streams waiting for a connect slot on this instance at accept() time *\/$/;"	m	struct:strm_logs
ptr	./include/common/epoll.h	/^		void *ptr;$/;"	m	union:epoll_event::__anon2
ptr	./include/types/applet.h	/^			int ptr;		\/* <0: headers, >=0 : text pointer to restart from *\/$/;"	m	struct:appctx::__anon21::__anon24
ptr	./include/types/applet.h	/^			struct dns_resolvers *ptr;$/;"	m	struct:appctx::__anon21::__anon33	typeref:struct:appctx::__anon21::__anon33::dns_resolvers
ptr	./include/types/applet.h	/^			void *ptr;              \/* multi-purpose pointer for peers *\/$/;"	m	struct:appctx::__anon21::__anon27
ptr	./include/types/pattern.h	/^		void *ptr;              \/* any data *\/$/;"	m	union:pattern::__anon91
ptr	./include/types/pattern.h	/^	} ptr;                          \/* indirect values, allocated *\/$/;"	m	struct:pattern	typeref:union:pattern::__anon91
ptr	./include/types/proxy.h	/^		struct server *ptr;		\/* target server *\/$/;"	m	union:server_rule::__anon113	typeref:struct:server_rule::__anon113::server
ptr_t	./ebtree/ebpttree.h	/^typedef PTR_INT_TYPE ptr_t;$/;"	t
puid	./include/types/server.h	/^	int puid;				\/* proxy-unique server ID, used for SNMP, and "first" LB algo *\/$/;"	m	struct:server
purge_me	./include/types/hlua.h	/^	struct list purge_me; \/* Part of the list of signals to be purged in the$/;"	m	struct:hlua_com	typeref:struct:hlua_com::list
put	./include/types/port_range.h	/^	int size, get, put;		\/* range size, and get\/put positions *\/$/;"	m	struct:port_range
put_pipe	./src/pipe.c	/^void put_pipe(struct pipe *p)$/;"	f
put_srv	./tests/filltab25.c	/^void put_srv(struct srv *s) {$/;"	f
px	./include/types/applet.h	/^			struct proxy *px;	\/* current proxy being dumped, NULL = not started yet. *\/$/;"	m	struct:appctx::__anon21::__anon24	typeref:struct:appctx::__anon21::__anon24::proxy
px	./include/types/applet.h	/^			struct proxy *px;$/;"	m	struct:appctx::__anon21::__anon22	typeref:struct:appctx::__anon21::__anon22::proxy
px	./include/types/sample.h	/^	struct proxy *px;$/;"	m	struct:sample	typeref:struct:sample::proxy
px_id	./include/common/uri_auth.h	/^	char *px_id;			\/* proxy id *\/$/;"	m	struct:uri_scope
px_len	./include/common/uri_auth.h	/^	int px_len;			\/* proxy name length *\/$/;"	m	struct:uri_scope
px_st	./include/types/applet.h	/^			int px_st;		\/* STAT_PX_ST* *\/$/;"	m	struct:appctx::__anon21::__anon22
pxcounters	./include/types/counters.h	/^struct pxcounters {$/;"	s
pygments_style	./doc/lua-api/conf.py	/^pygments_style = 'sphinx'$/;"	v
q_time	./include/types/counters.h	/^	unsigned int q_time, c_time, d_time, t_time; \/* sums of conn_time, queue_time, data_time, total_time *\/$/;"	m	struct:pxcounters
q_time	./include/types/counters.h	/^	unsigned int q_time, c_time, d_time, t_time; \/* sums of conn_time, queue_time, data_time, total_time *\/$/;"	m	struct:srvcounters
qclass	./include/types/dns.h	/^	unsigned short	qclass;		\/* query class *\/$/;"	m	struct:dns_question
qdcount	./include/types/dns.h	/^	unsigned short	qdcount :16;	\/* question count *\/$/;"	m	struct:dns_header
qfprintf	./src/log.c	/^void qfprintf(FILE *out, const char *fmt, ...)$/;"	f
qid	./include/types/dns.h	/^	struct eb32_node qid;		\/* ebtree query id *\/$/;"	m	struct:dns_resolution	typeref:struct:dns_resolution::eb32_node
qr	./include/types/dns.h	/^	unsigned char	qr :1;		\/* query\/response 0: query, 1: response *\/$/;"	m	struct:dns_header
qstr	./src/standard.c	/^const char *qstr(const char *str)$/;"	f
qtype	./include/types/dns.h	/^	unsigned short	qtype;		\/* question type *\/$/;"	m	struct:dns_question
quantify	./contrib/halog/halog.c	/^static inline int quantify(int i, int bits)$/;"	f	file:
quantify_u32	./contrib/halog/halog.c	/^static inline unsigned int quantify_u32(unsigned int i, int bits)$/;"	f	file:
query_id	./include/types/dns.h	/^	int query_id;			\/* DNS query ID dedicated for this resolution *\/$/;"	m	struct:dns_resolution
query_ids	./include/types/dns.h	/^	struct eb_root query_ids;	\/* tree to quickly lookup\/retrieve query ids currently in use *\/$/;"	m	struct:dns_resolvers	typeref:struct:dns_resolvers::eb_root
query_type	./include/types/dns.h	/^	int query_type;$/;"	m	struct:dns_resolution
queue	./include/types/proxy.h	/^		int queue;                      \/* queue timeout, defaults to connect if unspecified *\/$/;"	m	struct:proxy::__anon108
queue_by_weight	./tests/filltab25.c	/^void queue_by_weight(struct eb_root *root, struct srv *s) {$/;"	f
queue_by_weight_0	./tests/filltab25.c	/^void queue_by_weight_0(struct eb_root *root, struct srv *s) {$/;"	f
queued	./include/types/compression.h	/^	struct buffer *queued;  \/* if not NULL, data already queued *\/$/;"	m	struct:comp_ctx	typeref:struct:comp_ctx::buffer
queues	./include/types/proxy.h	/^		struct email_alertq *queues;	\/* per-mailer alerts queues *\/$/;"	m	struct:proxy::__anon110	typeref:struct:proxy::__anon110::email_alertq
quote_arg	./src/standard.c	/^const char *quote_arg(const char *ptr)$/;"	f
quoted_idx	./src/standard.c	/^int quoted_idx = 0;$/;"	v
quoted_str	./src/standard.c	/^char quoted_str[NB_QSTR][QSTR_SIZE + 1];$/;"	v
r	./include/types/proto_http.h	/^			int r, r_l;            \/* REASON, length *\/$/;"	m	struct:http_msg::__anon99::__anon101
r_l	./include/types/proto_http.h	/^			int r, r_l;            \/* REASON, length *\/$/;"	m	struct:http_msg::__anon99::__anon101
ra	./include/types/dns.h	/^	unsigned char	ra :1;		\/* recursion available 0: no, 1: yes *\/$/;"	m	struct:dns_header
range	./include/types/pattern.h	/^		} range; \/* integer range *\/$/;"	m	union:pattern::__anon87	typeref:struct:pattern::__anon87::__anon88
raw_def_init	./src/compression.c	/^static int raw_def_init(struct comp_ctx **comp_ctx, int level)$/;"	f	file:
raw_sock	./src/raw_sock.c	/^struct xprt_ops raw_sock = {$/;"	v	typeref:struct:xprt_ops
raw_sock_from_buf	./src/raw_sock.c	/^static int raw_sock_from_buf(struct connection *conn, struct buffer *buf, int flags)$/;"	f	file:
raw_sock_from_pipe	./src/raw_sock.c	/^int raw_sock_from_pipe(struct connection *conn, struct pipe *pipe)$/;"	f
raw_sock_to_buf	./src/raw_sock.c	/^static int raw_sock_to_buf(struct connection *conn, struct buffer *buf, int count)$/;"	f	file:
raw_sock_to_pipe	./src/raw_sock.c	/^int raw_sock_to_pipe(struct connection *conn, struct pipe *pipe, unsigned int count)$/;"	f
rb_color	./include/common/rbtree.h	/^	int rb_color;$/;"	m	struct:rb_node
rb_entry	./include/common/rbtree.h	/^#define	rb_entry(/;"	d
rb_erase	./src/rbtree.c	/^void rb_erase(struct rb_node *node, struct rb_root *root)$/;"	f
rb_first	./src/rbtree.c	/^struct rb_node *rb_first(struct rb_root *root)$/;"	f
rb_insert_color	./src/rbtree.c	/^void rb_insert_color(struct rb_node *node, struct rb_root *root)$/;"	f
rb_last	./src/rbtree.c	/^struct rb_node *rb_last(struct rb_root *root)$/;"	f
rb_left	./include/common/rbtree.h	/^	struct rb_node *rb_left;$/;"	m	struct:rb_node	typeref:struct:rb_node::rb_node
rb_link_node	./include/common/rbtree.h	/^static inline void rb_link_node(struct rb_node * node, struct rb_node * parent,$/;"	f
rb_next	./src/rbtree.c	/^struct rb_node *rb_next(struct rb_node *node)$/;"	f
rb_node	./include/common/rbtree.h	/^	struct rb_node *rb_node;$/;"	m	struct:rb_root	typeref:struct:rb_root::rb_node
rb_node	./include/common/rbtree.h	/^struct rb_node$/;"	s
rb_parent	./include/common/rbtree.h	/^	struct rb_node *rb_parent;$/;"	m	struct:rb_node	typeref:struct:rb_node::rb_node
rb_prev	./src/rbtree.c	/^struct rb_node *rb_prev(struct rb_node *node)$/;"	f
rb_replace_node	./src/rbtree.c	/^void rb_replace_node(struct rb_node *victim, struct rb_node *new,$/;"	f
rb_right	./include/common/rbtree.h	/^	struct rb_node *rb_right;$/;"	m	struct:rb_node	typeref:struct:rb_node::rb_node
rb_root	./include/common/rbtree.h	/^struct rb_root$/;"	s
rcode	./include/types/dns.h	/^	unsigned char	rcode :4;	\/* response code *\/$/;"	m	struct:dns_header
rcv_buf	./include/types/connection.h	/^	int  (*rcv_buf)(struct connection *conn, struct buffer *buf, int count); \/* recv callback *\/$/;"	m	struct:xprt_ops
rcv_pipe	./include/types/connection.h	/^	int  (*rcv_pipe)(struct connection *conn, struct pipe *pipe, unsigned int count); \/* recv-to-pipe callback *\/$/;"	m	struct:xprt_ops
rd	./include/types/dns.h	/^	unsigned char	rd :1;		\/* recursion desired 0: no, 1: yes *\/$/;"	m	struct:dns_header
rdp_cookie_len	./include/types/proxy.h	/^	int  rdp_cookie_len;			\/* strlen(rdp_cookie_name), computed only once *\/$/;"	m	struct:proxy
rdp_cookie_name	./include/types/proxy.h	/^	char *rdp_cookie_name;			\/* name of the RDP cookie to look for *\/$/;"	m	struct:proxy
rdr_fmt	./include/types/proxy.h	/^	struct list rdr_fmt;$/;"	m	struct:redirect_rule	typeref:struct:redirect_rule::list
rdr_len	./include/types/proxy.h	/^	int rdr_len;$/;"	m	struct:redirect_rule
rdr_len	./include/types/server.h	/^	int rdr_len;				\/* the length of the redirection prefix *\/$/;"	m	struct:server
rdr_pfx	./include/types/server.h	/^	char *rdr_pfx;				\/* the redirection prefix *\/$/;"	m	struct:server
rdr_str	./include/types/proxy.h	/^	char *rdr_str;$/;"	m	struct:redirect_rule
rdtsc	./include/common/standard.h	/^static inline unsigned long long rdtsc()$/;"	f
rdtsc	./src/trace.c	/^static inline unsigned long long rdtsc()$/;"	f	file:
re	./include/types/action.h	/^			struct my_regex re;    \/* used by replace-header and replace-value *\/$/;"	m	struct:act_rule::__anon9::__anon11	typeref:struct:act_rule::__anon9::__anon11::my_regex
read_freq_ctr	./src/freq_ctr.c	/^unsigned int read_freq_ctr(struct freq_ctr *ctr)$/;"	f
read_freq_ctr_period	./src/freq_ctr.c	/^unsigned int read_freq_ctr_period(struct freq_ctr_period *ctr, unsigned int period)$/;"	f
read_int64	./src/standard.c	/^long long int read_int64(const char **s, const char *end)$/;"	f
read_pids	./src/haproxy-systemd-wrapper.c	/^static int read_pids(char ***pid_strv)$/;"	f	file:
read_uint	./src/standard.c	/^unsigned int read_uint(const char **s, const char *end)$/;"	f
read_uint64	./src/standard.c	/^unsigned long long int read_uint64(const char **s, const char *end)$/;"	f
readcfgfile	./src/cfgparse.c	/^int readcfgfile(const char *file)$/;"	f
realm	./include/types/action.h	/^			char *realm;$/;"	m	struct:act_rule::__anon9::__anon10
recalc_server_map	./src/lb_map.c	/^void recalc_server_map(struct proxy *px)$/;"	f
reconnect	./include/types/peers.h	/^	unsigned int reconnect;	      \/* next connect timer *\/$/;"	m	struct:peer
recount_servers	./src/backend.c	/^void recount_servers(struct proxy *px)$/;"	f
recv	./include/types/connection.h	/^	void (*recv)(struct connection *conn);  \/* data-layer recv callback *\/$/;"	m	struct:data_cb
recv	./include/types/proto_udp.h	/^	void (*recv)(struct dgram_conn *dgram); \/* recv callback *\/$/;"	m	struct:dgram_data_cb
recv_enough	./include/types/global.h	/^		int recv_enough;   \/* how many input bytes at once are "enough" *\/$/;"	m	struct:global::__anon72
redir	./include/types/action.h	/^		struct redirect_rule *redir;   \/* redirect rule or "http-request redirect" *\/$/;"	m	union:act_rule::__anon9	typeref:struct:act_rule::__anon9::redirect_rule
redirect_rule	./include/types/proxy.h	/^struct redirect_rule {$/;"	s
redirect_rules	./include/types/proxy.h	/^	struct list redirect_rules;             \/* content redirecting rules (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
redispatch_after	./include/types/proxy.h	/^	int redispatch_after;			\/* number of retries before redispatch *\/$/;"	m	struct:proxy
redispatches	./include/types/counters.h	/^	long long redispatches;                 \/* retried and redispatched connections (BE only) *\/$/;"	m	struct:pxcounters
redispatches	./include/types/counters.h	/^	long long retries, redispatches;	\/* retried and redispatched connections *\/$/;"	m	struct:srvcounters
ref	./include/common/mini-clist.h	/^	struct list *ref; \/* pointer to the target's list entry *\/$/;"	m	struct:bref	typeref:struct:bref::list
ref	./include/types/action.h	/^			char *ref;             \/* MAP or ACL file name to update *\/$/;"	m	struct:act_rule::__anon9::__anon12
ref	./include/types/applet.h	/^			struct pat_ref *ref;$/;"	m	struct:appctx::__anon21::__anon28	typeref:struct:appctx::__anon21::__anon28::pat_ref
ref	./include/types/applet.h	/^			struct tls_keys_ref *ref;$/;"	m	struct:appctx::__anon21::__anon29	typeref:struct:appctx::__anon21::__anon29::tls_keys_ref
ref	./include/types/pattern.h	/^	struct pat_ref *ref; \/* The pattern reference if exists. *\/$/;"	m	struct:pattern_expr	typeref:struct:pattern_expr::pat_ref
ref	./include/types/pattern.h	/^	struct pat_ref_elt *ref;$/;"	m	struct:pattern	typeref:struct:pattern::pat_ref_elt
ref	./include/types/pattern.h	/^	struct pat_ref_elt *ref;$/;"	m	struct:pattern_tree	typeref:struct:pattern_tree::pat_ref_elt
ref_cnt	./include/types/stick_table.h	/^	unsigned int ref_cnt;     \/* reference count, can only purge when zero *\/$/;"	m	struct:stksess
reference	./include/types/pattern.h	/^	char *reference; \/* The reference name. *\/$/;"	m	struct:pat_ref
refresh	./include/common/uri_auth.h	/^	int refresh;			\/* refresh interval for the browser (in seconds) *\/$/;"	m	struct:uri_auth
refused	./include/types/dns.h	/^		long int refused;	\/* - queries refused *\/$/;"	m	struct:dns_nameserver::__anon65
reg	./include/common/regex.h	/^	pcre *reg;$/;"	m	struct:my_regex
reg	./include/types/arg.h	/^	struct my_regex *reg;$/;"	m	union:arg_data	typeref:struct:arg_data::my_regex
reg	./include/types/pattern.h	/^		struct my_regex *reg;   \/* a compiled regex *\/$/;"	m	union:pattern::__anon91	typeref:struct:pattern::__anon91::my_regex
regex	./examples/check	/^sub regex$/;"	s
regex_comp	./src/regex.c	/^int regex_comp(const char *str, struct my_regex *regex, int cs, int cap, char **err)$/;"	f
regex_exec	./include/common/regex.h	/^static inline int regex_exec(const struct my_regex *preg, char *subject) {$/;"	f
regex_exec2	./include/common/regex.h	/^static inline int regex_exec2(const struct my_regex *preg, char *subject, int length) {$/;"	f
regex_exec_match	./src/regex.c	/^int regex_exec_match(const struct my_regex *preg, const char *subject,$/;"	f
regex_exec_match2	./src/regex.c	/^int regex_exec_match2(const struct my_regex *preg, char *subject, int length,$/;"	f
regex_free	./include/common/regex.h	/^static inline void regex_free(struct my_regex *preg) {$/;"	f
register_name	./src/vars.c	/^static char *register_name(const char *name, int len, enum vars_scope *scope, char **err)$/;"	f	file:
relative_pid	./src/haproxy.c	/^int  relative_pid = 1;		\/* process id starting at 1 *\/$/;"	v
relax	./src/shctx.c	/^static inline void relax()$/;"	f	file:
release	./doc/lua-api/conf.py	/^release = '1.0'$/;"	v
release	./include/types/applet.h	/^	void (*release)(struct appctx *);  \/* callback to release resources, may be NULL *\/$/;"	m	struct:applet
rem	./tests/filltab25.c	/^	int rem;$/;"	m	struct:srv	file:
remote	./include/types/peers.h	/^	struct peer *remote;		 \/* remote peers list *\/$/;"	m	struct:peers	typeref:struct:peers::peer
remote_data	./include/types/peers.h	/^	uint64_t remote_data;$/;"	m	struct:shared_table
remote_id	./include/types/peers.h	/^	int remote_id;$/;"	m	struct:shared_table
remote_table	./include/types/peers.h	/^	struct shared_table *remote_table;$/;"	m	struct:peer	typeref:struct:peer::shared_table
replace	./include/common/regex.h	/^    const char *replace;		\/* expression to set instead *\/$/;"	m	struct:hdr_exp
replace_by	./src/log.c	/^	const char *replace_by; \/* new option to use instead of old one *\/$/;"	m	struct:logformat_type	file:
req	./include/types/proto_http.h	/^	struct http_msg req;            \/* HTTP request message *\/$/;"	m	struct:http_txn	typeref:struct:http_txn::http_msg
req	./include/types/stream.h	/^	struct channel req;             \/* request channel *\/$/;"	m	struct:stream	typeref:struct:stream::channel
req_add	./include/types/proxy.h	/^	struct list req_add, rsp_add;           \/* headers to be added *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
req_cap	./include/types/proxy.h	/^	struct cap_hdr *req_cap;		\/* chained list of request headers to be captured *\/$/;"	m	struct:proxy	typeref:struct:proxy::cap_hdr
req_cap	./include/types/stream.h	/^	char **req_cap;                         \/* array of captures from the request (may be NULL) *\/$/;"	m	struct:stream
req_cap_pool	./include/types/proxy.h	/^	struct pool_head *req_cap_pool,		\/* pools of pre-allocated char ** used to build the streams *\/$/;"	m	struct:proxy	typeref:struct:proxy::pool_head
req_count	./include/types/global.h	/^	unsigned int req_count; \/* request counter (HTTP or TCP session) for logs and unique_id *\/$/;"	m	struct:global
req_exp	./include/types/proxy.h	/^	struct hdr_exp *req_exp;		\/* regular expressions for request headers *\/$/;"	m	struct:proxy	typeref:struct:proxy::hdr_exp
requester	./include/types/dns.h	/^	void *requester;		\/* owner of this name resolution *\/$/;"	m	struct:dns_resolution
requester_cb	./include/types/dns.h	/^	int (*requester_cb)(struct dns_resolution *, struct dns_nameserver *, unsigned char *, int);$/;"	m	struct:dns_resolution
requester_error_cb	./include/types/dns.h	/^	int (*requester_error_cb)(struct dns_resolution *, int);$/;"	m	struct:dns_resolution
res	./include/types/stream.h	/^	struct channel res;             \/* response channel *\/$/;"	m	struct:stream	typeref:struct:stream::channel
res_cap	./include/types/stream.h	/^	char **res_cap;                         \/* array of captures from the response (may be NULL) *\/$/;"	m	struct:stream
reserved_bufs	./include/types/global.h	/^		int reserved_bufs; \/* how many buffers can only be allocated for response *\/$/;"	m	struct:global::__anon72
resolution	./include/types/server.h	/^	struct dns_resolution *resolution;	\/* server name resolution *\/$/;"	m	struct:server	typeref:struct:server::dns_resolution
resolution	./src/dns.c	/^struct dns_resolution *resolution = NULL;$/;"	v	typeref:struct:dns_resolution
resolve_dgram_cb	./src/dns.c	/^struct dgram_data_cb resolve_dgram_cb = {$/;"	v	typeref:struct:dgram_data_cb
resolve_retries	./include/types/dns.h	/^	int resolve_retries;		\/* number of retries before giving up *\/$/;"	m	struct:dns_resolvers
resolver_family_priority	./include/types/dns.h	/^	int resolver_family_priority;	\/* which IP family should the resolver use when both are returned *\/$/;"	m	struct:dns_resolution
resolver_family_priority	./include/types/server.h	/^	int resolver_family_priority;		\/* which IP family should the resolver use when both are returned *\/$/;"	m	struct:server
resolvers	./include/types/applet.h	/^		} resolvers;$/;"	m	union:appctx::__anon21	typeref:struct:appctx::__anon21::__anon33
resolvers	./include/types/dns.h	/^	struct dns_resolvers *resolvers;	\/* resolvers section associated to this resolution *\/$/;"	m	struct:dns_resolution	typeref:struct:dns_resolution::dns_resolvers
resolvers	./include/types/dns.h	/^	struct dns_resolvers *resolvers;$/;"	m	struct:dns_nameserver	typeref:struct:dns_nameserver::dns_resolvers
resolvers_id	./include/types/server.h	/^	char *resolvers_id;			\/* resolvers section used by this server *\/$/;"	m	struct:server
response	./src/ssl_sock.c	/^	struct chunk response;$/;"	m	struct:certificate_ocsp	typeref:struct:certificate_ocsp::chunk	file:
result	./include/types/checks.h	/^	enum chk_result result;                 \/* health-check result : CHK_RES_* *\/$/;"	m	struct:check	typeref:enum:check::chk_result
result	./include/types/checks.h	/^	short result;			\/* one of SRV_CHK_* *\/$/;"	m	struct:check_status
resume_listener	./src/listener.c	/^int resume_listener(struct listener *l)$/;"	f
resume_proxies	./src/proxy.c	/^void resume_proxies(void)$/;"	f
resume_proxy	./src/proxy.c	/^int resume_proxy(struct proxy *p)$/;"	f
resync_timeout	./include/types/peers.h	/^	unsigned int resync_timeout;	 \/* resync timeout timer *\/$/;"	m	struct:peers
retries	./include/types/counters.h	/^	long long retries, redispatches;	\/* retried and redispatched connections *\/$/;"	m	struct:srvcounters
retries	./include/types/counters.h	/^	long long retries;                      \/* retried and redispatched connections (BE only) *\/$/;"	m	struct:pxcounters
retrieve_errno_from_socket	./src/checks.c	/^static int retrieve_errno_from_socket(struct connection *conn)$/;"	f	file:
retry	./include/types/dns.h	/^		int retry;		\/*   wait for a response before retrying *\/$/;"	m	struct:dns_resolvers::__anon62
reused_sess	./include/types/server.h	/^		SSL_SESSION *reused_sess;$/;"	m	struct:server::__anon122
rev32	./tests/uri_hash.c	/^static unsigned int rev32(unsigned int c) {$/;"	f	file:
revision	./include/import/lru.h	/^	unsigned long long revision;  \/* data revision (to avoid use-after-free) *\/$/;"	m	struct:lru64
revision	./include/types/pattern.h	/^	unsigned long long revision; \/* updated for each update *\/$/;"	m	struct:pattern_expr
rex	./include/types/channel.h	/^	int rex;                        \/* expiration date for a read, in ticks *\/$/;"	m	struct:channel
rfc1950_init	./src/compression.c	/^static int rfc1950_init(struct comp_ctx **comp_ctx, int level)$/;"	f	file:
rfc1951_init	./src/compression.c	/^static int rfc1951_init(struct comp_ctx **comp_ctx, int level)$/;"	f	file:
rfc1952_init	./src/compression.c	/^static int rfc1952_init(struct comp_ctx **comp_ctx, int level)$/;"	f	file:
rfc195x_add_data	./src/compression.c	/^static int rfc195x_add_data(struct comp_ctx *comp_ctx, const char *in_data, int in_len, struct buffer *out)$/;"	f	file:
rfc195x_end	./src/compression.c	/^static int rfc195x_end(struct comp_ctx **comp_ctx)$/;"	f	file:
rfc195x_finish	./src/compression.c	/^static int rfc195x_finish(struct comp_ctx *comp_ctx, struct buffer *out)$/;"	f	file:
rfc195x_flush	./src/compression.c	/^static int rfc195x_flush(struct comp_ctx *comp_ctx, struct buffer *out)$/;"	f	file:
rfc195x_flush_or_finish	./src/compression.c	/^static int rfc195x_flush_or_finish(struct comp_ctx *comp_ctx, struct buffer *out, int finish)$/;"	f	file:
rfc4291_pfx	./src/standard.c	/^const char rfc4291_pfx[] = { 0x00, 0x00, 0x00, 0x00,$/;"	v
rise	./include/types/checks.h	/^	int rise, fall;				\/* time in iterations *\/$/;"	m	struct:check
rlimit_memmax	./include/types/global.h	/^	int rlimit_memmax;	\/* default per-process memory limit in megs ; 0=unset *\/$/;"	m	struct:global
rlimit_memmax_all	./include/types/global.h	/^	int rlimit_memmax_all;	\/* default all-process memory limit in megs ; 0=unset *\/$/;"	m	struct:global
rlimit_nofile	./include/types/global.h	/^	int rlimit_nofile;	\/* default ulimit-n value : 0=unset *\/$/;"	m	struct:global
rot	./tests/test_hashes.c	/^#define rot(/;"	d	file:
rotate_freq_ctr	./include/proto/freq_ctr.h	/^static inline void rotate_freq_ctr(struct freq_ctr *ctr)$/;"	f
rotate_freq_ctr_period	./include/proto/freq_ctr.h	/^static inline void rotate_freq_ctr_period(struct freq_ctr_period *ctr,$/;"	f
round_2dig	./src/standard.c	/^unsigned int round_2dig(unsigned int i)$/;"	f
rps_max	./include/types/counters.h	/^			unsigned int rps_max;   \/* maximum of new HTTP requests second observed *\/$/;"	m	struct:pxcounters::__anon57::__anon58
rq	./include/types/proto_http.h	/^		} rq;                          \/* request line : field, length *\/$/;"	m	union:http_msg::__anon99	typeref:struct:http_msg::__anon99::__anon100
rq	./include/types/task.h	/^	struct eb32_node rq;		\/* ebtree node used to hold the task in the run queue *\/$/;"	m	struct:task	typeref:struct:task::eb32_node
rq_next	./src/task.c	/^struct eb32_node *rq_next    = NULL;  \/* optimization: next task except if delete\/insert *\/$/;"	v	typeref:struct:eb32_node
rqueue	./src/task.c	/^static struct eb_root rqueue;      \/* tree constituting the run queue *\/$/;"	v	typeref:struct:eb_root	file:
rqueue_ticks	./src/task.c	/^static unsigned int rqueue_ticks;  \/* insertion count *\/$/;"	v	file:
rr_idx	./include/types/lb_map.h	/^	int rr_idx;		\/* next server to be elected in round robin mode *\/$/;"	m	struct:lb_map
rsp	./include/types/counters.h	/^			long long rsp[6];	\/* http response codes *\/$/;"	m	struct:srvcounters::__anon59::__anon60
rsp	./include/types/counters.h	/^			long long rsp[6];       \/* http response codes *\/$/;"	m	struct:pxcounters::__anon57::__anon58
rsp	./include/types/proto_http.h	/^	struct http_msg rsp;            \/* HTTP response message *\/$/;"	m	struct:http_txn	typeref:struct:http_txn::http_msg
rsp_add	./include/types/proxy.h	/^	struct list req_add, rsp_add;           \/* headers to be added *\/$/;"	m	struct:proxy	typeref:struct:proxy::
rsp_cap	./include/types/proxy.h	/^	struct cap_hdr *rsp_cap;		\/* chained list of response headers to be captured *\/$/;"	m	struct:proxy	typeref:struct:proxy::cap_hdr
rsp_cap_pool	./include/types/proxy.h	/^	                 *rsp_cap_pool;$/;"	m	struct:proxy	typeref:struct:proxy::
rsp_exp	./include/types/proxy.h	/^	struct hdr_exp *rsp_exp;		\/* regular expressions for response headers *\/$/;"	m	struct:proxy	typeref:struct:proxy::hdr_exp
rto	./include/types/channel.h	/^	int rto;                        \/* read timeout, in ticks *\/$/;"	m	struct:channel
rtrim	./include/common/standard.h	/^static inline char *rtrim(char *s, char c) {$/;"	f
rule	./include/types/applet.h	/^	struct act_rule *rule;     \/* rule associated with the applet. *\/$/;"	m	struct:appctx	typeref:struct:appctx::act_rule
rule_deny_status	./include/types/proto_http.h	/^	short rule_deny_status;         \/* HTTP status from rule when denying *\/$/;"	m	struct:http_txn
rule_result	./include/types/proto_http.h	/^enum rule_result {$/;"	g
run_poll_loop	./src/haproxy.c	/^void run_poll_loop()$/;"	f
run_queue	./src/task.c	/^unsigned int run_queue = 0;$/;"	v
run_queue_cur	./src/task.c	/^unsigned int run_queue_cur = 0;    \/* copy of the run queue size *\/$/;"	v
run_test	./tests/test_hashes.c	/^#define run_test(/;"	d	file:
run_time	./include/types/hlua.h	/^	unsigned int run_time; \/* Lua total execution time in ms. *\/$/;"	m	struct:hlua
runq	./include/types/applet.h	/^	struct list runq;          \/* chaining in the applet run queue *\/$/;"	m	struct:appctx	typeref:struct:appctx::list
rweight	./include/types/server.h	/^	unsigned rweight;			\/* remainer of weight in the current LB tree *\/$/;"	m	struct:server
s	./include/common/mini-clist.h	/^	char *s;$/;"	m	struct:cond_wordlist
s	./include/common/mini-clist.h	/^	char *s;$/;"	m	struct:wordlist
s	./include/types/hlua.h	/^	struct stream *s; \/* Stream used for socket I\/O. *\/$/;"	m	struct:hlua_socket	typeref:struct:hlua_socket::stream
s	./include/types/hlua.h	/^	struct stream *s;$/;"	m	struct:hlua_smp	typeref:struct:hlua_smp::stream
s	./include/types/hlua.h	/^	struct stream *s;$/;"	m	struct:hlua_txn	typeref:struct:hlua_txn::stream
s30tob64	./src/base64.c	/^const char *s30tob64(int in, char *out)$/;"	f
s32	./ebtree/eb32tree.h	/^typedef   signed int s32;$/;"	t
s64	./ebtree/eb64tree.h	/^typedef   signed long long s64;$/;"	t
s_flags	./include/types/proxy.h	/^	unsigned int s_flags;		\/* stream flags *\/$/;"	m	struct:error_snapshot
safe_conns	./include/types/server.h	/^	struct list safe_conns;			\/* safe idle connections attached to stream interfaces, shared *\/$/;"	m	struct:server	typeref:struct:server::list
safe_ljmp_env	./src/hlua.c	/^jmp_buf safe_ljmp_env;$/;"	v
samp_time	./src/time.c	/^unsigned int   samp_time;       \/* total elapsed time over current sample *\/$/;"	v
sample	./include/types/pattern.h	/^	char *sample;$/;"	m	struct:pat_ref_elt
sample	./include/types/sample.h	/^struct sample {$/;"	s
sample_cast_fct	./include/types/sample.h	/^typedef int (*sample_cast_fct)(struct sample *smp);$/;"	t
sample_casts	./src/sample.c	/^sample_cast_fct sample_casts[SMP_TYPES][SMP_TYPES] = {$/;"	v
sample_ckp_names	./src/sample.c	/^const char *sample_ckp_names(unsigned int use)$/;"	f
sample_conv	./include/types/sample.h	/^struct sample_conv {$/;"	s
sample_conv_arith_add	./src/sample.c	/^static int sample_conv_arith_add(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_arith_bool	./src/sample.c	/^static int sample_conv_arith_bool(const struct arg *arg_p,$/;"	f	file:
sample_conv_arith_div	./src/sample.c	/^static int sample_conv_arith_div(const struct arg *arg_p,$/;"	f	file:
sample_conv_arith_even	./src/sample.c	/^static int sample_conv_arith_even(const struct arg *arg_p,$/;"	f	file:
sample_conv_arith_mod	./src/sample.c	/^static int sample_conv_arith_mod(const struct arg *arg_p,$/;"	f	file:
sample_conv_arith_mul	./src/sample.c	/^static int sample_conv_arith_mul(const struct arg *arg_p,$/;"	f	file:
sample_conv_arith_neg	./src/sample.c	/^static int sample_conv_arith_neg(const struct arg *arg_p,$/;"	f	file:
sample_conv_arith_not	./src/sample.c	/^static int sample_conv_arith_not(const struct arg *arg_p,$/;"	f	file:
sample_conv_arith_odd	./src/sample.c	/^static int sample_conv_arith_odd(const struct arg *arg_p,$/;"	f	file:
sample_conv_arith_sub	./src/sample.c	/^static int sample_conv_arith_sub(const struct arg *arg_p,$/;"	f	file:
sample_conv_bin2base64	./src/sample.c	/^static int sample_conv_bin2base64(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_bin2hex	./src/sample.c	/^static int sample_conv_bin2hex(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_binary_and	./src/sample.c	/^static int sample_conv_binary_and(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_binary_cpl	./src/sample.c	/^static int sample_conv_binary_cpl(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_binary_or	./src/sample.c	/^static int sample_conv_binary_or(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_binary_xor	./src/sample.c	/^static int sample_conv_binary_xor(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_bytes	./src/sample.c	/^static int sample_conv_bytes(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_crc32	./src/sample.c	/^static int sample_conv_crc32(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_debug	./src/sample.c	/^static int sample_conv_debug(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_djb2	./src/sample.c	/^static int sample_conv_djb2(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_expr	./include/types/sample.h	/^struct sample_conv_expr {$/;"	s
sample_conv_field	./src/sample.c	/^static int sample_conv_field(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_field_check	./src/sample.c	/^static int sample_conv_field_check(struct arg *args, struct sample_conv *conv,$/;"	f	file:
sample_conv_getnext	./src/sample.c	/^struct sample_conv *sample_conv_getnext(struct sample_conv *current, int *idx)$/;"	f
sample_conv_http_date	./src/proto_http.c	/^static int sample_conv_http_date(const struct arg *args, struct sample *smp, void *private)$/;"	f	file:
sample_conv_in_table	./src/stick_table.c	/^static int sample_conv_in_table(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_ipmask	./src/sample.c	/^static int sample_conv_ipmask(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_json	./src/sample.c	/^static int sample_conv_json(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_json_check	./src/sample.c	/^static int sample_conv_json_check(struct arg *arg, struct sample_conv *conv,$/;"	f	file:
sample_conv_kw_list	./include/types/sample.h	/^struct sample_conv_kw_list {$/;"	s
sample_conv_kws	./src/map.c	/^static struct sample_conv_kw_list sample_conv_kws = {ILH, {$/;"	v	typeref:struct:sample_conv_kw_list	file:
sample_conv_kws	./src/proto_http.c	/^static struct sample_conv_kw_list sample_conv_kws = {ILH, {$/;"	v	typeref:struct:sample_conv_kw_list	file:
sample_conv_kws	./src/sample.c	/^static struct sample_conv_kw_list sample_conv_kws = {ILH, {$/;"	v	typeref:struct:sample_conv_kw_list	file:
sample_conv_kws	./src/stick_table.c	/^static struct sample_conv_kw_list sample_conv_kws = {ILH, {$/;"	v	typeref:struct:sample_conv_kw_list	file:
sample_conv_kws	./src/vars.c	/^static struct sample_conv_kw_list sample_conv_kws = {ILH, {$/;"	v	typeref:struct:sample_conv_kw_list	file:
sample_conv_ltime	./src/sample.c	/^static int sample_conv_ltime(const struct arg *args, struct sample *smp, void *private)$/;"	f	file:
sample_conv_map	./src/map.c	/^static int sample_conv_map(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_q_prefered	./src/proto_http.c	/^static int sample_conv_q_prefered(const struct arg *args, struct sample *smp, void *private)$/;"	f	file:
sample_conv_regsub	./src/sample.c	/^static int sample_conv_regsub(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_regsub_check	./src/sample.c	/^static int sample_conv_regsub_check(struct arg *args, struct sample_conv *conv,$/;"	f	file:
sample_conv_sdbm	./src/sample.c	/^static int sample_conv_sdbm(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_str2lower	./src/sample.c	/^static int sample_conv_str2lower(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_str2upper	./src/sample.c	/^static int sample_conv_str2upper(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_table_bytes_in_rate	./src/stick_table.c	/^static int sample_conv_table_bytes_in_rate(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_table_bytes_out_rate	./src/stick_table.c	/^static int sample_conv_table_bytes_out_rate(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_table_conn_cnt	./src/stick_table.c	/^static int sample_conv_table_conn_cnt(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_table_conn_cur	./src/stick_table.c	/^static int sample_conv_table_conn_cur(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_table_conn_rate	./src/stick_table.c	/^static int sample_conv_table_conn_rate(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_table_gpc0	./src/stick_table.c	/^static int sample_conv_table_gpc0(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_table_gpc0_rate	./src/stick_table.c	/^static int sample_conv_table_gpc0_rate(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_table_gpt0	./src/stick_table.c	/^static int sample_conv_table_gpt0(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_table_http_err_cnt	./src/stick_table.c	/^static int sample_conv_table_http_err_cnt(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_table_http_err_rate	./src/stick_table.c	/^static int sample_conv_table_http_err_rate(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_table_http_req_cnt	./src/stick_table.c	/^static int sample_conv_table_http_req_cnt(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_table_http_req_rate	./src/stick_table.c	/^static int sample_conv_table_http_req_rate(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_table_kbytes_in	./src/stick_table.c	/^static int sample_conv_table_kbytes_in(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_table_kbytes_out	./src/stick_table.c	/^static int sample_conv_table_kbytes_out(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_table_server_id	./src/stick_table.c	/^static int sample_conv_table_server_id(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_table_sess_cnt	./src/stick_table.c	/^static int sample_conv_table_sess_cnt(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_table_sess_rate	./src/stick_table.c	/^static int sample_conv_table_sess_rate(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_table_trackers	./src/stick_table.c	/^static int sample_conv_table_trackers(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_url_dec	./src/proto_http.c	/^static int sample_conv_url_dec(const struct arg *args, struct sample *smp, void *private)$/;"	f	file:
sample_conv_utime	./src/sample.c	/^static int sample_conv_utime(const struct arg *args, struct sample *smp, void *private)$/;"	f	file:
sample_conv_var2smp	./src/sample.c	/^static inline int sample_conv_var2smp(const struct arg *arg, struct stream *strm, struct sample *smp)$/;"	f	file:
sample_conv_word	./src/sample.c	/^static int sample_conv_word(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_conv_wt6	./src/sample.c	/^static int sample_conv_wt6(const struct arg *arg_p, struct sample *smp, void *private)$/;"	f	file:
sample_convert	./include/proto/sample.h	/^int sample_convert(struct sample *sample, int req_type)$/;"	f
sample_convs	./src/sample.c	/^static struct sample_conv_kw_list sample_convs = {$/;"	v	typeref:struct:sample_conv_kw_list	file:
sample_data	./include/types/sample.h	/^struct sample_data {$/;"	s
sample_expr	./include/types/sample.h	/^struct sample_expr {$/;"	s
sample_fetch	./include/types/sample.h	/^struct sample_fetch {$/;"	s
sample_fetch_as_type	./src/sample.c	/^struct sample *sample_fetch_as_type(struct proxy *px, struct session *sess,$/;"	f
sample_fetch_getnext	./src/sample.c	/^struct sample_fetch *sample_fetch_getnext(struct sample_fetch *current, int *idx)$/;"	f
sample_fetch_keywords	./src/51d.c	/^static struct sample_fetch_kw_list sample_fetch_keywords = {ILH, {$/;"	v	typeref:struct:sample_fetch_kw_list	file:
sample_fetch_keywords	./src/compression.c	/^static struct sample_fetch_kw_list sample_fetch_keywords = {ILH, {$/;"	v	typeref:struct:sample_fetch_kw_list	file:
sample_fetch_keywords	./src/proto_http.c	/^static struct sample_fetch_kw_list sample_fetch_keywords = {ILH, {$/;"	v	typeref:struct:sample_fetch_kw_list	file:
sample_fetch_keywords	./src/proto_tcp.c	/^static struct sample_fetch_kw_list sample_fetch_keywords = {ILH, {$/;"	v	typeref:struct:sample_fetch_kw_list	file:
sample_fetch_keywords	./src/ssl_sock.c	/^static struct sample_fetch_kw_list sample_fetch_keywords = {ILH, {$/;"	v	typeref:struct:sample_fetch_kw_list	file:
sample_fetch_keywords	./src/vars.c	/^static struct sample_fetch_kw_list sample_fetch_keywords = {ILH, {$/;"	v	typeref:struct:sample_fetch_kw_list	file:
sample_fetch_kw_list	./include/types/sample.h	/^struct sample_fetch_kw_list {$/;"	s
sample_fetches	./src/sample.c	/^static struct sample_fetch_kw_list sample_fetches = {$/;"	v	typeref:struct:sample_fetch_kw_list	file:
sample_load_map	./src/map.c	/^int sample_load_map(struct arg *arg, struct sample_conv *conv,$/;"	f
sample_parse_expr	./src/sample.c	/^struct sample_expr *sample_parse_expr(char **str, int *idx, const char *file, int line, char **err_msg, struct arg_list *al)$/;"	f
sample_process	./src/sample.c	/^struct sample *sample_process(struct proxy *px, struct session *sess,$/;"	f
sample_register_convs	./src/sample.c	/^void sample_register_convs(struct sample_conv_kw_list *pckl)$/;"	f
sample_register_fetches	./src/sample.c	/^void sample_register_fetches(struct sample_fetch_kw_list *kwl)$/;"	f
sample_src_names	./src/sample.c	/^const char *sample_src_names(unsigned int use)$/;"	f
sample_store	./src/vars.c	/^static int sample_store(struct vars *vars, const char *name, struct stream *strm, struct sample *smp)$/;"	f	file:
sample_store_stream	./src/vars.c	/^static inline int sample_store_stream(const char *name, enum vars_scope scope,$/;"	f	file:
sample_value	./include/types/sample.h	/^union sample_value {$/;"	u
sax_hash	./tests/test_hashes.c	/^unsigned sax_hash ( void *key, int len )$/;"	f
sc	./include/types/action.h	/^			int sc;$/;"	m	struct:act_rule::__anon9::__anon18
sc	./include/types/action.h	/^			int sc;$/;"	m	struct:act_rule::__anon9::__anon19
scheme	./include/common/standard.h	/^	enum http_scheme scheme;$/;"	m	struct:split_url	typeref:enum:split_url::http_scheme
scope	./include/common/uri_auth.h	/^	struct uri_scope *scope;	\/* linked list of authorized proxies *\/$/;"	m	struct:uri_auth	typeref:struct:uri_auth::uri_scope
scope	./include/types/action.h	/^			enum vars_scope scope;$/;"	m	struct:act_rule::__anon9::__anon17	typeref:enum:act_rule::__anon9::__anon17::vars_scope
scope	./include/types/listener.h	/^	const char *scope;$/;"	m	struct:bind_kw_list
scope	./include/types/server.h	/^	const char *scope;$/;"	m	struct:srv_kw_list
scope	./include/types/vars.h	/^	enum vars_scope scope;$/;"	m	struct:var_desc	typeref:enum:var_desc::vars_scope
scope	./include/types/vars.h	/^	enum vars_scope scope;$/;"	m	struct:vars	typeref:enum:vars::vars_scope
scope_len	./include/types/applet.h	/^			int scope_len;		\/* length of the string above in the buffer *\/$/;"	m	struct:appctx::__anon21::__anon22
scope_str	./include/types/applet.h	/^			int scope_str;		\/* limit scope to a frontend\/backend substring *\/$/;"	m	struct:appctx::__anon21::__anon22
sctl_ex_index	./src/ssl_sock.c	/^static int sctl_ex_index = -1;$/;"	v	file:
section	./include/common/cfgparse.h	/^	int section;                            \/* section type for this keyword *\/$/;"	m	struct:cfg_keyword
section	./include/types/applet.h	/^			int section;		\/* section of the session being dumped *\/$/;"	m	struct:appctx::__anon21::__anon23
section_name	./src/cfgparse.c	/^	char *section_name;$/;"	m	struct:cfg_section	file:
section_parser	./src/cfgparse.c	/^	int (*section_parser)(const char *, int, char **, int);$/;"	m	struct:cfg_section	file:
sections	./src/cfgparse.c	/^struct list sections = LIST_HEAD_INIT(sections);$/;"	v	typeref:struct:list
seed	./src/xxhash.c	/^    U32 seed;$/;"	m	struct:__anon148	file:
seed	./src/xxhash.c	/^    U64 seed;$/;"	m	struct:__anon149	file:
select_compression_request_header	./src/proto_http.c	/^int select_compression_request_header(struct stream *s, struct buffer *req)$/;"	f
select_compression_response_header	./src/proto_http.c	/^int select_compression_response_header(struct stream *s, struct buffer *res)$/;"	f
send	./include/types/connection.h	/^	void (*send)(struct connection *conn);  \/* data-layer send callback *\/$/;"	m	struct:data_cb
send	./include/types/proto_udp.h	/^	void (*send)(struct dgram_conn *dgram); \/* send callback *\/$/;"	m	struct:dgram_data_cb
send_email_alert	./src/checks.c	/^void send_email_alert(struct server *s, int level, const char *format, ...)$/;"	f
send_log	./src/log.c	/^void send_log(struct proxy *p, int level, const char *format, ...)$/;"	f
send_proxy	./include/types/checks.h	/^	int send_proxy;				\/* send a PROXY protocol header with checks *\/$/;"	m	struct:check
send_proxy_ofs	./include/types/connection.h	/^	signed short send_proxy_ofs;  \/* <0 = offset to (re)send from the end, >0 = send all *\/$/;"	m	struct:connection
sent	./include/types/dns.h	/^		long int sent;		\/* - queries sent *\/$/;"	m	struct:dns_nameserver::__anon65
sep1	./src/log.c	/^		struct chunk sep1; \/* first pid separator *\/$/;"	m	struct:log_fmt::__anon138	typeref:struct:log_fmt::__anon138::chunk	file:
sep2	./src/log.c	/^		struct chunk sep2; \/* second pid separator *\/$/;"	m	struct:log_fmt::__anon138	typeref:struct:log_fmt::__anon138::chunk	file:
separator	./include/types/global.h	/^		char separator;$/;"	m	struct:global::__anon75
seq	./src/shctx.c	/^	unsigned char seq:7;$/;"	m	struct:shsess_packet_hdr	file:
served	./include/types/server.h	/^	int served;				\/* # of active sessions currently being served (ie not pending) *\/$/;"	m	struct:server
server	./include/types/checks.h	/^	struct server *server;			\/* back-pointer to server *\/$/;"	m	struct:check	typeref:struct:check::server
server	./include/types/proxy.h	/^		int server;                     \/* server I\/O timeout (in ticks) *\/$/;"	m	struct:proxy::__anon108
server	./include/types/server.h	/^	struct server *server;$/;"	m	struct:tree_occ	typeref:struct:tree_occ::server
server	./include/types/server.h	/^struct server {$/;"	s
server_drop_conn	./include/types/backend.h	/^	void (*server_drop_conn)(struct server *);       \/* to be called when connection is dropped *\/$/;"	m	struct:lbprm
server_find_best_match	./src/server.c	/^struct server *server_find_best_match(struct proxy *bk, char *name, int id, int *diff)$/;"	f
server_find_by_id	./src/server.c	/^struct server *server_find_by_id(struct proxy *bk, int id)$/;"	f
server_find_by_name	./src/server.c	/^struct server *server_find_by_name(struct proxy *bk, const char *name)$/;"	f
server_has_room	./include/proto/queue.h	/^static inline int server_has_room(const struct server *s) {$/;"	f
server_id	./include/types/stick_table.h	/^	int server_id;$/;"	m	union:stktable_data
server_id_hdr_len	./include/types/proxy.h	/^	int server_id_hdr_len;                      \/* the length of the id (name) header... name *\/$/;"	m	struct:proxy
server_id_hdr_name	./include/types/proxy.h	/^	char *server_id_hdr_name;                   \/* the header to use to send the server id (name) *\/$/;"	m	struct:proxy
server_is_draining	./include/proto/server.h	/^static inline int server_is_draining(const struct server *s)$/;"	f
server_parse_addr_change_request	./src/server.c	/^const char *server_parse_addr_change_request(struct server *sv,$/;"	f
server_parse_weight_change_request	./src/server.c	/^const char *server_parse_weight_change_request(struct server *sv,$/;"	f
server_rcvbuf	./include/types/global.h	/^		int server_rcvbuf; \/* set server rcvbuf to this value if not null *\/$/;"	m	struct:global::__anon72
server_recalc_eweight	./src/server.c	/^void server_recalc_eweight(struct server *sv)$/;"	f
server_rule	./include/types/proxy.h	/^struct server_rule {$/;"	s
server_rules	./include/types/proxy.h	/^	struct list server_rules;               \/* server switching rules (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
server_sndbuf	./include/types/global.h	/^		int server_sndbuf; \/* set server sndbuf to this value if not null *\/$/;"	m	struct:global::__anon72
server_state	./include/types/applet.h	/^		} server_state;$/;"	m	union:appctx::__anon21	typeref:struct:appctx::__anon21::__anon34
server_state_base	./include/types/global.h	/^	char *server_state_base;   \/* path to a directory where server state files can be found *\/$/;"	m	struct:global
server_state_file	./include/types/global.h	/^	char *server_state_file;   \/* path to the file where server states are loaded from *\/$/;"	m	struct:global
server_state_file_name	./include/types/proxy.h	/^	char *server_state_file_name;		\/* used when load_server_state_from_file is set to$/;"	m	struct:proxy
server_take_conn	./include/types/backend.h	/^	void (*server_take_conn)(struct server *);       \/* to be called when connection is assigned *\/$/;"	m	struct:lbprm
server_throttle_rate	./include/proto/server.h	/^static inline unsigned int server_throttle_rate(struct server *sv)$/;"	f
server_warmup	./src/checks.c	/^static struct task *server_warmup(struct task *t)$/;"	f	file:
serverfin	./include/types/proxy.h	/^		int serverfin;                  \/* timeout to apply to server half-closed connections *\/$/;"	m	struct:proxy::__anon108
service_keywords	./src/stream.c	/^static struct list service_keywords = LIST_HEAD_INIT(service_keywords);$/;"	v	typeref:struct:list	file:
service_keywords_register	./src/stream.c	/^void service_keywords_register(struct action_kw_list *kw_list)$/;"	f
sess	./include/types/applet.h	/^		} sess;$/;"	m	union:appctx::__anon21	typeref:struct:appctx::__anon21::__anon23
sess	./include/types/sample.h	/^	struct session *sess;$/;"	m	struct:sample	typeref:struct:sample::session
sess	./include/types/stream.h	/^	struct session *sess;           \/* the session this stream is attached to *\/$/;"	m	struct:stream	typeref:struct:stream::session
sess_change_server	./src/stream.c	/^void sess_change_server(struct stream *sess, struct server *newsrv)$/;"	f
sess_cnt	./include/types/stick_table.h	/^	unsigned int sess_cnt;$/;"	m	union:stktable_data
sess_conn_cb	./src/session.c	/^struct data_cb sess_conn_cb = {$/;"	v	typeref:struct:data_cb
sess_cookie	./src/log.c	/^const char sess_cookie[8]     = "NIDVEOU7";	\/* No cookie, Invalid cookie, cookie for a Down server, Valid cookie, Expired cookie, Old cookie, Unused, unknown *\/$/;"	v
sess_establish	./src/stream.c	/^static void sess_establish(struct stream *s)$/;"	f	file:
sess_fin_state	./src/log.c	/^const char sess_fin_state[8]  = "-RCHDLQT";	\/* cliRequest, srvConnect, srvHeader, Data, Last, Queue, Tarpit *\/$/;"	v
sess_per_sec	./include/types/global.h	/^	struct freq_ctr sess_per_sec;$/;"	m	struct:global	typeref:struct:global::freq_ctr
sess_per_sec	./include/types/server.h	/^	struct freq_ctr sess_per_sec;		\/* sessions per second on this server *\/$/;"	m	struct:server	typeref:struct:server::freq_ctr
sess_prepare_conn_req	./src/stream.c	/^static void sess_prepare_conn_req(struct stream *s)$/;"	f	file:
sess_rate	./include/types/stick_table.h	/^	struct freq_ctr_period sess_rate;$/;"	m	union:stktable_data	typeref:struct:stktable_data::freq_ctr_period
sess_set_cookie	./src/log.c	/^const char sess_set_cookie[8] = "NPDIRU67";	\/* No set-cookie, Set-cookie found and left unchanged (passive),$/;"	v
sess_set_term_flags	./src/stream.c	/^static void sess_set_term_flags(struct stream *s)$/;"	f	file:
sess_term_cond	./src/log.c	/^const char sess_term_cond[16] = "-LcCsSPRIDKUIIII"; \/* normal, Local, CliTo, CliErr, SrvTo, SrvErr, PxErr, Resource, Internal, Down, Killed, Up, -- *\/$/;"	v
sess_update_st_cer	./src/stream.c	/^static int sess_update_st_cer(struct stream *s)$/;"	f	file:
sess_update_st_con_tcp	./src/stream.c	/^static int sess_update_st_con_tcp(struct stream *s)$/;"	f	file:
sess_update_stream_int	./src/stream.c	/^static void sess_update_stream_int(struct stream *s)$/;"	f	file:
session	./include/types/session.h	/^struct session {$/;"	s
session	./src/shctx.c	/^		struct shared_session session;$/;"	m	union:shared_block::__anon144	typeref:struct:shared_block::__anon144::shared_session	file:
session_accept_fd	./src/session.c	/^int session_accept_fd(struct listener *l, int cfd, struct sockaddr_storage *addr)$/;"	f
session_count_new	./src/session.c	/^static void session_count_new(struct session *sess)$/;"	f	file:
session_expire_embryonic	./src/session.c	/^static struct task *session_expire_embryonic(struct task *t)$/;"	f	file:
session_free	./src/session.c	/^void session_free(struct session *sess)$/;"	f
session_kill_embryonic	./src/session.c	/^static void session_kill_embryonic(struct session *sess)$/;"	f	file:
session_new	./src/session.c	/^struct session *session_new(struct proxy *fe, struct listener *li, enum obj_type *origin)$/;"	f
session_prepare_log_prefix	./src/session.c	/^static void session_prepare_log_prefix(struct session *sess)$/;"	f	file:
session_store_counters	./include/proto/session.h	/^static inline void session_store_counters(struct session *sess)$/;"	f
set	./include/types/proxy.h	/^		int set;			\/* True if email_alert settings are present *\/$/;"	m	struct:proxy::__anon110
set_backend_down	./src/backend.c	/^void set_backend_down(struct proxy *be)$/;"	f
set_host_port	./include/common/standard.h	/^static inline int set_host_port(struct sockaddr_storage *addr, int port)$/;"	f
set_net_port	./include/common/standard.h	/^static inline int set_net_port(struct sockaddr_storage *addr, int port)$/;"	f
set_server_check_status	./src/checks.c	/^static void set_server_check_status(struct check *check, short status, const char *desc)$/;"	f	file:
set_server_status_down	./include/types/backend.h	/^	void (*set_server_status_down)(struct server *); \/* to be called after status changes to DOWN *\/$/;"	m	struct:lbprm
set_server_status_up	./include/types/backend.h	/^	void (*set_server_status_up)(struct server *);   \/* to be called after status changes to UP *\/$/;"	m	struct:lbprm
sflags	./include/types/pattern.h	/^	int sflags;                     \/* flags relative to the storage method. *\/$/;"	m	struct:pattern
shared_block	./src/shctx.c	/^struct shared_block {$/;"	s	file:
shared_context	./src/shctx.c	/^struct shared_context {$/;"	s	file:
shared_context_init	./src/shctx.c	/^int shared_context_init(int size, int shared)$/;"	f
shared_context_lock	./src/shctx.c	/^#define shared_context_lock(/;"	d	file:
shared_context_set_cache	./src/shctx.c	/^void shared_context_set_cache(SSL_CTX *ctx)$/;"	f
shared_context_unlock	./src/shctx.c	/^#define shared_context_unlock(/;"	d	file:
shared_session	./src/shctx.c	/^struct shared_session {$/;"	s	file:
shared_table	./include/types/peers.h	/^struct shared_table {$/;"	s
shblock_set_active	./src/shctx.c	/^#define shblock_set_active(/;"	d	file:
shblock_set_free	./src/shctx.c	/^#define shblock_set_free(/;"	d	file:
shblock_unset	./src/shctx.c	/^#define shblock_unset(/;"	d	file:
shctx	./src/shctx.c	/^static struct shared_context *shctx = NULL;$/;"	v	typeref:struct:shared_context	file:
shctx_get_cb	./src/shctx.c	/^SSL_SESSION *shctx_get_cb(SSL *ssl, unsigned char *key, int key_len, int *do_copy)$/;"	f
shctx_lookups	./include/types/global.h	/^	unsigned int shctx_lookups, shctx_misses;$/;"	m	struct:global
shctx_misses	./include/types/global.h	/^	unsigned int shctx_lookups, shctx_misses;$/;"	m	struct:global
shctx_new_cb	./src/shctx.c	/^int shctx_new_cb(SSL *ssl, SSL_SESSION *sess)$/;"	f
shctx_remove_cb	./src/shctx.c	/^void shctx_remove_cb(SSL_CTX *ctx, SSL_SESSION *sess)$/;"	f
shl32	./tests/uri_hash.c	/^static inline u_int32_t shl32(u_int32_t i, int count) {$/;"	f	file:
showList	./examples/stats_haproxy.sh	/^showList ()$/;"	f
shr32	./tests/uri_hash.c	/^static inline u_int32_t shr32(u_int32_t i, int count) {$/;"	f	file:
shsess_free	./src/shctx.c	/^static int shsess_free(struct shared_session *shsess)$/;"	f	file:
shsess_get_next	./src/shctx.c	/^static struct shared_session *shsess_get_next(int data_len)$/;"	f	file:
shsess_packet	./src/shctx.c	/^struct shsess_packet {$/;"	s	file:
shsess_packet_hdr	./src/shctx.c	/^struct shsess_packet_hdr {$/;"	s	file:
shsess_store	./src/shctx.c	/^static int shsess_store(unsigned char *s_id, unsigned char *data, int data_len)$/;"	f	file:
shsess_tree_delete	./src/shctx.c	/^#define shsess_tree_delete(/;"	d	file:
shsess_tree_insert	./src/shctx.c	/^#define shsess_tree_insert(/;"	d	file:
shsess_tree_lookup	./src/shctx.c	/^#define shsess_tree_lookup(/;"	d	file:
shut_your_big_mouth_gcc	./include/common/standard.h	/^static inline void shut_your_big_mouth_gcc(int r)$/;"	f
shut_your_big_mouth_gcc_int	./src/haproxy.c	/^int shut_your_big_mouth_gcc_int = 0;$/;"	v
shutr	./include/types/connection.h	/^	void (*shutr)(struct connection *, int);    \/* shutr function *\/$/;"	m	struct:xprt_ops
shutr	./include/types/stream_interface.h	/^	void (*shutr)(struct stream_interface *);   \/* shut read function *\/$/;"	m	struct:si_ops
shutw	./include/types/connection.h	/^	void (*shutw)(struct connection *, int);    \/* shutw function *\/$/;"	m	struct:xprt_ops
shutw	./include/types/stream_interface.h	/^	void (*shutw)(struct stream_interface *);   \/* shut write function *\/$/;"	m	struct:si_ops
si	./include/types/stream.h	/^	struct stream_interface si[2];          \/* client and server stream interfaces *\/$/;"	m	struct:stream	typeref:struct:stream::stream_interface
si_alloc_appctx	./include/proto/stream_interface.h	/^static inline struct appctx *si_alloc_appctx(struct stream_interface *si, struct applet *applet)$/;"	f
si_alloc_conn	./include/proto/stream_interface.h	/^static inline struct connection *si_alloc_conn(struct stream_interface *si)$/;"	f
si_appctx	./include/proto/stream_interface.h	/^static inline struct appctx *si_appctx(struct stream_interface *si)$/;"	f
si_applet_cant_get	./include/proto/stream_interface.h	/^static inline void si_applet_cant_get(struct stream_interface *si)$/;"	f
si_applet_cant_put	./include/proto/stream_interface.h	/^static inline void si_applet_cant_put(struct stream_interface *si)$/;"	f
si_applet_ops	./src/stream_interface.c	/^struct si_ops si_applet_ops = {$/;"	v	typeref:struct:si_ops
si_applet_release	./include/proto/stream_interface.h	/^static inline void si_applet_release(struct stream_interface *si)$/;"	f
si_applet_stop_get	./include/proto/stream_interface.h	/^static inline void si_applet_stop_get(struct stream_interface *si)$/;"	f
si_applet_stop_put	./include/proto/stream_interface.h	/^static inline void si_applet_stop_put(struct stream_interface *si)$/;"	f
si_applet_wake_cb	./src/stream_interface.c	/^void si_applet_wake_cb(struct stream_interface *si)$/;"	f
si_applet_want_get	./include/proto/stream_interface.h	/^static inline void si_applet_want_get(struct stream_interface *si)$/;"	f
si_applet_want_put	./include/proto/stream_interface.h	/^static inline void si_applet_want_put(struct stream_interface *si)$/;"	f
si_attach_appctx	./include/proto/stream_interface.h	/^static inline void si_attach_appctx(struct stream_interface *si, struct appctx *appctx)$/;"	f
si_attach_conn	./include/proto/stream_interface.h	/^static inline void si_attach_conn(struct stream_interface *si, struct connection *conn)$/;"	f
si_chk_rcv	./include/proto/stream_interface.h	/^static inline void si_chk_rcv(struct stream_interface *si)$/;"	f
si_chk_snd	./include/proto/stream_interface.h	/^static inline void si_chk_snd(struct stream_interface *si)$/;"	f
si_conn_cb	./src/stream_interface.c	/^struct data_cb si_conn_cb = {$/;"	v	typeref:struct:data_cb
si_conn_ops	./src/stream_interface.c	/^struct si_ops si_conn_ops = {$/;"	v	typeref:struct:si_ops
si_conn_ready	./include/proto/stream_interface.h	/^static inline int si_conn_ready(struct stream_interface *si)$/;"	f
si_conn_recv_cb	./src/stream_interface.c	/^static void si_conn_recv_cb(struct connection *conn)$/;"	f	file:
si_conn_send	./src/stream_interface.c	/^static void si_conn_send(struct connection *conn)$/;"	f	file:
si_conn_send_cb	./src/stream_interface.c	/^static void si_conn_send_cb(struct connection *conn)$/;"	f	file:
si_conn_wake_cb	./src/stream_interface.c	/^static int si_conn_wake_cb(struct connection *conn)$/;"	f	file:
si_connect	./include/proto/stream_interface.h	/^static inline int si_connect(struct stream_interface *si)$/;"	f
si_detach_endpoint	./include/proto/stream_interface.h	/^static inline enum obj_type *si_detach_endpoint(struct stream_interface *si)$/;"	f
si_embedded_ops	./src/stream_interface.c	/^struct si_ops si_embedded_ops = {$/;"	v	typeref:struct:si_ops
si_ib	./include/proto/stream_interface.h	/^static inline struct buffer *si_ib(struct stream_interface *si)$/;"	f
si_ic	./include/proto/stream_interface.h	/^static inline struct channel *si_ic(struct stream_interface *si)$/;"	f
si_idle_conn	./include/proto/stream_interface.h	/^static inline void si_idle_conn(struct stream_interface *si, struct list *pool)$/;"	f
si_idle_conn_cb	./src/stream_interface.c	/^struct data_cb si_idle_conn_cb = {$/;"	v	typeref:struct:data_cb
si_idle_conn_null_cb	./src/stream_interface.c	/^static void si_idle_conn_null_cb(struct connection *conn)$/;"	f	file:
si_idle_conn_wake_cb	./src/stream_interface.c	/^static int si_idle_conn_wake_cb(struct connection *conn)$/;"	f	file:
si_ob	./include/proto/stream_interface.h	/^static inline struct buffer *si_ob(struct stream_interface *si)$/;"	f
si_oc	./include/proto/stream_interface.h	/^static inline struct channel *si_oc(struct stream_interface *si)$/;"	f
si_opposite	./include/proto/stream_interface.h	/^static inline struct stream_interface *si_opposite(struct stream_interface *si)$/;"	f
si_ops	./include/types/stream_interface.h	/^struct si_ops {$/;"	s
si_release_endpoint	./include/proto/stream_interface.h	/^static inline void si_release_endpoint(struct stream_interface *si)$/;"	f
si_reset	./include/proto/stream_interface.h	/^static inline void si_reset(struct stream_interface *si)$/;"	f
si_set_state	./include/proto/stream_interface.h	/^static inline void si_set_state(struct stream_interface *si, int state)$/;"	f
si_shutr	./include/proto/stream_interface.h	/^static inline void si_shutr(struct stream_interface *si)$/;"	f
si_shutw	./include/proto/stream_interface.h	/^static inline void si_shutw(struct stream_interface *si)$/;"	f
si_state	./include/types/stream_interface.h	/^enum si_state {$/;"	g
si_state_str	./include/proto/stream_interface.h	/^static inline const char *si_state_str(int state)$/;"	f
si_strm	./include/proto/stream_interface.h	/^static inline struct stream *si_strm(struct stream_interface *si)$/;"	f
si_task	./include/proto/stream_interface.h	/^static inline struct task *si_task(struct stream_interface *si)$/;"	f
si_update	./include/proto/stream_interface.h	/^static inline void si_update(struct stream_interface *si)$/;"	f
sid	./include/types/applet.h	/^			int iid, type, sid;	\/* proxy id, type and service id if bounding of stats is enabled *\/$/;"	m	struct:appctx::__anon21::__anon22
sid	./include/types/applet.h	/^			unsigned int sid;	\/* session ID of error being dumped *\/$/;"	m	struct:appctx::__anon21::__anon24
sid	./include/types/proxy.h	/^	unsigned int sid;		\/* ID of the faulty stream *\/$/;"	m	struct:error_snapshot
sig	./include/types/connection.h	/^	uint8_t sig[12];   \/* hex 0D 0A 0D 0A 00 0D 0A 51 55 49 54 0A *\/$/;"	m	struct:proxy_hdr_v2
sig	./src/shctx.c	/^	unsigned char sig[SHA_DIGEST_LENGTH];$/;"	m	struct:shsess_packet	file:
sig_dump_state	./src/haproxy.c	/^void sig_dump_state(struct sig_handler *sh)$/;"	f
sig_handler	./include/types/signal.h	/^struct sig_handler {$/;"	s
sig_listen	./src/haproxy.c	/^void sig_listen(struct sig_handler *sh)$/;"	f
sig_pause	./src/haproxy.c	/^void sig_pause(struct sig_handler *sh)$/;"	f
sig_soft_stop	./src/haproxy.c	/^void sig_soft_stop(struct sig_handler *sh)$/;"	f
sigchld_handler	./src/checks.c	/^static void sigchld_handler(int signal)$/;"	f	file:
sighandler	./include/types/peers.h	/^	struct sig_handler *sighandler;	 \/* signal handler *\/$/;"	m	struct:peers	typeref:struct:peers::sig_handler
signal_descriptor	./include/types/signal.h	/^struct signal_descriptor {$/;"	s
signal_handler	./src/haproxy-systemd-wrapper.c	/^static void signal_handler(int signum)$/;"	f	file:
signal_handler	./src/signal.c	/^void signal_handler(int sig)$/;"	f
signal_init	./src/signal.c	/^int signal_init()$/;"	f
signal_pending	./src/signal.c	/^int signal_pending = 0; \/* non-zero if t least one signal remains unprocessed *\/$/;"	v
signal_process_queue	./include/proto/signal.h	/^static inline void signal_process_queue()$/;"	f
signal_queue	./src/signal.c	/^int signal_queue[MAX_SIGNAL];                     \/* in-order queue of received signals *\/$/;"	v
signal_queue_len	./src/signal.c	/^int signal_queue_len; \/* length of signal queue, <= MAX_SIGNAL (1 entry per signal max) *\/$/;"	v
signal_register_fct	./src/signal.c	/^struct sig_handler *signal_register_fct(int sig, void (*fct)(struct sig_handler *), int arg)$/;"	f
signal_register_task	./src/signal.c	/^struct sig_handler *signal_register_task(int sig, struct task *task, int reason)$/;"	f
signal_state	./src/signal.c	/^struct signal_descriptor signal_state[MAX_SIGNAL];$/;"	v	typeref:struct:signal_descriptor
signal_unregister_handler	./src/signal.c	/^void signal_unregister_handler(struct sig_handler *handler)$/;"	f
signal_unregister_target	./src/signal.c	/^void signal_unregister_target(int sig, void *target)$/;"	f
sint	./include/types/arg.h	/^	long long int sint;$/;"	m	union:arg_data
sint	./include/types/sample.h	/^	long long int   sint;  \/* used for signed 64bits integers *\/$/;"	m	union:sample_value
size	./include/common/buffer.h	/^	unsigned int size;              \/* buffer size in bytes *\/$/;"	m	struct:buffer
size	./include/common/chunk.h	/^	int size;	\/* total size of the buffer, 0 if the *str is read-only *\/$/;"	m	struct:chunk
size	./include/common/memory.h	/^	unsigned int size;	\/* chunk size *\/$/;"	m	struct:pool_head
size	./include/types/hdr_idx.h	/^	short size;                 \/* size of the array including the head *\/$/;"	m	struct:hdr_idx
size	./include/types/port_range.h	/^	int size, get, put;		\/* range size, and get\/put positions *\/$/;"	m	struct:port_range
size	./include/types/stick_table.h	/^	unsigned int size;        \/* maximum number of sticky sessions in table *\/$/;"	m	struct:stktable
size	./include/types/vars.h	/^	unsigned int size;$/;"	m	struct:vars
sizeof_talloc	./tests/test_pools.c	/^#define sizeof_talloc /;"	d	file:
skip	./include/types/listener.h	/^	int skip; \/* nb of args to skip *\/$/;"	m	struct:bind_kw
skip	./include/types/server.h	/^	int skip; \/* nb min of args to skip, for use when kw is not handled *\/$/;"	m	struct:srv_kw
sl	./include/types/proto_http.h	/^	} sl;                                  \/* start line *\/$/;"	m	struct:http_msg	typeref:union:http_msg::__anon99
slowstart	./include/types/server.h	/^	int slowstart;				\/* slowstart time in seconds (ms in the conf) *\/$/;"	m	struct:server
sltoa_r	./src/standard.c	/^char *sltoa_r(long n, char *buffer, int size)$/;"	f
smp	./include/types/acl.h	/^	struct sample_expr *smp;      \/* the sample expression we depend on *\/$/;"	m	struct:acl_expr	typeref:struct:acl_expr::sample_expr
smp	./include/types/acl.h	/^	struct sample_fetch *smp; \/* the sample fetch we depend on *\/$/;"	m	struct:acl_keyword	typeref:struct:acl_keyword::sample_fetch
smp_check_const_bin	./src/sample.c	/^static int smp_check_const_bin(struct arg *args, char **err)$/;"	f	file:
smp_check_const_bool	./src/sample.c	/^static int smp_check_const_bool(struct arg *args, char **err)$/;"	f	file:
smp_check_const_meth	./src/sample.c	/^static int smp_check_const_meth(struct arg *args, char **err)$/;"	f	file:
smp_check_var	./src/vars.c	/^static int smp_check_var(struct arg *args, char **err)$/;"	f	file:
smp_conv_req_capture	./src/proto_http.c	/^static int smp_conv_req_capture(const struct arg *args, struct sample *smp, void *private)$/;"	f	file:
smp_conv_res_capture	./src/proto_http.c	/^static int smp_conv_res_capture(const struct arg *args, struct sample *smp, void *private)$/;"	f	file:
smp_conv_store	./src/vars.c	/^static int smp_conv_store(const struct arg *args, struct sample *smp, void *private)$/;"	f	file:
smp_create_src_stkctr	./src/stream.c	/^smp_create_src_stkctr(struct session *sess, struct stream *strm, const struct arg *args, const char *kw)$/;"	f
smp_ctx	./include/types/sample.h	/^union smp_ctx {$/;"	u
smp_dup	./src/sample.c	/^int smp_dup(struct sample *smp)$/;"	f
smp_expr_output_type	./src/sample.c	/^int smp_expr_output_type(struct sample_expr *expr)$/;"	f
smp_fetch_avg_queue_size	./src/backend.c	/^smp_fetch_avg_queue_size(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_base	./src/proto_http.c	/^smp_fetch_base(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_base32	./src/proto_http.c	/^smp_fetch_base32(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f
smp_fetch_base32_src	./src/proto_http.c	/^smp_fetch_base32_src(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_be_conn	./src/backend.c	/^smp_fetch_be_conn(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_be_id	./src/backend.c	/^smp_fetch_be_id(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_be_sess_rate	./src/backend.c	/^smp_fetch_be_sess_rate(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_body	./src/proto_http.c	/^smp_fetch_body(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_body_len	./src/proto_http.c	/^smp_fetch_body_len(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_body_param	./src/proto_http.c	/^smp_fetch_body_param(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_body_size	./src/proto_http.c	/^smp_fetch_body_size(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_capture_header_req	./src/proto_http.c	/^smp_fetch_capture_header_req(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_capture_header_res	./src/proto_http.c	/^smp_fetch_capture_header_res(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_capture_req_method	./src/proto_http.c	/^smp_fetch_capture_req_method(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_capture_req_uri	./src/proto_http.c	/^smp_fetch_capture_req_uri(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_capture_req_ver	./src/proto_http.c	/^smp_fetch_capture_req_ver(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_capture_res_ver	./src/proto_http.c	/^smp_fetch_capture_res_ver(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_connslots	./src/backend.c	/^smp_fetch_connslots(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_const_bin	./src/sample.c	/^static int smp_fetch_const_bin(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_const_bool	./src/sample.c	/^static int smp_fetch_const_bool(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_const_int	./src/sample.c	/^static int smp_fetch_const_int(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_const_ipv4	./src/sample.c	/^static int smp_fetch_const_ipv4(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_const_ipv6	./src/sample.c	/^static int smp_fetch_const_ipv6(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_const_meth	./src/sample.c	/^static int smp_fetch_const_meth(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_const_str	./src/sample.c	/^static int smp_fetch_const_str(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_cookie	./src/proto_http.c	/^int smp_fetch_cookie(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f
smp_fetch_cookie_cnt	./src/proto_http.c	/^smp_fetch_cookie_cnt(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_cookie_val	./src/proto_http.c	/^smp_fetch_cookie_val(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_date	./src/sample.c	/^smp_fetch_date(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_dconn	./src/listener.c	/^smp_fetch_dconn(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_dport	./src/proto_tcp.c	/^smp_fetch_dport(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_dst	./src/proto_tcp.c	/^smp_fetch_dst(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_env	./src/sample.c	/^smp_fetch_env(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_false	./src/sample.c	/^smp_fetch_false(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_fe_conn	./src/frontend.c	/^smp_fetch_fe_conn(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_fe_id	./src/frontend.c	/^smp_fetch_fe_id(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_fe_sess_rate	./src/frontend.c	/^smp_fetch_fe_sess_rate(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_fhdr	./src/proto_http.c	/^smp_fetch_fhdr(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_fhdr_cnt	./src/proto_http.c	/^smp_fetch_fhdr_cnt(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_hdr	./src/proto_http.c	/^smp_fetch_hdr(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_hdr_cnt	./src/proto_http.c	/^smp_fetch_hdr_cnt(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_hdr_ip	./src/proto_http.c	/^smp_fetch_hdr_ip(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_hdr_names	./src/proto_http.c	/^smp_fetch_hdr_names(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_hdr_val	./src/proto_http.c	/^smp_fetch_hdr_val(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_http_auth	./src/proto_http.c	/^smp_fetch_http_auth(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_http_auth_grp	./src/proto_http.c	/^smp_fetch_http_auth_grp(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_http_first_req	./src/proto_http.c	/^smp_fetch_http_first_req(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_keywords	./src/stream.c	/^static struct sample_fetch_kw_list smp_fetch_keywords = {ILH, {$/;"	v	typeref:struct:sample_fetch_kw_list	file:
smp_fetch_len	./src/payload.c	/^smp_fetch_len(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_meth	./src/proto_http.c	/^smp_fetch_meth(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_nbproc	./src/sample.c	/^smp_fetch_nbproc(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_nbsrv	./src/backend.c	/^smp_fetch_nbsrv(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_param	./src/proto_http.c	/^smp_fetch_param(char delim, const char *name, int name_len, const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_path	./src/proto_http.c	/^smp_fetch_path(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_payload	./src/payload.c	/^smp_fetch_payload(const struct arg *arg_p, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_payload_lv	./src/payload.c	/^smp_fetch_payload_lv(const struct arg *arg_p, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_proc	./src/sample.c	/^smp_fetch_proc(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_proto_http	./src/proto_http.c	/^smp_fetch_proto_http(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_query	./src/proto_http.c	/^smp_fetch_query(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_queue_size	./src/backend.c	/^smp_fetch_queue_size(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_rand	./src/sample.c	/^smp_fetch_rand(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_rdp_cookie	./src/payload.c	/^smp_fetch_rdp_cookie(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f
smp_fetch_rdp_cookie_cnt	./src/payload.c	/^smp_fetch_rdp_cookie_cnt(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_req_ssl_ec_ext	./src/payload.c	/^smp_fetch_req_ssl_ec_ext(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_req_ssl_st_ext	./src/payload.c	/^smp_fetch_req_ssl_st_ext(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_req_ssl_ver	./src/payload.c	/^smp_fetch_req_ssl_ver(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_res_comp	./src/compression.c	/^smp_fetch_res_comp(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_res_comp_algo	./src/compression.c	/^smp_fetch_res_comp_algo(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_rqver	./src/proto_http.c	/^smp_fetch_rqver(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_sc_bytes_in_rate	./src/stream.c	/^smp_fetch_sc_bytes_in_rate(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_sc_bytes_out_rate	./src/stream.c	/^smp_fetch_sc_bytes_out_rate(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_sc_clr_gpc0	./src/stream.c	/^smp_fetch_sc_clr_gpc0(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_sc_conn_cnt	./src/stream.c	/^smp_fetch_sc_conn_cnt(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_sc_conn_cur	./src/stream.c	/^smp_fetch_sc_conn_cur(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_sc_conn_rate	./src/stream.c	/^smp_fetch_sc_conn_rate(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_sc_get_gpc0	./src/stream.c	/^smp_fetch_sc_get_gpc0(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_sc_get_gpt0	./src/stream.c	/^smp_fetch_sc_get_gpt0(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_sc_gpc0_rate	./src/stream.c	/^smp_fetch_sc_gpc0_rate(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_sc_http_err_cnt	./src/stream.c	/^smp_fetch_sc_http_err_cnt(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_sc_http_err_rate	./src/stream.c	/^smp_fetch_sc_http_err_rate(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_sc_http_req_cnt	./src/stream.c	/^smp_fetch_sc_http_req_cnt(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_sc_http_req_rate	./src/stream.c	/^smp_fetch_sc_http_req_rate(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_sc_inc_gpc0	./src/stream.c	/^smp_fetch_sc_inc_gpc0(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_sc_kbytes_in	./src/stream.c	/^smp_fetch_sc_kbytes_in(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_sc_kbytes_out	./src/stream.c	/^smp_fetch_sc_kbytes_out(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_sc_sess_cnt	./src/stream.c	/^smp_fetch_sc_sess_cnt(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_sc_sess_rate	./src/stream.c	/^smp_fetch_sc_sess_rate(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_sc_stkctr	./src/stream.c	/^smp_fetch_sc_stkctr(struct session *sess, struct stream *strm, const struct arg *args, const char *kw)$/;"	f
smp_fetch_sc_tracked	./src/stream.c	/^smp_fetch_sc_tracked(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_sc_trackers	./src/stream.c	/^smp_fetch_sc_trackers(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_so_id	./src/listener.c	/^smp_fetch_so_id(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_sport	./src/proto_tcp.c	/^smp_fetch_sport(const struct arg *args, struct sample *smp, const char *k, void *private)$/;"	f	file:
smp_fetch_src	./src/proto_tcp.c	/^int smp_fetch_src(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f
smp_fetch_src_updt_conn_cnt	./src/stream.c	/^smp_fetch_src_updt_conn_cnt(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_srv_conn	./src/backend.c	/^smp_fetch_srv_conn(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_srv_id	./src/backend.c	/^smp_fetch_srv_id(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_srv_is_up	./src/backend.c	/^smp_fetch_srv_is_up(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_srv_sess_rate	./src/backend.c	/^smp_fetch_srv_sess_rate(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_ssl_c_ca_err	./src/ssl_sock.c	/^smp_fetch_ssl_c_ca_err(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_ssl_c_ca_err_depth	./src/ssl_sock.c	/^smp_fetch_ssl_c_ca_err_depth(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_ssl_c_err	./src/ssl_sock.c	/^smp_fetch_ssl_c_err(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_ssl_c_used	./src/ssl_sock.c	/^smp_fetch_ssl_c_used(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_ssl_c_verify	./src/ssl_sock.c	/^smp_fetch_ssl_c_verify(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_ssl_fc	./src/ssl_sock.c	/^smp_fetch_ssl_fc(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_ssl_fc_alg_keysize	./src/ssl_sock.c	/^smp_fetch_ssl_fc_alg_keysize(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_ssl_fc_alpn	./src/ssl_sock.c	/^smp_fetch_ssl_fc_alpn(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_ssl_fc_cipher	./src/ssl_sock.c	/^smp_fetch_ssl_fc_cipher(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_ssl_fc_has_crt	./src/ssl_sock.c	/^smp_fetch_ssl_fc_has_crt(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_ssl_fc_has_sni	./src/ssl_sock.c	/^smp_fetch_ssl_fc_has_sni(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_ssl_fc_is_resumed	./src/ssl_sock.c	/^smp_fetch_ssl_fc_is_resumed(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_ssl_fc_npn	./src/ssl_sock.c	/^smp_fetch_ssl_fc_npn(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_ssl_fc_protocol	./src/ssl_sock.c	/^smp_fetch_ssl_fc_protocol(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_ssl_fc_session_id	./src/ssl_sock.c	/^smp_fetch_ssl_fc_session_id(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_ssl_fc_sni	./src/ssl_sock.c	/^smp_fetch_ssl_fc_sni(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_ssl_fc_unique_id	./src/ssl_sock.c	/^smp_fetch_ssl_fc_unique_id(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_ssl_fc_use_keysize	./src/ssl_sock.c	/^smp_fetch_ssl_fc_use_keysize(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_ssl_hello_sni	./src/payload.c	/^smp_fetch_ssl_hello_sni(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_ssl_hello_type	./src/payload.c	/^smp_fetch_ssl_hello_type(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_ssl_x_der	./src/ssl_sock.c	/^smp_fetch_ssl_x_der(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_ssl_x_i_dn	./src/ssl_sock.c	/^smp_fetch_ssl_x_i_dn(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_ssl_x_key_alg	./src/ssl_sock.c	/^smp_fetch_ssl_x_key_alg(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_ssl_x_notafter	./src/ssl_sock.c	/^smp_fetch_ssl_x_notafter(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_ssl_x_notbefore	./src/ssl_sock.c	/^smp_fetch_ssl_x_notbefore(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_ssl_x_s_dn	./src/ssl_sock.c	/^smp_fetch_ssl_x_s_dn(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_ssl_x_serial	./src/ssl_sock.c	/^smp_fetch_ssl_x_serial(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_ssl_x_sha1	./src/ssl_sock.c	/^smp_fetch_ssl_x_sha1(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_ssl_x_sig_alg	./src/ssl_sock.c	/^smp_fetch_ssl_x_sig_alg(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_ssl_x_version	./src/ssl_sock.c	/^smp_fetch_ssl_x_version(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_stcode	./src/proto_http.c	/^smp_fetch_stcode(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_stopping	./src/sample.c	/^smp_fetch_stopping(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_stver	./src/proto_http.c	/^smp_fetch_stver(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_table_avl	./src/stream.c	/^smp_fetch_table_avl(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_table_cnt	./src/stream.c	/^smp_fetch_table_cnt(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_true	./src/sample.c	/^smp_fetch_true(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_url	./src/proto_http.c	/^smp_fetch_url(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_url32	./src/proto_http.c	/^smp_fetch_url32(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_url32_src	./src/proto_http.c	/^smp_fetch_url32_src(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_url_ip	./src/proto_http.c	/^smp_fetch_url_ip(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_url_param	./src/proto_http.c	/^smp_fetch_url_param(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_url_param_val	./src/proto_http.c	/^smp_fetch_url_param_val(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_url_port	./src/proto_http.c	/^smp_fetch_url_port(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_var	./src/vars.c	/^static int smp_fetch_var(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_fetch_wait_end	./src/payload.c	/^smp_fetch_wait_end(const struct arg *args, struct sample *smp, const char *kw, void *private)$/;"	f	file:
smp_kws	./src/backend.c	/^static struct sample_fetch_kw_list smp_kws = {ILH, {$/;"	v	typeref:struct:sample_fetch_kw_list	file:
smp_kws	./src/frontend.c	/^static struct sample_fetch_kw_list smp_kws = {ILH, {$/;"	v	typeref:struct:sample_fetch_kw_list	file:
smp_kws	./src/listener.c	/^static struct sample_fetch_kw_list smp_kws = {ILH, {$/;"	v	typeref:struct:sample_fetch_kw_list	file:
smp_kws	./src/payload.c	/^static struct sample_fetch_kw_list smp_kws = {ILH, {$/;"	v	typeref:struct:sample_fetch_kw_list	file:
smp_kws	./src/sample.c	/^static struct sample_fetch_kw_list smp_kws = {ILH, {$/;"	v	typeref:struct:sample_fetch_kw_list	file:
smp_prefetch_http	./src/proto_http.c	/^int smp_prefetch_http(struct proxy *px, struct stream *s, unsigned int opt,$/;"	f
smp_resolve_args	./src/sample.c	/^int smp_resolve_args(struct proxy *p)$/;"	f
smp_to_stkey	./src/stick_table.c	/^struct stktable_key *smp_to_stkey(struct sample *smp, struct stktable *t)$/;"	f
smp_to_type	./src/sample.c	/^const char *smp_to_type[SMP_TYPES] = {$/;"	v
snd_buf	./include/types/connection.h	/^	int  (*snd_buf)(struct connection *conn, struct buffer *buf, int flags); \/* send callback *\/$/;"	m	struct:xprt_ops
snd_pipe	./include/types/connection.h	/^	int  (*snd_pipe)(struct connection *conn, struct pipe *pipe); \/* send-to-pipe callback *\/$/;"	m	struct:xprt_ops
sni	./include/types/server.h	/^		struct sample_expr *sni;        \/* sample expression for SNI *\/$/;"	m	struct:server::__anon122	typeref:struct:server::__anon122::sample_expr
sni_ctx	./include/types/listener.h	/^	struct eb_root sni_ctx;    \/* sni_ctx tree of all known certs full-names sorted by name *\/$/;"	m	struct:bind_conf	typeref:struct:bind_conf::eb_root
sni_ctx	./include/types/ssl_sock.h	/^struct sni_ctx {$/;"	s
sni_w_ctx	./include/types/listener.h	/^	struct eb_root sni_w_ctx;  \/* sni_ctx tree of all known certs wildcards sorted by name *\/$/;"	m	struct:bind_conf	typeref:struct:bind_conf::eb_root
snr_resolution_cb	./src/server.c	/^int snr_resolution_cb(struct dns_resolution *resolution, struct dns_nameserver *nameserver, unsigned char *response, int response_len)$/;"	f
snr_resolution_error_cb	./src/server.c	/^int snr_resolution_error_cb(struct dns_resolution *resolution, int error_code)$/;"	f
snr_update_srv_status	./src/server.c	/^int snr_update_srv_status(struct server *s)$/;"	f
sock	./include/types/connection.h	/^		} sock;$/;"	m	union:connection::__anon50	typeref:struct:connection::__anon50::__anon51
sock	./include/types/proto_udp.h	/^		} sock;$/;"	m	union:dgram_conn::__anon102	typeref:struct:dgram_conn::__anon102::__anon103
sock_addrlen	./include/types/protocol.h	/^	socklen_t sock_addrlen;				\/* socket address length, used by bind() *\/$/;"	m	struct:protocol
sock_domain	./include/types/protocol.h	/^	int sock_domain;				\/* socket domain, as passed to socket()   *\/$/;"	m	struct:protocol
sock_family	./include/types/protocol.h	/^	sa_family_t sock_family;			\/* socket family, for sockaddr *\/$/;"	m	struct:protocol
sock_init_arg	./include/types/mailers.h	/^	void *sock_init_arg;		\/* socket operations's opaque init argument if needed *\/$/;"	m	struct:mailer
sock_init_arg	./include/types/peers.h	/^	void *sock_init_arg;           \/* socket operations's opaque init argument if needed *\/$/;"	m	struct:peer
sock_prot	./include/types/protocol.h	/^	int sock_prot;					\/* socket protocol, as passed to socket() *\/$/;"	m	struct:protocol
sock_type	./include/types/protocol.h	/^	int sock_type;					\/* socket type, as passed to socket()     *\/$/;"	m	struct:protocol
socket	./include/types/applet.h	/^			struct hlua_socket *socket;$/;"	m	struct:appctx::__anon21::__anon30	typeref:struct:appctx::__anon21::__anon30::hlua_socket
socket_proxy	./src/hlua.c	/^static struct proxy socket_proxy;$/;"	v	typeref:struct:proxy	file:
socket_ssl	./src/hlua.c	/^static struct server socket_ssl;$/;"	v	typeref:struct:server	file:
socket_tcp	./src/hlua.c	/^static struct server socket_tcp;$/;"	v	typeref:struct:server	file:
soft_stop	./src/proxy.c	/^void soft_stop(void)$/;"	f
sol	./include/types/proto_http.h	/^	unsigned int sol;                      \/* start of current line during parsing otherwise zero *\/$/;"	m	struct:http_msg
source_addr	./include/types/connection.h	/^	struct sockaddr_storage source_addr; \/* the address to which we want to bind for connect() *\/$/;"	m	struct:conn_src	typeref:struct:conn_src::sockaddr_storage
source_suffix	./doc/lua-api/conf.py	/^source_suffix = '.rst'$/;"	v
sov	./include/types/proto_http.h	/^	int sov;                               \/* current header: start of value ; data: start of body *\/$/;"	m	struct:http_msg
spare	./include/import/lru.h	/^	struct lru64  *spare;$/;"	m	struct:lru64_head	typeref:struct:lru64_head::lru64
spawn_haproxy	./src/haproxy-systemd-wrapper.c	/^static void spawn_haproxy(char **pid_strv, int nb_pid)$/;"	f	file:
split_url	./include/common/standard.h	/^struct split_url {$/;"	s
sport_range	./include/types/connection.h	/^	struct port_range *sport_range;      \/* optional per-server TCP source ports *\/$/;"	m	struct:conn_src	typeref:struct:conn_src::port_range
spread_checks	./include/types/global.h	/^	int spread_checks;$/;"	m	struct:global
sps_lim	./include/types/global.h	/^	int sps_lim, sps_max;$/;"	m	struct:global
sps_max	./include/types/counters.h	/^	unsigned int sps_max;			\/* maximum of new sessions per second seen on this server *\/$/;"	m	struct:srvcounters
sps_max	./include/types/counters.h	/^	unsigned int sps_max;                   \/* maximum of new connections accepted per second (sessions) *\/$/;"	m	struct:pxcounters
sps_max	./include/types/global.h	/^	int sps_lim, sps_max;$/;"	m	struct:global
src	./include/types/proxy.h	/^	struct sockaddr_storage src;	\/* client's address *\/$/;"	m	struct:error_snapshot	typeref:struct:error_snapshot::sockaddr_storage
src_addr	./include/types/connection.h	/^			uint32_t src_addr;$/;"	m	struct:proxy_hdr_v2::__anon53::__anon54
src_addr	./include/types/connection.h	/^			uint8_t  src_addr[16];$/;"	m	struct:proxy_hdr_v2::__anon53::__anon55
src_addr	./include/types/connection.h	/^			uint8_t src_addr[108];$/;"	m	struct:proxy_hdr_v2::__anon53::__anon56
src_port	./include/types/connection.h	/^			uint16_t src_port;$/;"	m	struct:proxy_hdr_v2::__anon53::__anon54
src_port	./include/types/connection.h	/^			uint16_t src_port;$/;"	m	struct:proxy_hdr_v2::__anon53::__anon55
srv	./include/types/arg.h	/^	struct server *srv;$/;"	m	union:arg_data	typeref:struct:arg_data::server
srv	./include/types/lb_map.h	/^	struct server **srv;	\/* the server map used to apply weights *\/$/;"	m	struct:lb_map	typeref:struct:lb_map::server
srv	./include/types/proxy.h	/^	struct server *srv, defsrv;		\/* known servers; default server configuration *\/$/;"	m	struct:proxy	typeref:struct:proxy::server
srv	./include/types/proxy.h	/^	struct server *srv;		\/* server associated with the error (or NULL) *\/$/;"	m	struct:error_snapshot	typeref:struct:error_snapshot::server
srv	./include/types/proxy.h	/^	} srv;$/;"	m	struct:server_rule	typeref:union:server_rule::__anon113
srv	./include/types/queue.h	/^	struct server *srv;		\/* the server we are waiting for *\/$/;"	m	struct:pendconn	typeref:struct:pendconn::server
srv	./tests/filltab25.c	/^struct srv {$/;"	s	file:
srv	./tests/filltab25.c	/^} *srv;$/;"	v	typeref:struct:srv
srv_aborts	./include/types/counters.h	/^	long long cli_aborts, srv_aborts;	\/* aborted responses during DATA phase due to client or server *\/$/;"	m	struct:srvcounters
srv_aborts	./include/types/counters.h	/^	long long srv_aborts;                   \/* aborted responses during DATA phase caused by the server *\/$/;"	m	struct:pxcounters
srv_act	./include/types/proxy.h	/^	int srv_act, srv_bck;			\/* # of servers eligible for LB (UP|!checked) AND (enabled+weight!=0) *\/$/;"	m	struct:proxy
srv_adm_set_drain	./include/proto/server.h	/^static inline void srv_adm_set_drain(struct server *s)$/;"	f
srv_adm_set_maint	./include/proto/server.h	/^static inline void srv_adm_set_maint(struct server *s)$/;"	f
srv_adm_set_ready	./include/proto/server.h	/^static inline void srv_adm_set_ready(struct server *s)$/;"	f
srv_admin	./include/types/server.h	/^enum srv_admin {$/;"	g
srv_append_status	./src/server.c	/^void srv_append_status(struct chunk *msg, struct server *s, const char *reason, int xferred, int forced)$/;"	f
srv_bck	./include/types/proxy.h	/^	int srv_act, srv_bck;			\/* # of servers eligible for LB (UP|!checked) AND (enabled+weight!=0) *\/$/;"	m	struct:proxy
srv_clr_admin_flag	./src/server.c	/^void srv_clr_admin_flag(struct server *s, enum srv_admin mode)$/;"	f
srv_conn	./include/types/stream.h	/^	struct server *srv_conn;        \/* stream already has a slot on a server and is not in queue *\/$/;"	m	struct:stream	typeref:struct:stream::server
srv_cookie	./include/types/proto_http.h	/^	char *srv_cookie;               \/* cookie presented by the server, in capture mode *\/$/;"	m	struct:http_txn
srv_downtime	./src/server.c	/^int srv_downtime(const struct server *s)$/;"	f
srv_dump_kws	./src/server.c	/^void srv_dump_kws(char **out)$/;"	f
srv_dynamic_maxconn	./src/queue.c	/^unsigned int srv_dynamic_maxconn(const struct server *s)$/;"	f
srv_error	./include/types/stream.h	/^	void (*srv_error)(struct stream *s,     \/* the function to call upon unrecoverable server errors (or NULL) *\/$/;"	m	struct:stream
srv_find_kw	./src/server.c	/^struct srv_kw *srv_find_kw(const char *kw)$/;"	f
srv_getinter	./src/server.c	/^int srv_getinter(const struct check *check)$/;"	f
srv_inc_sess_ctr	./include/proto/server.h	/^static void inline srv_inc_sess_ctr(struct server *s)$/;"	f
srv_is_usable	./include/proto/backend.h	/^static inline int srv_is_usable(const struct server *srv)$/;"	f
srv_keywords	./src/server.c	/^static struct srv_kw_list srv_keywords = {$/;"	v	typeref:struct:srv_kw_list	file:
srv_kw	./include/types/server.h	/^struct srv_kw {$/;"	s
srv_kw_list	./include/types/server.h	/^struct srv_kw_list {$/;"	s
srv_kws	./src/proto_tcp.c	/^static struct srv_kw_list srv_kws = { "TCP", { }, {$/;"	v	typeref:struct:srv_kw_list	file:
srv_kws	./src/server.c	/^static struct srv_kw_list srv_kws = { "ALL", { }, {$/;"	v	typeref:struct:srv_kw_list	file:
srv_kws	./src/ssl_sock.c	/^static struct srv_kw_list srv_kws = { "SSL", { }, {$/;"	v	typeref:struct:srv_kw_list	file:
srv_lastsession	./src/server.c	/^int srv_lastsession(const struct server *s)$/;"	f
srv_lb_commit_status	./include/proto/backend.h	/^static inline void srv_lb_commit_status(struct server *srv)$/;"	f
srv_lb_status_changed	./include/proto/backend.h	/^static inline int srv_lb_status_changed(const struct server *srv)$/;"	f
srv_parse_ca_file	./src/ssl_sock.c	/^static int srv_parse_ca_file(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_check_ssl	./src/ssl_sock.c	/^static int srv_parse_check_ssl(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_ciphers	./src/ssl_sock.c	/^static int srv_parse_ciphers(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_crl_file	./src/ssl_sock.c	/^static int srv_parse_crl_file(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_crt	./src/ssl_sock.c	/^static int srv_parse_crt(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_force_sslv3	./src/ssl_sock.c	/^static int srv_parse_force_sslv3(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_force_tlsv10	./src/ssl_sock.c	/^static int srv_parse_force_tlsv10(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_force_tlsv11	./src/ssl_sock.c	/^static int srv_parse_force_tlsv11(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_force_tlsv12	./src/ssl_sock.c	/^static int srv_parse_force_tlsv12(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_id	./src/server.c	/^static int srv_parse_id(char **args, int *cur_arg, struct proxy *curproxy, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_no_ssl_reuse	./src/ssl_sock.c	/^static int srv_parse_no_ssl_reuse(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_no_sslv3	./src/ssl_sock.c	/^static int srv_parse_no_sslv3(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_no_tls_tickets	./src/ssl_sock.c	/^static int srv_parse_no_tls_tickets(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_no_tlsv10	./src/ssl_sock.c	/^static int srv_parse_no_tlsv10(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_no_tlsv11	./src/ssl_sock.c	/^static int srv_parse_no_tlsv11(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_no_tlsv12	./src/ssl_sock.c	/^static int srv_parse_no_tlsv12(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_send_proxy_cn	./src/ssl_sock.c	/^static int srv_parse_send_proxy_cn(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_send_proxy_ssl	./src/ssl_sock.c	/^static int srv_parse_send_proxy_ssl(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_sni	./src/ssl_sock.c	/^static int srv_parse_sni(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_ssl	./src/ssl_sock.c	/^static int srv_parse_ssl(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_tcp_ut	./src/proto_tcp.c	/^static int srv_parse_tcp_ut(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_verify	./src/ssl_sock.c	/^static int srv_parse_verify(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_parse_verifyhost	./src/ssl_sock.c	/^static int srv_parse_verifyhost(char **args, int *cur_arg, struct proxy *px, struct server *newsrv, char **err)$/;"	f	file:
srv_queue_size	./include/types/stream.h	/^	unsigned long srv_queue_size;   \/* number of streams waiting for a connect slot on this server at accept() time (in direct assignment) *\/$/;"	m	struct:strm_logs
srv_redispatch_connect	./src/backend.c	/^int srv_redispatch_connect(struct stream *s)$/;"	f
srv_register_keywords	./src/server.c	/^void srv_register_keywords(struct srv_kw_list *kwl)$/;"	f
srv_set_admin_flag	./src/server.c	/^void srv_set_admin_flag(struct server *s, enum srv_admin mode)$/;"	f
srv_set_running	./src/server.c	/^void srv_set_running(struct server *s, const char *reason)$/;"	f
srv_set_sess_last	./include/proto/server.h	/^static void inline srv_set_sess_last(struct server *s)$/;"	f
srv_set_stopped	./src/server.c	/^void srv_set_stopped(struct server *s, const char *reason)$/;"	f
srv_set_stopping	./src/server.c	/^void srv_set_stopping(struct server *s, const char *reason)$/;"	f
srv_shutdown_backup_streams	./src/server.c	/^void srv_shutdown_backup_streams(struct proxy *px, int why)$/;"	f
srv_shutdown_streams	./src/server.c	/^void srv_shutdown_streams(struct server *srv, int why)$/;"	f
srv_st	./contrib/halog/halog.c	/^struct srv_st {$/;"	s	file:
srv_state	./include/types/server.h	/^enum srv_state {$/;"	g
srv_stats_colour	./src/dumpstats.c	/^enum srv_stats_colour {$/;"	g	file:
srv_stats_colour_st	./src/dumpstats.c	/^static const char *srv_stats_colour_st[SRV_STATS_COLOUR_COUNT] = {$/;"	v	file:
srv_stats_state	./src/dumpstats.c	/^enum srv_stats_state {$/;"	g	file:
srv_update_state	./src/server.c	/^static void srv_update_state(struct server *srv, int version, char **params)$/;"	f	file:
srv_was_usable	./include/proto/backend.h	/^static inline int srv_was_usable(const struct server *srv)$/;"	f
srvcounters	./include/types/counters.h	/^struct srvcounters {$/;"	s
ssl_be_keys_max	./include/types/global.h	/^	int ssl_fe_keys_max, ssl_be_keys_max;$/;"	m	struct:global
ssl_be_keys_per_sec	./include/types/global.h	/^	struct freq_ctr ssl_be_keys_per_sec;$/;"	m	struct:global	typeref:struct:global::freq_ctr
ssl_ctx	./include/types/server.h	/^	} ssl_ctx;$/;"	m	struct:server	typeref:struct:server::__anon122
ssl_ctx_cache	./include/types/global.h	/^		int ssl_ctx_cache; \/* max number of entries in the ssl_ctx cache. *\/$/;"	m	struct:global::__anon72
ssl_ctx_lru_seed	./src/ssl_sock.c	/^static unsigned int       ssl_ctx_lru_seed = 0;$/;"	v	file:
ssl_ctx_lru_tree	./src/ssl_sock.c	/^static struct lru64_head *ssl_ctx_lru_tree = NULL;$/;"	v	typeref:struct:lru64_head	file:
ssl_default_dh_param	./include/types/global.h	/^		unsigned int ssl_default_dh_param; \/* SSL maximum DH parameter size *\/$/;"	m	struct:global::__anon72
ssl_dh_ptr_index	./src/ssl_sock.c	/^static int ssl_dh_ptr_index = -1;$/;"	v	file:
ssl_fe_keys_max	./include/types/global.h	/^	int ssl_fe_keys_max, ssl_be_keys_max;$/;"	m	struct:global
ssl_fe_keys_per_sec	./include/types/global.h	/^	struct freq_ctr ssl_fe_keys_per_sec;$/;"	m	struct:global	typeref:struct:global::freq_ctr
ssl_get_dh_1024	./src/ssl_sock.c	/^static DH * ssl_get_dh_1024(void)$/;"	f	file:
ssl_get_dh_2048	./src/ssl_sock.c	/^static DH *ssl_get_dh_2048(void)$/;"	f	file:
ssl_get_dh_4096	./src/ssl_sock.c	/^static DH *ssl_get_dh_4096(void)$/;"	f	file:
ssl_get_tmp_dh	./src/ssl_sock.c	/^static DH *ssl_get_tmp_dh(SSL *ssl, int export, int keylen)$/;"	f	file:
ssl_handshake_max_cost	./include/types/global.h	/^	int ssl_handshake_max_cost; \/* how many bytes an SSL handshake may use *\/$/;"	m	struct:global
ssl_initialize_random	./src/ssl_sock.c	/^static int ssl_initialize_random()$/;"	f	file:
ssl_lim	./include/types/global.h	/^	int ssl_lim, ssl_max;$/;"	m	struct:global
ssl_max	./include/types/global.h	/^	int ssl_lim, ssl_max;$/;"	m	struct:global
ssl_max_record	./include/types/global.h	/^		unsigned int ssl_max_record; \/* SSL max record size *\/$/;"	m	struct:global::__anon72
ssl_options	./include/types/listener.h	/^	int ssl_options;           \/* ssl options *\/$/;"	m	struct:bind_conf
ssl_parse_default_bind_options	./src/ssl_sock.c	/^static int ssl_parse_default_bind_options(char **args, int section_type, struct proxy *curpx,$/;"	f	file:
ssl_parse_default_server_options	./src/ssl_sock.c	/^static int ssl_parse_default_server_options(char **args, int section_type, struct proxy *curpx,$/;"	f	file:
ssl_per_sec	./include/types/global.h	/^	struct freq_ctr ssl_per_sec;$/;"	m	struct:global	typeref:struct:global::freq_ctr
ssl_server_verify	./include/types/global.h	/^	unsigned int ssl_server_verify; \/* default verify mode on servers side *\/$/;"	m	struct:global
ssl_session_max_cost	./include/types/global.h	/^	int ssl_session_max_cost;   \/* how many bytes an SSL session may cost *\/$/;"	m	struct:global
ssl_sock	./src/ssl_sock.c	/^struct xprt_ops ssl_sock = {$/;"	v	typeref:struct:xprt_ops
ssl_sock_add_cert_sni	./src/ssl_sock.c	/^static int ssl_sock_add_cert_sni(SSL_CTX *ctx, struct bind_conf *s, char *name, int order)$/;"	f	file:
ssl_sock_advertise_alpn_protos	./src/ssl_sock.c	/^static int ssl_sock_advertise_alpn_protos(SSL *s, const unsigned char **out,$/;"	f	file:
ssl_sock_advertise_npn_protos	./src/ssl_sock.c	/^static int ssl_sock_advertise_npn_protos(SSL *s, const unsigned char **data,$/;"	f	file:
ssl_sock_bind_verifycbk	./src/ssl_sock.c	/^int ssl_sock_bind_verifycbk(int ok, X509_STORE_CTX *x_store)$/;"	f
ssl_sock_close	./src/ssl_sock.c	/^static void ssl_sock_close(struct connection *conn) {$/;"	f	file:
ssl_sock_create_cert	./src/ssl_sock.c	/^ssl_sock_create_cert(struct connection *conn, const char *servername, unsigned int serial)$/;"	f
ssl_sock_crt2der	./src/ssl_sock.c	/^ssl_sock_crt2der(X509 *crt, struct chunk *out)$/;"	f	file:
ssl_sock_do_create_cert	./src/ssl_sock.c	/^ssl_sock_do_create_cert(const char *servername, unsigned int serial,$/;"	f	file:
ssl_sock_free_all_ctx	./src/ssl_sock.c	/^void ssl_sock_free_all_ctx(struct bind_conf *bind_conf)$/;"	f
ssl_sock_free_ca	./src/ssl_sock.c	/^ssl_sock_free_ca(struct bind_conf *bind_conf)$/;"	f
ssl_sock_free_srv_ctx	./src/ssl_sock.c	/^void ssl_sock_free_srv_ctx(struct server *srv)$/;"	f
ssl_sock_from_buf	./src/ssl_sock.c	/^static int ssl_sock_from_buf(struct connection *conn, struct buffer *buf, int flags)$/;"	f	file:
ssl_sock_generate_certificate	./src/ssl_sock.c	/^ssl_sock_generate_certificate(const char *servername, struct bind_conf *bind_conf, SSL *ssl)$/;"	f	file:
ssl_sock_generated_cert_serial	./src/ssl_sock.c	/^ssl_sock_generated_cert_serial(const void *data, size_t len)$/;"	f
ssl_sock_get_cert_used_conn	./src/ssl_sock.c	/^int ssl_sock_get_cert_used_conn(struct connection *conn)$/;"	f
ssl_sock_get_cert_used_sess	./src/ssl_sock.c	/^int ssl_sock_get_cert_used_sess(struct connection *conn)$/;"	f
ssl_sock_get_cipher_name	./src/ssl_sock.c	/^const char *ssl_sock_get_cipher_name(struct connection *conn)$/;"	f
ssl_sock_get_dh_from_file	./src/ssl_sock.c	/^static DH * ssl_sock_get_dh_from_file(const char *filename)$/;"	f	file:
ssl_sock_get_dn_entry	./src/ssl_sock.c	/^ssl_sock_get_dn_entry(X509_NAME *a, const struct chunk *entry, int pos, struct chunk *out)$/;"	f	file:
ssl_sock_get_dn_oneline	./src/ssl_sock.c	/^ssl_sock_get_dn_oneline(X509_NAME *a, struct chunk *out)$/;"	f	file:
ssl_sock_get_generated_cert	./src/ssl_sock.c	/^ssl_sock_get_generated_cert(unsigned int serial, struct bind_conf *bind_conf)$/;"	f
ssl_sock_get_proto_version	./src/ssl_sock.c	/^const char *ssl_sock_get_proto_version(struct connection *conn)$/;"	f
ssl_sock_get_remote_common_name	./src/ssl_sock.c	/^int ssl_sock_get_remote_common_name(struct connection *conn, struct chunk *dest)$/;"	f
ssl_sock_get_serial	./src/ssl_sock.c	/^ssl_sock_get_serial(X509 *crt, struct chunk *out)$/;"	f	file:
ssl_sock_get_time	./src/ssl_sock.c	/^ssl_sock_get_time(ASN1_TIME *tm, struct chunk *out)$/;"	f	file:
ssl_sock_get_verify_result	./src/ssl_sock.c	/^unsigned int ssl_sock_get_verify_result(struct connection *conn)$/;"	f
ssl_sock_get_version	./src/ssl_sock.c	/^char *ssl_sock_get_version(struct connection *conn)$/;"	f
ssl_sock_handshake	./src/ssl_sock.c	/^int ssl_sock_handshake(struct connection *conn, unsigned int flag)$/;"	f
ssl_sock_infocbk	./src/ssl_sock.c	/^void ssl_sock_infocbk(const SSL *ssl, int where, int ret)$/;"	f
ssl_sock_init	./src/ssl_sock.c	/^static int ssl_sock_init(struct connection *conn)$/;"	f	file:
ssl_sock_is_ssl	./include/proto/ssl_sock.h	/^int ssl_sock_is_ssl(struct connection *conn)$/;"	f
ssl_sock_load_ca	./src/ssl_sock.c	/^ssl_sock_load_ca(struct bind_conf *bind_conf, struct proxy *px)$/;"	f
ssl_sock_load_cert	./src/ssl_sock.c	/^int ssl_sock_load_cert(char *path, struct bind_conf *bind_conf, struct proxy *curproxy, char **err)$/;"	f
ssl_sock_load_cert_chain_file	./src/ssl_sock.c	/^static int ssl_sock_load_cert_chain_file(SSL_CTX *ctx, const char *file, struct bind_conf *s, char **sni_filter, int fcount)$/;"	f	file:
ssl_sock_load_cert_file	./src/ssl_sock.c	/^static int ssl_sock_load_cert_file(const char *path, struct bind_conf *bind_conf, struct proxy *curproxy, char **sni_filter, int fcount, char **err)$/;"	f	file:
ssl_sock_load_cert_list_file	./src/ssl_sock.c	/^int ssl_sock_load_cert_list_file(char *file, struct bind_conf *bind_conf, struct proxy *curproxy, char **err)$/;"	f
ssl_sock_load_dh_params	./src/ssl_sock.c	/^int ssl_sock_load_dh_params(SSL_CTX *ctx, const char *file)$/;"	f
ssl_sock_load_global_dh_param_from_file	./src/ssl_sock.c	/^int ssl_sock_load_global_dh_param_from_file(const char *filename)$/;"	f
ssl_sock_load_ocsp	./src/ssl_sock.c	/^static int ssl_sock_load_ocsp(SSL_CTX *ctx, const char *cert_path)$/;"	f	file:
ssl_sock_load_ocsp_response	./src/ssl_sock.c	/^static int ssl_sock_load_ocsp_response(struct chunk *ocsp_response, struct certificate_ocsp *ocsp, OCSP_CERTID *cid, char **err)$/;"	f	file:
ssl_sock_load_ocsp_response_from_file	./src/ssl_sock.c	/^static int ssl_sock_load_ocsp_response_from_file(const char *ocsp_path, struct certificate_ocsp *ocsp, OCSP_CERTID *cid, char **err)$/;"	f	file:
ssl_sock_load_sctl	./src/ssl_sock.c	/^static int ssl_sock_load_sctl(SSL_CTX *ctx, const char *cert_path)$/;"	f	file:
ssl_sock_load_sctl_from_file	./src/ssl_sock.c	/^static int ssl_sock_load_sctl_from_file(const char *sctl_path, struct chunk **sctl)$/;"	f	file:
ssl_sock_msgcbk	./src/ssl_sock.c	/^void ssl_sock_msgcbk(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg)$/;"	f
ssl_sock_ocsp_stapling_cbk	./src/ssl_sock.c	/^int ssl_sock_ocsp_stapling_cbk(SSL *ssl, void *arg)$/;"	f
ssl_sock_parse_sctl	./src/ssl_sock.c	/^static int ssl_sock_parse_sctl(struct chunk *sctl)$/;"	f	file:
ssl_sock_prepare_all_ctx	./src/ssl_sock.c	/^int ssl_sock_prepare_all_ctx(struct bind_conf *bind_conf, struct proxy *px)$/;"	f
ssl_sock_prepare_ctx	./src/ssl_sock.c	/^int ssl_sock_prepare_ctx(struct bind_conf *bind_conf, SSL_CTX *ctx, struct proxy *curproxy)$/;"	f
ssl_sock_prepare_srv_ctx	./src/ssl_sock.c	/^int ssl_sock_prepare_srv_ctx(struct server *srv, struct proxy *curproxy)$/;"	f
ssl_sock_sctl_add_cbk	./src/ssl_sock.c	/^int ssl_sock_sctl_add_cbk(SSL *ssl, unsigned ext_type, const unsigned char **out, size_t *outlen, int *al, void *add_arg)$/;"	f
ssl_sock_sctl_free_func	./src/ssl_sock.c	/^static void ssl_sock_sctl_free_func(void *parent, void *ptr, CRYPTO_EX_DATA *ad, int idx, long argl, void *argp)$/;"	f	file:
ssl_sock_sctl_parse_cbk	./src/ssl_sock.c	/^int ssl_sock_sctl_parse_cbk(SSL *s, unsigned int ext_type, const unsigned char *in, size_t inlen, int *al, void *parse_arg)$/;"	f
ssl_sock_set_generated_cert	./src/ssl_sock.c	/^ssl_sock_set_generated_cert(SSL_CTX *ssl_ctx, unsigned int serial, struct bind_conf *bind_conf)$/;"	f
ssl_sock_set_servername	./src/ssl_sock.c	/^void ssl_sock_set_servername(struct connection *conn, const char *hostname)$/;"	f
ssl_sock_shutw	./src/ssl_sock.c	/^static void ssl_sock_shutw(struct connection *conn, int clean)$/;"	f	file:
ssl_sock_srv_hostcheck	./src/ssl_sock.c	/^static int ssl_sock_srv_hostcheck(const char *pattern, const char *hostname)$/;"	f	file:
ssl_sock_srv_verifycbk	./src/ssl_sock.c	/^static int ssl_sock_srv_verifycbk(int ok, X509_STORE_CTX *ctx)$/;"	f	file:
ssl_sock_switchctx_cbk	./src/ssl_sock.c	/^static int ssl_sock_switchctx_cbk(SSL *ssl, int *al, struct bind_conf *s)$/;"	f	file:
ssl_sock_to_buf	./src/ssl_sock.c	/^static int ssl_sock_to_buf(struct connection *conn, struct buffer *buf, int count)$/;"	f	file:
ssl_sock_update_ocsp_response	./src/ssl_sock.c	/^int ssl_sock_update_ocsp_response(struct chunk *ocsp_response, char **err)$/;"	f
ssl_sock_update_tlskey	./src/ssl_sock.c	/^int ssl_sock_update_tlskey(char *filename, struct chunk *tlskey, char **err) {$/;"	f
ssl_tlsext_ticket_key_cb	./src/ssl_sock.c	/^static int ssl_tlsext_ticket_key_cb(SSL *s, unsigned char key_name[16], unsigned char *iv, EVP_CIPHER_CTX *ectx, HMAC_CTX *hctx, int enc)$/;"	f	file:
ssl_used_backend	./include/types/global.h	/^	int ssl_used_backend;       \/* non-zero if SSL is used in a backend *\/$/;"	m	struct:global
ssl_used_frontend	./include/types/global.h	/^	int ssl_used_frontend;      \/* non-zero if SSL is used in a frontend *\/$/;"	m	struct:global
sslcachesize	./include/types/global.h	/^		int sslcachesize;  \/* SSL cache size in session, defaults to 20000 *\/$/;"	m	struct:global::__anon72
sslconns	./src/ssl_sock.c	/^int sslconns = 0;$/;"	v
ssllifetime	./include/types/global.h	/^		unsigned int ssllifetime;   \/* SSL session lifetime in seconds *\/$/;"	m	struct:global::__anon72
sslprivatecache	./include/types/global.h	/^		int sslprivatecache; \/* Force to use a private session cache even if nbproc > 1 *\/$/;"	m	struct:global::__anon72
sslv3_client_hello_pkt	./src/cfgparse.c	/^const char sslv3_client_hello_pkt[] = {$/;"	v
st	./include/types/proto_http.h	/^		} st;                          \/* status line : field, length *\/$/;"	m	union:http_msg::__anon99	typeref:struct:http_msg::__anon99::__anon101
st0	./include/types/applet.h	/^	unsigned int st0;          \/* CLI state for stats, session state for peers *\/$/;"	m	struct:appctx
st1	./include/types/applet.h	/^	unsigned int st1;          \/* prompt for stats, session error for peers *\/$/;"	m	struct:appctx
st2	./include/types/applet.h	/^	unsigned int st2;          \/* output state for stats, unused by peers  *\/$/;"	m	struct:appctx
st_cnt	./contrib/halog/halog.c	/^	unsigned int st_cnt[6]; \/* 0xx to 5xx *\/$/;"	m	struct:srv_st	file:
st_code	./include/types/applet.h	/^			int st_code;		\/* the status code returned by an action *\/$/;"	m	struct:appctx::__anon21::__anon22
start	./include/types/checks.h	/^	struct timeval start;			\/* last health check start time *\/$/;"	m	struct:check	typeref:struct:check::timeval
start_check_task	./src/checks.c	/^static int start_check_task(struct check *check, int mininter,$/;"	f	file:
start_checks	./src/checks.c	/^int start_checks() {$/;"	f
start_date	./src/time.c	/^struct timeval start_date;      \/* the process's start date *\/$/;"	v	typeref:struct:timeval
start_proxies	./src/proxy.c	/^int start_proxies(int verbose)$/;"	f
start_time	./include/types/hlua.h	/^	unsigned int start_time; \/* The ms time when the Lua starts the last execution. *\/$/;"	m	struct:hlua
stat_status_codes	./src/proto_http.c	/^const char *stat_status_codes[STAT_STATUS_SIZE] = {$/;"	v
state	./include/types/checks.h	/^	int state;				\/* state of the check : CHK_ST_*   *\/$/;"	m	struct:check
state	./include/types/fd.h	/^	unsigned char state;                 \/* FD state for read and write directions (2*3 bits) *\/$/;"	m	struct:fdtab
state	./include/types/lb_map.h	/^	int state;		\/* LB_MAP_RECALC *\/$/;"	m	struct:lb_map
state	./include/types/listener.h	/^	enum li_state state;            \/* state: NEW, INIT, ASSIGNED, LISTEN, READY, FULL *\/$/;"	m	struct:listener	typeref:enum:listener::li_state
state	./include/types/peers.h	/^	int state;			 \/* proxy state *\/$/;"	m	struct:peers
state	./include/types/proxy.h	/^	enum pr_state state;                    \/* proxy state, one of PR_* *\/$/;"	m	struct:proxy	typeref:enum:proxy::pr_state
state	./include/types/proxy.h	/^	unsigned int state;		\/* message state before the error (when saved) *\/$/;"	m	struct:error_snapshot
state	./include/types/server.h	/^	enum srv_state state, prev_state;       \/* server state among SRV_ST_* *\/$/;"	m	struct:server	typeref:enum:server::srv_state
state	./include/types/stream_interface.h	/^	enum si_state state;     \/* SI_ST* *\/$/;"	m	struct:stream_interface	typeref:enum:stream_interface::si_state
state	./include/types/task.h	/^	unsigned short state;		\/* task state : bit field of TASK_* *\/$/;"	m	struct:task
static_hdr_ctx	./src/proto_http.c	/^static struct hdr_ctx static_hdr_ctx;$/;"	v	typeref:struct:hdr_ctx	file:
static_pattern	./src/pattern.c	/^static struct pattern static_pattern;$/;"	v	typeref:struct:pattern	file:
static_table_key	./src/stick_table.c	/^struct stktable_key *static_table_key;$/;"	v	typeref:struct:stktable_key
stats	./include/types/applet.h	/^		} stats;$/;"	m	union:appctx::__anon21	typeref:struct:appctx::__anon21::__anon22
stats_admin_rule	./include/common/uri_auth.h	/^struct stats_admin_rule {$/;"	s
stats_check_uri	./src/proto_http.c	/^int stats_check_uri(struct stream_interface *si, struct http_txn *txn, struct proxy *backend)$/;"	f
stats_dump_backend_to_buffer	./src/dumpstats.c	/^static int stats_dump_backend_to_buffer(struct stream_interface *si)$/;"	f	file:
stats_dump_be_stats	./src/dumpstats.c	/^static int stats_dump_be_stats(struct stream_interface *si, struct proxy *px, int flags)$/;"	f	file:
stats_dump_csv_header	./src/dumpstats.c	/^static void stats_dump_csv_header()$/;"	f	file:
stats_dump_errors_to_buffer	./src/dumpstats.c	/^static int stats_dump_errors_to_buffer(struct stream_interface *si)$/;"	f	file:
stats_dump_fe_stats	./src/dumpstats.c	/^static int stats_dump_fe_stats(struct stream_interface *si, struct proxy *px)$/;"	f	file:
stats_dump_full_sess_to_buffer	./src/dumpstats.c	/^static int stats_dump_full_sess_to_buffer(struct stream_interface *si, struct stream *sess)$/;"	f	file:
stats_dump_html_end	./src/dumpstats.c	/^static void stats_dump_html_end()$/;"	f	file:
stats_dump_html_head	./src/dumpstats.c	/^static void stats_dump_html_head(struct uri_auth *uri)$/;"	f	file:
stats_dump_html_info	./src/dumpstats.c	/^static void stats_dump_html_info(struct stream_interface *si, struct uri_auth *uri)$/;"	f	file:
stats_dump_html_px_end	./src/dumpstats.c	/^static void stats_dump_html_px_end(struct stream_interface *si, struct proxy *px)$/;"	f	file:
stats_dump_html_px_hdr	./src/dumpstats.c	/^static void stats_dump_html_px_hdr(struct stream_interface *si, struct proxy *px, struct uri_auth *uri)$/;"	f	file:
stats_dump_info_to_buffer	./src/dumpstats.c	/^static int stats_dump_info_to_buffer(struct stream_interface *si)$/;"	f	file:
stats_dump_li_stats	./src/dumpstats.c	/^static int stats_dump_li_stats(struct stream_interface *si, struct proxy *px, struct listener *l, int flags)$/;"	f	file:
stats_dump_pools_to_buffer	./src/dumpstats.c	/^static int stats_dump_pools_to_buffer(struct stream_interface *si)$/;"	f	file:
stats_dump_proxy_to_buffer	./src/dumpstats.c	/^static int stats_dump_proxy_to_buffer(struct stream_interface *si, struct proxy *px, struct uri_auth *uri)$/;"	f	file:
stats_dump_resolvers_to_buffer	./src/dumpstats.c	/^static int stats_dump_resolvers_to_buffer(struct stream_interface *si)$/;"	f	file:
stats_dump_servers_state_to_buffer	./src/dumpstats.c	/^static int stats_dump_servers_state_to_buffer(struct stream_interface *si)$/;"	f	file:
stats_dump_sess_to_buffer	./src/dumpstats.c	/^static int stats_dump_sess_to_buffer(struct stream_interface *si)$/;"	f	file:
stats_dump_stat_to_buffer	./src/dumpstats.c	/^static int stats_dump_stat_to_buffer(struct stream_interface *si, struct uri_auth *uri)$/;"	f	file:
stats_dump_sv_stats	./src/dumpstats.c	/^static int stats_dump_sv_stats(struct stream_interface *si, struct proxy *px, int flags, struct server *sv,$/;"	f	file:
stats_dump_table_entry_to_buffer	./src/dumpstats.c	/^static int stats_dump_table_entry_to_buffer(struct chunk *msg, struct stream_interface *si,$/;"	f	file:
stats_dump_table_head_to_buffer	./src/dumpstats.c	/^static int stats_dump_table_head_to_buffer(struct chunk *msg, struct stream_interface *si,$/;"	f	file:
stats_fe	./include/types/global.h	/^	struct proxy *stats_fe;     \/* the frontend holding the stats settings *\/$/;"	m	struct:global	typeref:struct:global::proxy
stats_map_lookup	./src/dumpstats.c	/^static int stats_map_lookup(struct stream_interface *si)$/;"	f	file:
stats_parse_global	./src/dumpstats.c	/^static int stats_parse_global(char **args, int section_type, struct proxy *curpx,$/;"	f	file:
stats_pat_list	./src/dumpstats.c	/^static int stats_pat_list(struct stream_interface *si)$/;"	f	file:
stats_pats_list	./src/dumpstats.c	/^static int stats_pats_list(struct stream_interface *si)$/;"	f	file:
stats_permission_denied_msg	./src/dumpstats.c	/^static const char stats_permission_denied_msg[] =$/;"	v	file:
stats_process_http_post	./src/dumpstats.c	/^static int stats_process_http_post(struct stream_interface *si)$/;"	f	file:
stats_send_http_headers	./src/dumpstats.c	/^static int stats_send_http_headers(struct stream_interface *si)$/;"	f	file:
stats_send_http_redirect	./src/dumpstats.c	/^static int stats_send_http_redirect(struct stream_interface *si)$/;"	f	file:
stats_sock_parse_request	./src/dumpstats.c	/^static int stats_sock_parse_request(struct stream_interface *si, char *line)$/;"	f	file:
stats_sock_table_data_request	./src/dumpstats.c	/^static void stats_sock_table_data_request(struct stream_interface *si, char **args, int action)$/;"	f	file:
stats_sock_table_key_request	./src/dumpstats.c	/^static void stats_sock_table_key_request(struct stream_interface *si, char **args, int action)$/;"	f	file:
stats_sock_table_request	./src/dumpstats.c	/^static void stats_sock_table_request(struct stream_interface *si, char **args, int action)$/;"	f	file:
stats_sock_usage_msg	./src/dumpstats.c	/^static const char stats_sock_usage_msg[] =$/;"	v	file:
stats_table_request	./src/dumpstats.c	/^static int stats_table_request(struct stream_interface *si, int action)$/;"	f	file:
stats_tlskeys_list	./src/dumpstats.c	/^static int stats_tlskeys_list(struct stream_interface *si) {$/;"	f	file:
status	./include/types/action.h	/^		} status;$/;"	m	union:act_rule::__anon9	typeref:struct:act_rule::__anon9::__anon15
status	./include/types/applet.h	/^			int status;$/;"	m	struct:appctx::__anon21::__anon32
status	./include/types/checks.h	/^	short status, code;			\/* check result, check code *\/$/;"	m	struct:check
status	./include/types/dns.h	/^	int status;			\/* status of the resolution being processed RSLV_STATUS_* *\/$/;"	m	struct:dns_resolution
status	./include/types/proto_http.h	/^	short status;                   \/* HTTP status from the server, negative if from proxy *\/$/;"	m	struct:http_txn
status	./include/types/server.h	/^	int status;$/;"	m	struct:pid_list
statuscode	./include/types/peers.h	/^	unsigned int statuscode;      \/* current\/last session status code *\/$/;"	m	struct:peer
std_t_frqp	./include/types/stick_table.h	/^	struct freq_ctr_period std_t_frqp;$/;"	m	union:stktable_data	typeref:struct:stktable_data::freq_ctr_period
std_t_sint	./include/types/stick_table.h	/^	int std_t_sint;$/;"	m	union:stktable_data
std_t_uint	./include/types/stick_table.h	/^	unsigned int std_t_uint;$/;"	m	union:stktable_data
std_t_ull	./include/types/stick_table.h	/^	unsigned long long std_t_ull;$/;"	m	union:stktable_data
std_type	./include/types/stick_table.h	/^	int std_type;     \/* standard type we can use for this data, STD_T_* *\/$/;"	m	struct:stktable_data_type
step	./include/types/dns.h	/^	int step;			\/* *\/$/;"	m	struct:dns_resolution
sticking_rule	./include/types/proxy.h	/^struct sticking_rule {$/;"	s
sticking_rules	./include/types/proxy.h	/^	struct list sticking_rules;             \/* content sticking rules (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
stkctr	./include/types/session.h	/^	struct stkctr stkctr[MAX_SESS_STKCTR];  \/* stick counters for tcp-connection *\/$/;"	m	struct:session	typeref:struct:session::stkctr
stkctr	./include/types/stick_table.h	/^struct stkctr {$/;"	s
stkctr	./include/types/stream.h	/^	struct stkctr stkctr[MAX_SESS_STKCTR];  \/* content-aware stick counters *\/$/;"	m	struct:stream	typeref:struct:stream::stkctr
stkctr_clr_flags	./include/proto/stick_table.h	/^static inline void stkctr_clr_flags(struct stkctr *stkctr, unsigned int flags)$/;"	f
stkctr_entry	./include/proto/stick_table.h	/^static inline struct stksess *stkctr_entry(struct stkctr *stkctr)$/;"	f
stkctr_flags	./include/proto/stick_table.h	/^static inline unsigned int stkctr_flags(struct stkctr *stkctr)$/;"	f
stkctr_set_entry	./include/proto/stick_table.h	/^static inline void stkctr_set_entry(struct stkctr *stkctr, struct stksess *entry)$/;"	f
stkctr_set_flags	./include/proto/stick_table.h	/^static inline void stkctr_set_flags(struct stkctr *stkctr, unsigned int flags)$/;"	f
stksess	./include/types/stick_table.h	/^struct stksess {$/;"	s
stksess_free	./src/stick_table.c	/^void stksess_free(struct stktable *t, struct stksess *ts)$/;"	f
stksess_init	./src/stick_table.c	/^static struct stksess *stksess_init(struct stktable *t, struct stksess * ts)$/;"	f	file:
stksess_kill	./src/stick_table.c	/^void stksess_kill(struct stktable *t, struct stksess *ts)$/;"	f
stksess_kill_if_expired	./include/proto/stick_table.h	/^static inline void stksess_kill_if_expired(struct stktable *t, struct stksess *ts)$/;"	f
stksess_new	./src/stick_table.c	/^struct stksess *stksess_new(struct stktable *t, struct stktable_key *key)$/;"	f
stksess_setkey	./src/stick_table.c	/^void stksess_setkey(struct stktable *t, struct stksess *ts, struct stktable_key *key)$/;"	f
stktable	./include/types/stick_table.h	/^struct stktable {$/;"	s
stktable_alloc_data_type	./include/proto/stick_table.h	/^static inline int stktable_alloc_data_type(struct stktable *t, int type, const char *sa)$/;"	f
stktable_compatible_sample	./src/stick_table.c	/^int stktable_compatible_sample(struct sample_expr *expr, unsigned long table_type)$/;"	f
stktable_data	./include/types/stick_table.h	/^union stktable_data {$/;"	u
stktable_data_cast	./include/proto/stick_table.h	/^#define stktable_data_cast(/;"	d
stktable_data_ptr	./include/proto/stick_table.h	/^static inline void *stktable_data_ptr(struct stktable *t, struct stksess *ts, int type)$/;"	f
stktable_data_size	./include/proto/stick_table.h	/^#define stktable_data_size(/;"	d
stktable_data_type	./include/types/stick_table.h	/^struct stktable_data_type {$/;"	s
stktable_data_types	./src/stick_table.c	/^struct stktable_data_type stktable_data_types[STKTABLE_DATA_TYPES] = {$/;"	v	typeref:struct:stktable_data_type
stktable_fetch_key	./src/stick_table.c	/^struct stktable_key *stktable_fetch_key(struct stktable *t, struct proxy *px, struct session *sess, struct stream *strm,$/;"	f
stktable_get_data_type	./src/stick_table.c	/^int stktable_get_data_type(char *name)$/;"	f
stktable_get_entry	./src/stick_table.c	/^struct stksess *stktable_get_entry(struct stktable *table, struct stktable_key *key)$/;"	f
stktable_init	./src/stick_table.c	/^int stktable_init(struct stktable *t)$/;"	f
stktable_key	./include/types/stick_table.h	/^struct stktable_key {$/;"	s
stktable_lookup	./src/stick_table.c	/^struct stksess *stktable_lookup(struct stktable *t, struct stksess *ts)$/;"	f
stktable_lookup_key	./src/stick_table.c	/^struct stksess *stktable_lookup_key(struct stktable *t, struct stktable_key *key)$/;"	f
stktable_parse_type	./src/stick_table.c	/^int stktable_parse_type(char **args, int *myidx, unsigned long *type, size_t *key_size)$/;"	f
stktable_register_data_store	./src/stick_table.c	/^int stktable_register_data_store(int idx, const char *name, int std_type, int arg_type)$/;"	f
stktable_store	./src/stick_table.c	/^struct stksess *stktable_store(struct stktable *t, struct stksess *ts, int local)$/;"	f
stktable_touch	./src/stick_table.c	/^struct stksess *stktable_touch(struct stktable *t, struct stksess *ts, int local)$/;"	f
stktable_trash_expired	./src/stick_table.c	/^static int stktable_trash_expired(struct stktable *t)$/;"	f	file:
stktable_trash_oldest	./src/stick_table.c	/^int stktable_trash_oldest(struct stktable *t, int to_batch)$/;"	f
stktable_type	./include/types/stick_table.h	/^struct stktable_type {$/;"	s
stktable_type_size	./include/proto/stick_table.h	/^static inline int stktable_type_size(int type)$/;"	f
stktable_types	./src/stick_table.c	/^struct stktable_type stktable_types[SMP_TYPES] = {$/;"	v	typeref:struct:stktable_type
stktable_update_key	./src/stick_table.c	/^struct stksess *stktable_update_key(struct stktable *table, struct stktable_key *key)$/;"	f
stop_proxy	./src/proxy.c	/^void stop_proxy(struct proxy *p)$/;"	f
stop_time	./include/types/proxy.h	/^	int stop_time;                          \/* date to stop listening, when stopping != 0 (int ticks) *\/$/;"	m	struct:proxy
stopping	./src/haproxy.c	/^int stopping;	\/* non zero means stopping in progress *\/$/;"	v
store	./include/types/stream.h	/^	} store[8];                     \/* tracked stickiness values to store *\/$/;"	m	struct:stream	typeref:struct:stream::__anon130
store_count	./include/types/stream.h	/^	int store_count;$/;"	m	struct:stream
storersp_rules	./include/types/proxy.h	/^	struct list storersp_rules;             \/* content store response rules (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
str	./include/common/chunk.h	/^	char *str;	\/* beginning of the string itself. Might not be 0-terminated *\/$/;"	m	struct:chunk
str	./include/types/arg.h	/^	struct chunk str;$/;"	m	union:arg_data	typeref:struct:arg_data::chunk
str	./include/types/pattern.h	/^		char *str;              \/* any string  *\/$/;"	m	union:pattern::__anon91
str	./include/types/sample.h	/^	struct chunk    str;   \/* used for char strings or buffers *\/$/;"	m	union:sample_value	typeref:struct:sample_value::chunk
str	./include/types/sample.h	/^	struct chunk str;$/;"	m	struct:meth	typeref:struct:meth::chunk
str2ic	./contrib/halog/halog.c	/^int str2ic(const char *s)$/;"	f
str2ip	./include/common/standard.h	/^static inline struct sockaddr_storage *str2ip(const char *str, struct sockaddr_storage *sa)$/;"	f
str2ip2	./src/standard.c	/^struct sockaddr_storage *str2ip2(const char *str, struct sockaddr_storage *sa, int resolve)$/;"	f
str2listener	./src/cfgparse.c	/^int str2listener(char *str, struct proxy *curproxy, struct bind_conf *bind_conf, const char *file, int line, char **err)$/;"	f
str2mask	./src/standard.c	/^int str2mask(const char *str, struct in_addr *mask)$/;"	f
str2net	./src/standard.c	/^int str2net(const char *str, int resolve, struct in_addr *addr, struct in_addr *mask)$/;"	f
str2sa_range	./src/standard.c	/^struct sockaddr_storage *str2sa_range(const char *str, int *low, int *high, char **err, const char *pfx, char **fqdn, int resolve)$/;"	f
str2ui	./src/standard.c	/^unsigned int str2ui(const char *s)$/;"	f
str2uic	./src/standard.c	/^unsigned int str2uic(const char *s)$/;"	f
str62net	./src/standard.c	/^int str62net(const char *str, struct in6_addr *addr, unsigned char *mask)$/;"	f
stream	./include/types/peers.h	/^	struct stream *stream;        \/* current transport stream *\/$/;"	m	struct:peer	typeref:struct:peer::stream
stream	./include/types/stream.h	/^struct stream {$/;"	s
stream_add_srv_conn	./include/proto/stream.h	/^static void inline stream_add_srv_conn(struct stream *sess, struct server *srv)$/;"	f
stream_alloc_recv_buffer	./src/stream.c	/^int stream_alloc_recv_buffer(struct channel *chn)$/;"	f
stream_alloc_work_buffer	./src/stream.c	/^int stream_alloc_work_buffer(struct stream *s)$/;"	f
stream_del_srv_conn	./include/proto/stream.h	/^static void inline stream_del_srv_conn(struct stream *sess)$/;"	f
stream_free	./src/stream.c	/^static void stream_free(struct stream *s)$/;"	f	file:
stream_http_keywords	./src/stream.c	/^static struct action_kw_list stream_http_keywords = { ILH, {$/;"	v	typeref:struct:action_kw_list	file:
stream_inc_be_http_req_ctr	./include/proto/stream.h	/^static void inline stream_inc_be_http_req_ctr(struct stream *s)$/;"	f
stream_inc_http_err_ctr	./include/proto/stream.h	/^static void inline stream_inc_http_err_ctr(struct stream *s)$/;"	f
stream_inc_http_req_ctr	./include/proto/stream.h	/^static void inline stream_inc_http_req_ctr(struct stream *s)$/;"	f
stream_init_srv_conn	./include/proto/stream.h	/^static void inline stream_init_srv_conn(struct stream *sess)$/;"	f
stream_int_check_timeouts	./src/stream_interface.c	/^int stream_int_check_timeouts(struct stream_interface *si)$/;"	f
stream_int_chk_rcv	./src/stream_interface.c	/^static void stream_int_chk_rcv(struct stream_interface *si)$/;"	f	file:
stream_int_chk_rcv_applet	./src/stream_interface.c	/^static void stream_int_chk_rcv_applet(struct stream_interface *si)$/;"	f	file:
stream_int_chk_rcv_conn	./src/stream_interface.c	/^static void stream_int_chk_rcv_conn(struct stream_interface *si)$/;"	f	file:
stream_int_chk_snd	./src/stream_interface.c	/^static void stream_int_chk_snd(struct stream_interface *si)$/;"	f	file:
stream_int_chk_snd_applet	./src/stream_interface.c	/^static void stream_int_chk_snd_applet(struct stream_interface *si)$/;"	f	file:
stream_int_chk_snd_conn	./src/stream_interface.c	/^static void stream_int_chk_snd_conn(struct stream_interface *si)$/;"	f	file:
stream_int_notify	./src/stream_interface.c	/^void stream_int_notify(struct stream_interface *si)$/;"	f
stream_int_register_handler	./src/stream_interface.c	/^struct appctx *stream_int_register_handler(struct stream_interface *si, struct applet *app)$/;"	f
stream_int_report_error	./src/stream_interface.c	/^void stream_int_report_error(struct stream_interface *si)$/;"	f
stream_int_retnclose	./src/stream_interface.c	/^void stream_int_retnclose(struct stream_interface *si, const struct chunk *msg)$/;"	f
stream_int_shutr	./src/stream_interface.c	/^static void stream_int_shutr(struct stream_interface *si)$/;"	f	file:
stream_int_shutr_applet	./src/stream_interface.c	/^static void stream_int_shutr_applet(struct stream_interface *si)$/;"	f	file:
stream_int_shutr_conn	./src/stream_interface.c	/^static void stream_int_shutr_conn(struct stream_interface *si)$/;"	f	file:
stream_int_shutw	./src/stream_interface.c	/^static void stream_int_shutw(struct stream_interface *si)$/;"	f	file:
stream_int_shutw_applet	./src/stream_interface.c	/^static void stream_int_shutw_applet(struct stream_interface *si)$/;"	f	file:
stream_int_shutw_conn	./src/stream_interface.c	/^static void stream_int_shutw_conn(struct stream_interface *si)$/;"	f	file:
stream_int_update	./src/stream_interface.c	/^void stream_int_update(struct stream_interface *si)$/;"	f
stream_int_update_applet	./src/stream_interface.c	/^void stream_int_update_applet(struct stream_interface *si)$/;"	f
stream_int_update_conn	./src/stream_interface.c	/^void stream_int_update_conn(struct stream_interface *si)$/;"	f
stream_interface	./include/types/stream_interface.h	/^struct stream_interface {$/;"	s
stream_new	./src/stream.c	/^struct stream *stream_new(struct session *sess, struct task *t, enum obj_type *origin)$/;"	f
stream_offer_buffers	./include/proto/stream.h	/^static inline void stream_offer_buffers()$/;"	f
stream_parse_use_service	./src/stream.c	/^static enum act_parse_ret stream_parse_use_service(const char **args, int *cur_arg,$/;"	f	file:
stream_process_counters	./src/stream.c	/^void stream_process_counters(struct stream *s)$/;"	f
stream_release_buffers	./src/stream.c	/^void stream_release_buffers(struct stream *s)$/;"	f
stream_set_backend	./src/proxy.c	/^int stream_set_backend(struct stream *s, struct proxy *be)$/;"	f
stream_shutdown	./src/stream.c	/^void stream_shutdown(struct stream *stream, int why)$/;"	f
stream_sock_read0	./src/stream_interface.c	/^void stream_sock_read0(struct stream_interface *si)$/;"	f
stream_start_counters	./include/proto/stream.h	/^static inline void stream_start_counters(struct stktable *t, struct stksess *ts)$/;"	f
stream_stop_content_counters	./include/proto/stream.h	/^static inline void stream_stop_content_counters(struct stream *s)$/;"	f
stream_store_counters	./include/proto/stream.h	/^static inline void stream_store_counters(struct stream *s)$/;"	f
stream_tcp_keywords	./src/stream.c	/^static struct action_kw_list stream_tcp_keywords = { ILH, {$/;"	v	typeref:struct:action_kw_list	file:
stream_track_stkctr	./include/proto/stream.h	/^static inline void stream_track_stkctr(struct stkctr *ctr, struct stktable *t, struct stksess *ts)$/;"	f
stream_update_time_stats	./src/stream.c	/^void stream_update_time_stats(struct stream *s)$/;"	f
streams	./src/stream.c	/^struct list streams;$/;"	v	typeref:struct:list
strict_sni	./include/types/listener.h	/^	int strict_sni;            \/* refuse negotiation if sni doesn't match a certificate *\/$/;"	m	struct:bind_conf
string	./include/types/checks.h	/^	char *string;                           \/* sent or expected string *\/$/;"	m	struct:tcpcheck_rule
string_equal_bits	./ebtree/ebtree.h	/^static forceinline int string_equal_bits(const unsigned char *a,$/;"	f
string_len	./include/types/checks.h	/^	int string_len;                         \/* string lenght *\/$/;"	m	struct:tcpcheck_rule
strl2ic	./src/standard.c	/^int strl2ic(const char *s, int len)$/;"	f
strl2irc	./src/standard.c	/^int strl2irc(const char *s, int len, int *ret)$/;"	f
strl2llrc	./src/standard.c	/^int strl2llrc(const char *s, int len, long long *ret)$/;"	f
strl2llrc_dotted	./src/standard.c	/^int strl2llrc_dotted(const char *text, int len, long long *ret)$/;"	f
strl2ui	./contrib/halog/halog.c	/^unsigned int strl2ui(const char *s, int len)$/;"	f
strl2ui	./src/standard.c	/^unsigned int strl2ui(const char *s, int len)$/;"	f
strl2uic	./src/standard.c	/^unsigned int strl2uic(const char *s, int len)$/;"	f
strlcpy2	./src/standard.c	/^int strlcpy2(char *dst, const char *src, int size)$/;"	f
strm	./include/types/compression.h	/^	struct slz_stream strm;$/;"	m	struct:comp_ctx	typeref:struct:comp_ctx::slz_stream
strm	./include/types/queue.h	/^	struct stream *strm;		\/* the stream waiting for a connection *\/$/;"	m	struct:pendconn	typeref:struct:pendconn::stream
strm	./include/types/sample.h	/^	struct stream *strm;$/;"	m	struct:sample	typeref:struct:sample::stream
strm_fe	./include/proto/stream.h	/^static inline struct proxy *strm_fe(const struct stream *strm)$/;"	f
strm_li	./include/proto/stream.h	/^static inline struct listener *strm_li(const struct stream *strm)$/;"	f
strm_log	./src/log.c	/^void strm_log(struct stream *s)$/;"	f
strm_logs	./include/types/stream.h	/^struct strm_logs {$/;"	s
strm_orig	./include/proto/stream.h	/^static inline enum obj_type *strm_orig(const struct stream *strm)$/;"	f
strm_sess	./include/proto/stream.h	/^static inline struct session *strm_sess(const struct stream *strm)$/;"	f
strnistr	./src/standard.c	/^const char *strnistr(const char *str1, int len_str1, const char *str2, int len_str2)$/;"	f
sub_tlv	./include/types/connection.h	/^	uint8_t sub_tlv[0];$/;"	m	struct:tlv_ssl
suites	./include/types/acl.h	/^	struct list suites;         \/* list of acl_term_suites *\/$/;"	m	struct:acl_cond	typeref:struct:acl_cond::list
sum	./src/lru.c	/^static unsigned long long sum(unsigned long long x)$/;"	f	file:
sv	./include/types/applet.h	/^			struct server *sv;$/;"	m	struct:appctx::__anon21::__anon22	typeref:struct:appctx::__anon21::__anon22::server
sw	./tests/filltab25.c	/^int nsw, sw;    \/* sum of weights *\/$/;"	v
swap_buffer	./src/haproxy.c	/^char *swap_buffer = NULL;$/;"	v
switch_trees	./tests/filltab25.c	/^void switch_trees() {$/;"	f
switching_rule	./include/types/proxy.h	/^struct switching_rule {$/;"	s
switching_rules	./include/types/proxy.h	/^	struct list switching_rules;            \/* content switching rules (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
swrate_add	./include/proto/freq_ctr.h	/^static inline unsigned int swrate_add(unsigned int *sum, unsigned int n, unsigned int v)$/;"	f
swrate_avg	./include/proto/freq_ctr.h	/^static inline unsigned int swrate_avg(unsigned int sum, unsigned int n)$/;"	f
sync_task	./include/types/peers.h	/^	struct task *sync_task;		 \/* main sync task *\/$/;"	m	struct:peers	typeref:struct:peers::task
sync_task	./include/types/stick_table.h	/^	struct task *sync_task;   \/* sync task *\/$/;"	m	struct:stktable	typeref:struct:stktable::task
syncing	./include/types/stick_table.h	/^	unsigned int syncing;     \/* number of sync tasks watching this table now *\/$/;"	m	struct:stktable
sys	./doc/lua-api/conf.py	/^import sys, os$/;"	i
t	./include/types/connection.h	/^	} t;$/;"	m	struct:connection	typeref:union:connection::__anon50
t	./include/types/dns.h	/^	struct task *t;			\/* timeout management *\/$/;"	m	struct:dns_resolvers	typeref:struct:dns_resolvers::task
t	./include/types/proto_udp.h	/^	} t;$/;"	m	struct:dgram_conn	typeref:union:dgram_conn::__anon102
t	./include/types/proxy.h	/^		struct stktable *t;	        \/* target table *\/$/;"	m	union:sticking_rule::__anon114	typeref:struct:sticking_rule::__anon114::stktable
t	./include/types/server.h	/^	struct task *t;$/;"	m	struct:pid_list	typeref:struct:pid_list::task
t	./include/types/stick_table.h	/^		struct stktable *t;		\/* a pointer to the table *\/$/;"	m	union:track_ctr_prm::__anon129	typeref:struct:track_ctr_prm::__anon129::stktable
t0	./include/types/lb_fwrr.h	/^	struct eb_root t0, t1;  \/* "init" and "next" servers *\/$/;"	m	struct:fwrr_group	typeref:struct:fwrr_group::eb_root
t1	./include/types/lb_fwrr.h	/^	struct eb_root t0, t1;  \/* "init" and "next" servers *\/$/;"	m	struct:fwrr_group	typeref:struct:fwrr_group::
t_close	./include/types/stream.h	/^	unsigned long t_close;          \/* total stream duration *\/$/;"	m	struct:strm_logs
t_connect	./include/types/stream.h	/^	long  t_connect;                \/* delay before the connect() to the server succeeds, -1 if never occurs *\/$/;"	m	struct:strm_logs
t_data	./include/types/stream.h	/^	long  t_data;                   \/* delay before the first data byte from the server ... *\/$/;"	m	struct:strm_logs
t_flags	./include/types/proxy.h	/^	unsigned int t_flags;		\/* transaction flags *\/$/;"	m	struct:error_snapshot
t_queue	./include/types/stream.h	/^	long  t_queue;                  \/* delay before the stream gets out of the connect queue, -1 if never occurs *\/$/;"	m	struct:strm_logs
t_time	./include/types/counters.h	/^	unsigned int q_time, c_time, d_time, t_time; \/* sums of conn_time, queue_time, data_time, total_time *\/$/;"	m	struct:pxcounters
t_time	./include/types/counters.h	/^	unsigned int q_time, c_time, d_time, t_time; \/* sums of conn_time, queue_time, data_time, total_time *\/$/;"	m	struct:srvcounters
table	./include/types/applet.h	/^		} table;$/;"	m	union:appctx::__anon21	typeref:struct:appctx::__anon21::__anon25
table	./include/types/peers.h	/^	struct stktable *table;		    \/* stick table to sync *\/$/;"	m	struct:shared_table	typeref:struct:shared_table::stktable
table	./include/types/proxy.h	/^	struct stktable table;			\/* table for storing sticking streams *\/$/;"	m	struct:proxy	typeref:struct:proxy::stktable
table	./include/types/proxy.h	/^	} table;$/;"	m	struct:sticking_rule	typeref:union:sticking_rule::__anon114
table	./include/types/stick_table.h	/^	struct stktable *table;         \/* table the counters above belong to (undefined if counters are null) *\/$/;"	m	struct:stkctr	typeref:struct:stkctr::stktable
table	./include/types/stick_table.h	/^	} table;$/;"	m	struct:track_ctr_prm	typeref:union:track_ctr_prm::__anon129
table	./include/types/stream.h	/^		struct stktable *table;$/;"	m	struct:stream::__anon130	typeref:struct:stream::__anon130::stktable
tables	./include/types/peers.h	/^	struct shared_table *tables;$/;"	m	struct:peer	typeref:struct:peer::shared_table
tail	./include/types/hdr_idx.h	/^	signed short tail;          \/* last used element, 0..size-1 *\/$/;"	m	struct:hdr_idx
target	./include/types/applet.h	/^			void *target;		\/* session we want to dump, or NULL for all *\/$/;"	m	struct:appctx::__anon21::__anon23
target	./include/types/applet.h	/^			void *target;		\/* table we want to dump, or NULL for all *\/$/;"	m	struct:appctx::__anon21::__anon25
target	./include/types/connection.h	/^	enum obj_type *target;        \/* the target to connect to (server, proxy, applet, ...) *\/$/;"	m	struct:connection	typeref:enum:connection::obj_type
target	./include/types/stream.h	/^	enum obj_type *target;          \/* target to use for this stream *\/$/;"	m	struct:stream	typeref:enum:stream::obj_type
tarpit	./include/types/proxy.h	/^		int tarpit;                     \/* tarpit timeout, defaults to connect if unspecified *\/$/;"	m	struct:proxy::__anon108
task	./include/types/applet.h	/^			struct task *task;$/;"	m	struct:appctx::__anon21::__anon31	typeref:struct:appctx::__anon21::__anon31::task
task	./include/types/applet.h	/^			struct task *task;$/;"	m	struct:appctx::__anon21::__anon32	typeref:struct:appctx::__anon21::__anon32::task
task	./include/types/checks.h	/^	struct task *task;			\/* the task associated to the health check processing, NULL if disabled *\/$/;"	m	struct:check	typeref:struct:check::task
task	./include/types/hlua.h	/^	struct task *task; \/* The task associated with the lua stack execution.$/;"	m	struct:hlua	typeref:struct:hlua::task
task	./include/types/hlua.h	/^	struct task *task; \/* The task to be wake if an event occurs. *\/$/;"	m	struct:hlua_com	typeref:struct:hlua_com::task
task	./include/types/hlua.h	/^	struct task *task; \/* task associated with sleep. *\/$/;"	m	struct:hlua_sleep	typeref:struct:hlua_sleep::task
task	./include/types/proxy.h	/^	struct task *task;			\/* the associated task, mandatory to manage rate limiting, stopping and resource shortage, NULL if disabled *\/$/;"	m	struct:proxy	typeref:struct:proxy::task
task	./include/types/stream.h	/^	struct task *task;              \/* the task associated with this stream *\/$/;"	m	struct:stream	typeref:struct:stream::task
task	./include/types/task.h	/^struct task {$/;"	s
task_delete	./include/proto/task.h	/^static inline struct task *task_delete(struct task *t)$/;"	f
task_free	./include/proto/task.h	/^static inline void task_free(struct task *t)$/;"	f
task_in_rq	./include/proto/task.h	/^static inline int task_in_rq(struct task *t)$/;"	f
task_in_wq	./include/proto/task.h	/^static inline int task_in_wq(struct task *t)$/;"	f
task_init	./include/proto/task.h	/^static inline struct task *task_init(struct task *t)$/;"	f
task_new	./include/proto/task.h	/^static inline struct task *task_new(void)$/;"	f
task_queue	./include/proto/task.h	/^static inline void task_queue(struct task *task)$/;"	f
task_schedule	./include/proto/task.h	/^static inline void task_schedule(struct task *task, int when)$/;"	f
task_unlink_rq	./include/proto/task.h	/^static inline struct task *task_unlink_rq(struct task *t)$/;"	f
task_unlink_wq	./include/proto/task.h	/^static inline struct task *task_unlink_wq(struct task *t)$/;"	f
task_wakeup	./include/proto/task.h	/^static inline struct task *task_wakeup(struct task *t, unsigned int f)$/;"	f
tc	./include/types/dns.h	/^	unsigned char	tc :1;		\/* truncation 0:no, 1: yes *\/$/;"	m	struct:dns_header
tcp_bind_listener	./src/proto_tcp.c	/^int tcp_bind_listener(struct listener *listener, char *errmsg, int errlen)$/;"	f
tcp_bind_listeners	./src/proto_tcp.c	/^static int tcp_bind_listeners(struct protocol *proto, char *errmsg, int errlen)$/;"	f	file:
tcp_bind_socket	./src/proto_tcp.c	/^int tcp_bind_socket(int fd, int flags, struct sockaddr_storage *local, struct sockaddr_storage *remote)$/;"	f
tcp_conn_kws	./src/stick_table.c	/^static struct action_kw_list tcp_conn_kws = { { }, {$/;"	v	typeref:struct:action_kw_list	file:
tcp_connect_probe	./src/proto_tcp.c	/^int tcp_connect_probe(struct connection *conn)$/;"	f
tcp_connect_server	./src/proto_tcp.c	/^int tcp_connect_server(struct connection *conn, int data, int delack)$/;"	f
tcp_drain	./src/proto_tcp.c	/^int tcp_drain(int fd)$/;"	f
tcp_exec_action_silent_drop	./src/proto_tcp.c	/^static enum act_return tcp_exec_action_silent_drop(struct act_rule *rule, struct proxy *px, struct session *sess, struct stream *strm, int flags)$/;"	f	file:
tcp_exec_req_rules	./src/proto_tcp.c	/^int tcp_exec_req_rules(struct session *sess)$/;"	f
tcp_get_dst	./src/proto_tcp.c	/^int tcp_get_dst(int fd, struct sockaddr *sa, socklen_t salen, int dir)$/;"	f
tcp_get_src	./src/proto_tcp.c	/^int tcp_get_src(int fd, struct sockaddr *sa, socklen_t salen, int dir)$/;"	f
tcp_inspect_request	./src/proto_tcp.c	/^int tcp_inspect_request(struct stream *s, struct channel *req, int an_bit)$/;"	f
tcp_inspect_response	./src/proto_tcp.c	/^int tcp_inspect_response(struct stream *s, struct channel *rep, int an_bit)$/;"	f
tcp_parse_request_rule	./src/proto_tcp.c	/^static int tcp_parse_request_rule(char **args, int arg, int section_type,$/;"	f	file:
tcp_parse_response_rule	./src/proto_tcp.c	/^static int tcp_parse_response_rule(char **args, int arg, int section_type,$/;"	f	file:
tcp_parse_silent_drop	./src/proto_tcp.c	/^static enum act_parse_ret tcp_parse_silent_drop(const char **args, int *orig_arg, struct proxy *px,$/;"	f	file:
tcp_parse_tcp_rep	./src/proto_tcp.c	/^static int tcp_parse_tcp_rep(char **args, int section_type, struct proxy *curpx,$/;"	f	file:
tcp_parse_tcp_req	./src/proto_tcp.c	/^static int tcp_parse_tcp_req(char **args, int section_type, struct proxy *curpx,$/;"	f	file:
tcp_pause_listener	./src/proto_tcp.c	/^int tcp_pause_listener(struct listener *l)$/;"	f
tcp_persist_rdp_cookie	./src/backend.c	/^int tcp_persist_rdp_cookie(struct stream *s, struct channel *req, int an_bit)$/;"	f
tcp_rep	./include/types/proxy.h	/^	} tcp_rep;$/;"	m	struct:proxy	typeref:struct:proxy::__anon107
tcp_req	./include/types/proxy.h	/^	} tcp_req;$/;"	m	struct:proxy	typeref:struct:proxy::__anon106
tcp_req_conn_action	./src/proto_tcp.c	/^static struct action_kw *tcp_req_conn_action(const char *kw)$/;"	f	file:
tcp_req_conn_actions	./src/proto_tcp.c	/^static struct action_kw_list tcp_req_conn_actions = {ILH, {$/;"	v	typeref:struct:action_kw_list	file:
tcp_req_conn_keywords	./src/proto_tcp.c	/^struct list tcp_req_conn_keywords = LIST_HEAD_INIT(tcp_req_conn_keywords);$/;"	v	typeref:struct:list
tcp_req_conn_keywords_register	./src/proto_tcp.c	/^void tcp_req_conn_keywords_register(struct action_kw_list *kw_list)$/;"	f
tcp_req_cont_action	./src/proto_tcp.c	/^static struct action_kw *tcp_req_cont_action(const char *kw)$/;"	f	file:
tcp_req_cont_actions	./src/proto_tcp.c	/^static struct action_kw_list tcp_req_cont_actions = {ILH, {$/;"	v	typeref:struct:action_kw_list	file:
tcp_req_cont_keywords	./src/proto_tcp.c	/^struct list tcp_req_cont_keywords = LIST_HEAD_INIT(tcp_req_cont_keywords);$/;"	v	typeref:struct:list
tcp_req_cont_keywords_register	./src/proto_tcp.c	/^void tcp_req_cont_keywords_register(struct action_kw_list *kw_list)$/;"	f
tcp_req_kws	./src/stick_table.c	/^static struct action_kw_list tcp_req_kws = { { }, {$/;"	v	typeref:struct:action_kw_list	file:
tcp_req_kws	./src/vars.c	/^static struct action_kw_list tcp_req_kws = { { }, {$/;"	v	typeref:struct:action_kw_list	file:
tcp_res_cont_action	./src/proto_tcp.c	/^static struct action_kw *tcp_res_cont_action(const char *kw)$/;"	f	file:
tcp_res_cont_actions	./src/proto_tcp.c	/^static struct action_kw_list tcp_res_cont_actions = {ILH, {$/;"	v	typeref:struct:action_kw_list	file:
tcp_res_cont_keywords	./src/proto_tcp.c	/^struct list tcp_res_cont_keywords = LIST_HEAD_INIT(tcp_res_cont_keywords);$/;"	v	typeref:struct:list
tcp_res_cont_keywords_register	./src/proto_tcp.c	/^void tcp_res_cont_keywords_register(struct action_kw_list *kw_list)$/;"	f
tcp_res_kws	./src/stick_table.c	/^static struct action_kw_list tcp_res_kws = { { }, {$/;"	v	typeref:struct:action_kw_list	file:
tcp_res_kws	./src/vars.c	/^static struct action_kw_list tcp_res_kws = { { }, {$/;"	v	typeref:struct:action_kw_list	file:
tcp_trk_idx	./include/proto/proto_tcp.h	/^static inline int tcp_trk_idx(int trk_action)$/;"	f
tcp_ut	./include/types/listener.h	/^	int tcp_ut;                     \/* for TCP, user timeout *\/$/;"	m	struct:listener
tcp_ut	./include/types/server.h	/^	int tcp_ut;                             \/* for TCP, user timeout *\/$/;"	m	struct:server
tcpcheck_get_step_comment	./src/checks.c	/^static char * tcpcheck_get_step_comment(struct check *check, int stepid)$/;"	f	file:
tcpcheck_get_step_id	./src/checks.c	/^static int tcpcheck_get_step_id(struct check *check)$/;"	f	file:
tcpcheck_main	./src/checks.c	/^static void tcpcheck_main(struct connection *conn)$/;"	f	file:
tcpcheck_rule	./include/types/checks.h	/^struct tcpcheck_rule {$/;"	s
tcpcheck_rules	./include/types/checks.h	/^	struct list *tcpcheck_rules;		\/* tcp-check send \/ expect rules *\/$/;"	m	struct:check	typeref:struct:check::list
tcpcheck_rules	./include/types/proxy.h	/^	struct list tcpcheck_rules;		\/* tcp-check send \/ expect rules *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
tcpcheck_rules	./include/types/proxy.h	/^	struct list tcpcheck_rules;$/;"	m	struct:email_alert	typeref:struct:email_alert::list
tcpv4_add_listener	./src/proto_tcp.c	/^void tcpv4_add_listener(struct listener *listener)$/;"	f
tcpv6_add_listener	./src/proto_tcp.c	/^void tcpv6_add_listener(struct listener *listener)$/;"	f
teaching_origin	./include/types/peers.h	/^	unsigned int teaching_origin;$/;"	m	struct:shared_table
tell_old_pids	./src/haproxy.c	/^static int tell_old_pids(int sig)$/;"	f	file:
temp_smp	./src/sample.c	/^static struct sample temp_smp;$/;"	v	typeref:struct:sample	file:
templates_path	./doc/lua-api/conf.py	/^templates_path = ['_templates']$/;"	v
term	./include/types/fd.h	/^	void REGPRM1   (*term)(struct poller *p);            \/* termination of this poller *\/$/;"	m	struct:poller
terms	./include/types/acl.h	/^	struct list terms;          \/* list of acl_terms *\/$/;"	m	struct:acl_term_suite	typeref:struct:acl_term_suite::list
test	./include/types/fd.h	/^	int  REGPRM1   (*test)(struct poller *p);            \/* pre-init check of the poller *\/$/;"	m	struct:poller
test_speed1	./tests/test_pools.c	/^static bool test_speed1(void)$/;"	f	file:
texinfo_documents	./doc/lua-api/conf.py	/^texinfo_documents = [$/;"	v
text	./src/proto_http.c	/^	const char text[8];$/;"	m	struct:http_method_desc	file:
tick_add	./include/common/ticks.h	/^static inline int tick_add(int now, int timeout)$/;"	f
tick_add_ifset	./include/common/ticks.h	/^static inline int tick_add_ifset(int now, int timeout)$/;"	f
tick_first	./include/common/ticks.h	/^static inline int tick_first(int t1, int t2)$/;"	f
tick_first_2nz	./include/common/ticks.h	/^static inline int tick_first_2nz(int t1, int t2)$/;"	f
tick_is_expired	./include/common/ticks.h	/^static inline int tick_is_expired(int timer, int now)$/;"	f
tick_is_le	./include/common/ticks.h	/^static inline int tick_is_le(int t1, int t2)$/;"	f
tick_is_lt	./include/common/ticks.h	/^static inline int tick_is_lt(int t1, int t2)$/;"	f
tick_isset	./include/common/ticks.h	/^static inline int tick_isset(int expire)$/;"	f
tick_remain	./include/common/ticks.h	/^static inline int tick_remain(int now, int exp)$/;"	f
time	./include/types/pattern.h	/^		struct pat_time time;           \/* valid hours and days *\/$/;"	m	union:pattern::__anon87	typeref:struct:pattern::__anon87::pat_time
timeout	./include/types/applet.h	/^	unsigned int timeout;              \/* execution timeout. *\/$/;"	m	struct:applet
timeout	./include/types/dns.h	/^		long int timeout;	\/* - queries which reached timeout *\/$/;"	m	struct:dns_nameserver::__anon65
timeout	./include/types/dns.h	/^	} timeout;$/;"	m	struct:dns_resolvers	typeref:struct:dns_resolvers::__anon62
timeout	./include/types/proxy.h	/^	} timeout;$/;"	m	struct:proxy	typeref:struct:proxy::__anon108
timer	./contrib/halog/halog.c	/^struct timer {$/;"	s	file:
timers	./contrib/halog/halog.c	/^static struct eb_root timers[5] = {$/;"	v	typeref:struct:eb_root	file:
timers	./src/task.c	/^static struct eb_root timers;      \/* sorted timers tree *\/$/;"	v	typeref:struct:eb_root	file:
timeval_current	./tests/test_hashes.c	/^static struct timeval timeval_current(void)$/;"	f	file:
timeval_current	./tests/test_pools.c	/^static struct timeval timeval_current(void)$/;"	f	file:
timeval_elapsed	./tests/test_hashes.c	/^static double timeval_elapsed(struct timeval *tv)$/;"	f	file:
timeval_elapsed	./tests/test_pools.c	/^static double timeval_elapsed(struct timeval *tv)$/;"	f	file:
tls_keys_ref	./include/types/ssl_sock.h	/^struct tls_keys_ref {$/;"	s
tls_sess_key	./include/types/ssl_sock.h	/^struct tls_sess_key {$/;"	s
tls_ticket_enc_index	./include/types/ssl_sock.h	/^	int tls_ticket_enc_index;$/;"	m	struct:tls_keys_ref
tlskeys	./include/types/applet.h	/^		} tlskeys;$/;"	m	union:appctx::__anon21	typeref:struct:appctx::__anon21::__anon29
tlskeys	./include/types/ssl_sock.h	/^	struct tls_sess_key *tlskeys;$/;"	m	struct:tls_keys_ref	typeref:struct:tls_keys_ref::tls_sess_key
tlskeys_finalize_config	./src/ssl_sock.c	/^void tlskeys_finalize_config(void)$/;"	f
tlskeys_list_get_next	./src/dumpstats.c	/^struct tls_keys_ref *tlskeys_list_get_next(struct tls_keys_ref *getnext, struct list *end)$/;"	f	file:
tlskeys_ref_lookup	./src/ssl_sock.c	/^struct tls_keys_ref *tlskeys_ref_lookup(const char *filename)$/;"	f
tlskeys_ref_lookup_ref	./src/dumpstats.c	/^struct tls_keys_ref *tlskeys_ref_lookup_ref(const char *reference)$/;"	f	file:
tlskeys_ref_lookupid	./src/ssl_sock.c	/^struct tls_keys_ref *tlskeys_ref_lookupid(int unique_id)$/;"	f
tlskeys_reference	./src/ssl_sock.c	/^struct list tlskeys_reference = LIST_HEAD_INIT(tlskeys_reference);$/;"	v	typeref:struct:list
tlv	./include/types/connection.h	/^	struct tlv tlv;$/;"	m	struct:tlv_ssl	typeref:struct:tlv_ssl::tlv
tlv	./include/types/connection.h	/^struct tlv {$/;"	s
tlv_ssl	./include/types/connection.h	/^struct tlv_ssl {$/;"	s
tmp_evts	./src/ev_select.c	/^static fd_set *tmp_evts[2];$/;"	v	file:
to	./include/types/connection.h	/^		struct sockaddr_storage to;	\/* address reached by the client, or address to connect to *\/$/;"	m	struct:connection::__anon52	typeref:struct:connection::__anon52::sockaddr_storage
to	./include/types/proto_udp.h	/^		struct sockaddr_storage to;	\/* address reached by the client, or address to connect to *\/$/;"	m	struct:dgram_conn::__anon104	typeref:struct:dgram_conn::__anon104::sockaddr_storage
to	./include/types/proxy.h	/^		char *to;			\/* Address(es) to send email alerts to *\/$/;"	m	struct:proxy::__anon110
to_forward	./include/types/channel.h	/^	unsigned int to_forward;        \/* number of bytes to forward after out without a wake-up *\/$/;"	m	struct:channel
to_log	./include/types/proxy.h	/^	int to_log;				\/* things to be logged (LW_*) *\/$/;"	m	struct:proxy
too_big	./include/types/dns.h	/^		long int too_big;	\/* - too big response *\/$/;"	m	struct:dns_nameserver::__anon65
torture_assert	./tests/test_pools.c	/^#define torture_assert(/;"	d	file:
torture_assert_str_equal	./tests/test_pools.c	/^#define torture_assert_str_equal(/;"	d	file:
tos	./include/types/action.h	/^		int tos;                       \/* tos value for ACT_HTTP_SET_TOS *\/$/;"	m	union:act_rule::__anon9
tot_used	./include/types/backend.h	/^	int tot_used;			\/* total number of servers used for LB *\/$/;"	m	struct:lbprm
tot_wact	./include/types/backend.h	/^	int tot_wact, tot_wbck;		\/* total effective weights of active and backup servers *\/$/;"	m	struct:lbprm
tot_wbck	./include/types/backend.h	/^	int tot_wact, tot_wbck;		\/* total effective weights of active and backup servers *\/$/;"	m	struct:lbprm
tot_weight	./include/types/backend.h	/^	int tot_weight;			\/* total effective weight of servers participating to LB *\/$/;"	m	struct:lbprm
total	./include/types/channel.h	/^	unsigned long long total;       \/* total data read *\/$/;"	m	struct:channel
total_bytes_sent	./contrib/halog/halog.c	/^	unsigned long long total_bytes_sent; \/* sum(all bytes sent) *\/$/;"	m	struct:url_stat	file:
total_len	./src/xxhash.c	/^    U64 total_len;$/;"	m	struct:__anon148	file:
total_len	./src/xxhash.c	/^    U64 total_len;$/;"	m	struct:__anon149	file:
total_time	./contrib/halog/halog.c	/^	unsigned long long total_time;    \/* sum(all reqs' times) *\/$/;"	m	struct:url_stat	file:
total_time_ok	./contrib/halog/halog.c	/^	unsigned long long total_time_ok; \/* sum(all OK reqs' times) *\/$/;"	m	struct:url_stat	file:
totalconn	./src/fd.c	/^int totalconn;                  \/* total # of terminated sessions *\/$/;"	v
totalsslconns	./src/ssl_sock.c	/^int totalsslconns = 0;$/;"	v
totpend	./include/types/proxy.h	/^	int totpend;				\/* total number of pending connections on this instance (for stats) *\/$/;"	m	struct:proxy
tproxy_addr	./include/types/connection.h	/^	struct sockaddr_storage tproxy_addr; \/* non-local address we want to bind to for connect() *\/$/;"	m	struct:conn_src	typeref:struct:conn_src::sockaddr_storage
trace_now	./src/trace.c	/^static struct timeval trace_now;$/;"	v	typeref:struct:timeval	file:
track	./include/types/server.h	/^	struct server *track;                   \/* the server we're currently tracking, if any *\/$/;"	m	struct:server	typeref:struct:server::server
track_ctr_prm	./include/types/stick_table.h	/^struct track_ctr_prm {$/;"	s
trackers	./include/types/server.h	/^	struct server *trackers;                \/* the list of servers tracking us, if any *\/$/;"	m	struct:server	typeref:struct:server::server
trackit	./include/types/server.h	/^	char *trackit;				\/* temporary variable to make assignment deferrable *\/$/;"	m	struct:server
tracknext	./include/types/server.h	/^	struct server *tracknext;               \/* next server tracking <track> in <track>'s trackers list *\/$/;"	m	struct:server	typeref:struct:server::server
trash	./src/haproxy.c	/^struct chunk trash = { };$/;"	v	typeref:struct:chunk
trash_buf1	./src/chunk.c	/^static char *trash_buf1;$/;"	v	file:
trash_buf2	./src/chunk.c	/^static char *trash_buf2;$/;"	v	file:
trash_chunk	./src/chunk.c	/^static struct chunk *trash_chunk;$/;"	v	typeref:struct:chunk	file:
trash_chunk1	./src/chunk.c	/^static struct chunk trash_chunk1;$/;"	v	typeref:struct:chunk	file:
trash_chunk2	./src/chunk.c	/^static struct chunk trash_chunk2;$/;"	v	typeref:struct:chunk	file:
trash_size	./src/chunk.c	/^static int trash_size;$/;"	v	file:
tree	./include/types/pattern.h	/^		struct eb_root *tree;           \/* tree storing all values if any *\/$/;"	m	union:pattern::__anon87	typeref:struct:pattern::__anon87::eb_root
tree	./tests/filltab25.c	/^	struct eb_root *tree; \/\/ we want to know where the server is$/;"	m	struct:srv	typeref:struct:srv::eb_root	file:
tree_0	./tests/filltab25.c	/^struct eb_root tree_0 = EB_ROOT;$/;"	v	typeref:struct:eb_root
tree_1	./tests/filltab25.c	/^struct eb_root tree_1 = EB_ROOT;$/;"	v	typeref:struct:eb_root
tree_2	./tests/filltab25.c	/^struct eb_root tree_2 = EB_ROOT;$/;"	v	typeref:struct:eb_root
tree_occ	./include/types/server.h	/^struct tree_occ {$/;"	s
trigger_resolution	./src/checks.c	/^int trigger_resolution(struct server *s)$/;"	f
trk_ctr	./include/types/action.h	/^		struct track_ctr_prm trk_ctr;$/;"	m	union:act_rule::__anon9	typeref:struct:act_rule::__anon9::track_ctr_prm
truncated	./include/types/dns.h	/^		long int truncated;	\/* - truncated response *\/$/;"	m	struct:dns_nameserver::__anon65
truncated_line	./contrib/halog/halog.c	/^void truncated_line(int linenum, const char *line)$/;"	f
try_cname	./include/types/dns.h	/^	int try_cname;			\/* number of CNAME requests sent *\/$/;"	m	struct:dns_resolution
ts	./include/types/stream.h	/^		struct stksess *ts;$/;"	m	struct:stream::__anon130	typeref:struct:stream::__anon130::stksess
tune	./include/types/global.h	/^	} tune;$/;"	m	struct:global	typeref:struct:global::__anon72
tunnel	./include/types/proxy.h	/^		int tunnel;                     \/* I\/O timeout to use in tunnel mode (in ticks) *\/$/;"	m	struct:proxy::__anon108
tv_accept	./include/types/session.h	/^	struct timeval tv_accept;       \/* date of the session's accept() in internal date (monotonic) *\/$/;"	m	struct:session	typeref:struct:session::timeval
tv_accept	./include/types/stream.h	/^	struct timeval tv_accept;       \/* date of the stream's accept() in internal date (monotonic) *\/$/;"	m	struct:strm_logs	typeref:struct:strm_logs::timeval
tv_add	./include/common/time.h	/^#define tv_add /;"	d
tv_add_ifset	./include/common/time.h	/^#define tv_add_ifset /;"	d
tv_bound	./include/common/time.h	/^#define tv_bound(/;"	d
tv_eternity	./include/common/time.h	/^REGPRM1 static inline struct timeval *tv_eternity(struct timeval *tv)$/;"	f
tv_isbefore	./include/common/time.h	/^#define tv_isbefore(/;"	d
tv_iseq	./include/common/time.h	/^#define tv_iseq /;"	d
tv_iseternity	./include/common/time.h	/^#define tv_iseternity(/;"	d
tv_isge	./include/common/time.h	/^#define tv_isge /;"	d
tv_isgt	./include/common/time.h	/^#define tv_isgt /;"	d
tv_isle	./include/common/time.h	/^#define tv_isle /;"	d
tv_islt	./include/common/time.h	/^#define tv_islt /;"	d
tv_isset	./include/common/time.h	/^#define tv_isset(/;"	d
tv_iszero	./include/common/time.h	/^#define tv_iszero(/;"	d
tv_min	./include/common/time.h	/^#define tv_min(/;"	d
tv_ms_add	./include/common/time.h	/^#define tv_ms_add /;"	d
tv_ms_cmp	./include/common/time.h	/^#define tv_ms_cmp /;"	d
tv_ms_cmp2	./include/common/time.h	/^#define tv_ms_cmp2 /;"	d
tv_ms_elapsed	./include/common/time.h	/^#define tv_ms_elapsed /;"	d
tv_ms_le2	./include/common/time.h	/^#define tv_ms_le2 /;"	d
tv_ms_remain	./include/common/time.h	/^#define tv_ms_remain /;"	d
tv_ms_remain2	./include/common/time.h	/^#define tv_ms_remain2 /;"	d
tv_now	./include/common/time.h	/^REGPRM1 static inline struct timeval *tv_now(struct timeval *tv)$/;"	f
tv_remain	./include/common/time.h	/^#define tv_remain /;"	d
tv_remain2	./include/common/time.h	/^#define tv_remain2 /;"	d
tv_request	./include/types/stream.h	/^	struct timeval tv_request;      \/* date the request arrives, {0,0} if never occurs *\/$/;"	m	struct:strm_logs	typeref:struct:strm_logs::timeval
tv_update_date	./src/time.c	/^REGPRM2 void tv_update_date(int max_wait, int interrupted)$/;"	f
tv_zero	./include/common/time.h	/^REGPRM1 static inline struct timeval *tv_zero(struct timeval *tv) {$/;"	f
tws	./include/types/proto_http.h	/^	int  tws;  \/* added to vlen if some trailing white spaces are present *\/$/;"	m	struct:hdr_ctx
txn	./include/types/stream.h	/^	struct http_txn *txn;           \/* current HTTP transaction being processed. Should become a list. *\/$/;"	m	struct:stream	typeref:struct:stream::http_txn
type	./include/types/applet.h	/^			int iid, type, sid;	\/* proxy id, type and service id if bounding of stats is enabled *\/$/;"	m	struct:appctx::__anon21::__anon22
type	./include/types/arg.h	/^	unsigned char type;       \/* argument type, ARGT_* *\/$/;"	m	struct:arg
type	./include/types/checks.h	/^	int type;				\/* Check type, one of PR_O2_*_CHK *\/$/;"	m	struct:check
type	./include/types/connection.h	/^	uint8_t type;$/;"	m	struct:tlv
type	./include/types/log.h	/^	int type;      \/\/ LOG_FMT_*$/;"	m	struct:logformat_node
type	./include/types/pattern.h	/^	int type;                               \/* type of the ACL pattern (SMP_T_*) *\/$/;"	m	struct:pattern
type	./include/types/proxy.h	/^	int type;$/;"	m	struct:persist_rule
type	./include/types/proxy.h	/^	int type;$/;"	m	struct:redirect_rule
type	./include/types/sample.h	/^	int type;                 \/* SMP_T_* *\/$/;"	m	struct:sample_data
type	./include/types/stick_table.h	/^	unsigned long type;       \/* type of table (determines key format) *\/$/;"	m	struct:stktable
type	./src/log.c	/^	int type;$/;"	m	struct:logformat_type	file:
type_flags	./include/types/arg.h	/^	unsigned char type_flags; \/* type-specific extra flags (eg: case sensitivity for regex), ARGF_* *\/$/;"	m	struct:arg
types	./include/types/compression.h	/^	struct comp_type *types;$/;"	m	struct:comp	typeref:struct:comp::comp_type
u	./include/types/auth.h	/^	} u;$/;"	m	struct:auth_users	typeref:union:auth_users::__anon37
u	./include/types/proto_http.h	/^			int u, u_l;            \/* URI, length *\/$/;"	m	struct:http_msg::__anon99::__anon100
u	./include/types/sample.h	/^	union sample_value u;     \/* sample data *\/$/;"	m	struct:sample_data	typeref:union:sample_data::sample_value
u	./include/types/stick_table.h	/^		unsigned int u;$/;"	m	union:stktable::__anon128
u32	./ebtree/eb32tree.h	/^typedef unsigned int u32;$/;"	t
u32	./include/common/epoll.h	/^		uint32_t u32;$/;"	m	union:epoll_event::__anon2
u64	./ebtree/eb64tree.h	/^typedef unsigned long long u64;$/;"	t
u64	./include/common/epoll.h	/^		uint64_t u64;$/;"	m	union:epoll_event::__anon2
u_int32_t	./tests/uri_hash.c	/^typedef unsigned int u_int32_t;$/;"	t	file:
u_l	./include/types/proto_http.h	/^			int u, u_l;            \/* URI, length *\/$/;"	m	struct:http_msg::__anon99::__anon100
ua_name	./include/types/compression.h	/^	char *ua_name;  \/* name for the user-agent *\/$/;"	m	struct:comp_algo
ua_name_len	./include/types/compression.h	/^	int ua_name_len;$/;"	m	struct:comp_algo
ub1	./tests/test_hashes.c	/^typedef  unsigned       char ub1;   \/* unsigned 1-byte quantities *\/$/;"	t	file:
ub4	./tests/test_hashes.c	/^typedef  unsigned long  int  ub4;   \/* unsigned 4-byte quantities *\/$/;"	t	file:
uid	./include/types/applet.h	/^			unsigned int uid;	\/* if non-null, the uniq_id of the session being dumped *\/$/;"	m	struct:appctx::__anon21::__anon23
uid	./include/types/global.h	/^			uid_t uid;      \/* -1 to leave unchanged *\/$/;"	m	struct:global::__anon73::__anon74
uid	./include/types/global.h	/^	int uid;$/;"	m	struct:global
uid	./include/types/listener.h	/^		uid_t uid;         \/* -1 to leave unchanged *\/$/;"	m	struct:bind_conf::__anon77
uif_file	./include/types/proxy.h	/^		char *uif_file;                 \/* file name where the unique-id-format string appears (strdup) *\/$/;"	m	struct:proxy::__anon109
uif_line	./include/types/proxy.h	/^		int   uif_line;                 \/* file name where the unique-id-format string appears *\/$/;"	m	struct:proxy::__anon109
ulltoa	./src/standard.c	/^char *ulltoa(unsigned long long n, char *dst, size_t size)$/;"	f
ulltoh_r	./src/standard.c	/^const char *ulltoh_r(unsigned long long n, char *buffer, int size)$/;"	f
ultoa	./include/common/standard.h	/^static inline const char *ultoa(unsigned long n)$/;"	f
ultoa_o	./src/standard.c	/^char *ultoa_o(unsigned long n, char *dst, size_t size)$/;"	f
ultoa_r	./src/standard.c	/^char *ultoa_r(unsigned long n, char *buffer, int size)$/;"	f
ultoad2	./src/trace.c	/^static char *ultoad2(unsigned int x, char *out, int min_pairs)$/;"	f	file:
unbind_all	./include/types/protocol.h	/^	int (*unbind_all)(struct protocol *proto);	\/* unbind all bound listeners *\/$/;"	m	struct:protocol
unbind_all_listeners	./src/listener.c	/^int unbind_all_listeners(struct protocol *proto)$/;"	f
unbind_listener	./src/listener.c	/^int unbind_listener(struct listener *listener)$/;"	f
unblock_sigchld	./src/checks.c	/^void unblock_sigchld(void)$/;"	f
uniq_id	./include/types/stream.h	/^	unsigned int uniq_id;           \/* unique ID used for the traces *\/$/;"	m	struct:stream
unique_id	./include/types/pattern.h	/^	int unique_id; \/* Each pattern reference have unique id. *\/$/;"	m	struct:pat_ref
unique_id	./include/types/ssl_sock.h	/^	int unique_id; \/* Each pattern reference have unique id. *\/$/;"	m	struct:tls_keys_ref
unique_id	./include/types/stream.h	/^	char *unique_id;                        \/* custom unique ID *\/$/;"	m	struct:stream
uniqueid_format_string	./include/types/proxy.h	/^		char *uniqueid_format_string;	\/* unique-id format string *\/$/;"	m	struct:proxy::__anon109
unix_bind	./include/types/global.h	/^	} unix_bind;$/;"	m	struct:global	typeref:struct:global::__anon73
unlikely	./include/common/compiler.h	/^#define unlikely(/;"	d
unresolved	./include/types/arg.h	/^	unsigned char unresolved; \/* argument contains a string in <str> that must be resolved and freed *\/$/;"	m	struct:arg
unx	./include/types/connection.h	/^		} unx;$/;"	m	union:proxy_hdr_v2::__anon53	typeref:struct:proxy_hdr_v2::__anon53::__anon56
upd	./include/types/stick_table.h	/^	struct eb32_node upd;     \/* ebtree node used to hold the update sequence tree *\/$/;"	m	struct:stksess	typeref:struct:stksess::eb32_node
upd	./src/shctx.c	/^	struct shsess_packet_hdr upd;$/;"	m	struct:shared_context	typeref:struct:shared_context::shsess_packet_hdr	file:
update	./include/types/dns.h	/^		long int update;	\/* - valid response used to update server's IP *\/$/;"	m	struct:dns_nameserver::__anon65
update	./include/types/peers.h	/^	unsigned int update;$/;"	m	struct:shared_table
update	./include/types/stick_table.h	/^	unsigned int update;$/;"	m	struct:stktable
update	./include/types/stream_interface.h	/^	void (*update)(struct stream_interface *);  \/* I\/O update function *\/$/;"	m	struct:si_ops
update_applet	./src/hlua.c	/^static struct applet update_applet = {$/;"	v	typeref:struct:applet	file:
update_backend_weight	./src/backend.c	/^void update_backend_weight(struct proxy *px)$/;"	f
update_freq_ctr	./include/proto/freq_ctr.h	/^static inline void update_freq_ctr(struct freq_ctr *ctr, unsigned int inc)$/;"	f
update_freq_ctr_period	./include/proto/freq_ctr.h	/^static inline void update_freq_ctr_period(struct freq_ctr_period *ctr,$/;"	f
update_log_hdr	./src/log.c	/^static char *update_log_hdr(const time_t time)$/;"	f	file:
update_log_hdr_rfc5424	./src/log.c	/^static char *update_log_hdr_rfc5424(const time_t time)$/;"	f	file:
update_position	./tests/filltab25.c	/^void update_position(struct srv *s) {$/;"	f
update_server_addr	./src/server.c	/^int update_server_addr(struct server *s, void *ip, int ip_sin_family, char *updater)$/;"	f
update_server_eweight	./include/types/backend.h	/^	void (*update_server_eweight)(struct server *);  \/* to be called after eweight change *\/$/;"	m	struct:lbprm
updated	./include/types/fd.h	/^	unsigned char updated:1;             \/* 1 if this fd is already in the update list *\/$/;"	m	struct:fdtab
updates	./include/types/stick_table.h	/^	struct eb_root updates;   \/* head of sticky updates sequence tree *\/$/;"	m	struct:stktable	typeref:struct:stktable::eb_root
updt_fd_polling	./include/proto/fd.h	/^static inline void updt_fd_polling(const int fd)$/;"	f
uri	./include/types/proto_http.h	/^	char *uri;                      \/* first line if log needed, NULL otherwise *\/$/;"	m	struct:http_txn
uri_add_auth	./src/uri_auth.c	/^struct uri_auth *uri_add_auth(struct uri_auth **root, char *user, char *default_uri)$/;"	f
uri_add_scope	./src/uri_auth.c	/^struct uri_auth *uri_add_scope(struct uri_auth **root, char *scope, char *default_uri)$/;"	f
uri_auth	./include/common/uri_auth.h	/^struct uri_auth {$/;"	s
uri_auth	./include/types/proxy.h	/^	struct uri_auth *uri_auth;		\/* if non-NULL, the (list of) per-URI authentications *\/$/;"	m	struct:proxy	typeref:struct:proxy::uri_auth
uri_dirs_depth1	./include/types/proxy.h	/^	int  uri_dirs_depth1;			\/* directories+1 (slashes) limit for uri balancing algorithm *\/$/;"	m	struct:proxy
uri_len	./include/common/uri_auth.h	/^	int uri_len;			\/* the prefix length *\/$/;"	m	struct:uri_auth
uri_len_limit	./include/types/proxy.h	/^	int  uri_len_limit;			\/* character limit for uri balancing algorithm *\/$/;"	m	struct:proxy
uri_prefix	./include/common/uri_auth.h	/^	char *uri_prefix;		\/* the prefix we want to match *\/$/;"	m	struct:uri_auth
uri_scope	./include/common/uri_auth.h	/^struct uri_scope {$/;"	s
uri_set_desc	./src/uri_auth.c	/^struct uri_auth *uri_set_desc(struct uri_auth **root, char *desc, char *default_uri)$/;"	f
uri_set_flag	./src/uri_auth.c	/^struct uri_auth *uri_set_flag(struct uri_auth **root, char *default_uri, int flag)$/;"	f
uri_set_node	./src/uri_auth.c	/^struct uri_auth *uri_set_node(struct uri_auth **root, char *name, char *default_uri)$/;"	f
uri_whole	./include/types/proxy.h	/^	int  uri_whole;				\/* if != 0, calculates the hash from the whole uri. Still honors the len_limit and dirs_depth1 *\/$/;"	m	struct:proxy
url	./contrib/halog/halog.c	/^		struct ebpt_node url;$/;"	m	union:url_stat::__anon1	typeref:struct:url_stat::__anon1::ebpt_node	file:
url	./contrib/halog/halog.c	/^	char *url;$/;"	m	struct:url_stat	file:
url2ipv4	./src/standard.c	/^int url2ipv4(const char *addr, struct in_addr *dst)$/;"	f
url2sa	./src/standard.c	/^int url2sa(const char *url, int ulen, struct sockaddr_storage *addr, struct split_url *out)$/;"	f
url_decode	./src/standard.c	/^int url_decode(char *string)$/;"	f
url_encode_map	./src/proto_http.c	/^fd_set url_encode_map[(sizeof(fd_set) > (256\/8)) ? 1 : ((256\/8) \/ sizeof(fd_set))];$/;"	v
url_param_len	./include/types/proxy.h	/^	int  url_param_len;			\/* strlen(url_param_name), computed only once *\/$/;"	m	struct:proxy
url_param_name	./include/types/proxy.h	/^	char *url_param_name;			\/* name of the URL parameter used for hashing *\/$/;"	m	struct:proxy
url_stat	./contrib/halog/halog.c	/^struct url_stat {$/;"	s	file:
usage	./contrib/halog/halog.c	/^void usage(FILE *output, const char *msg)$/;"	f
usage	./contrib/ip6range/ip6range.c	/^static void usage(const char *argv0)$/;"	f	file:
usage	./contrib/iprange/iprange.c	/^static void usage(const char *argv0)$/;"	f	file:
usage	./src/haproxy.c	/^void usage(char *name)$/;"	f
use	./include/types/acl.h	/^	unsigned int use;           \/* or'ed bit mask of all acl_expr's SMP_USE_* *\/$/;"	m	struct:acl
use	./include/types/acl.h	/^	unsigned int use;           \/* or'ed bit mask of all suites's SMP_USE_* *\/$/;"	m	struct:acl_cond
use	./include/types/sample.h	/^	unsigned int use;                         \/* fetch source (SMP_USE_*) *\/$/;"	m	struct:sample_fetch
use_shared_mem	./src/shctx.c	/^static int use_shared_mem = 0;$/;"	v	file:
use_ssl	./include/types/checks.h	/^	int use_ssl;				\/* use SSL for health checks *\/$/;"	m	struct:check
use_ssl	./include/types/server.h	/^	int use_ssl;				\/* ssl enabled *\/$/;"	m	struct:server
use_tsc	./src/trace.c	/^static int use_tsc;$/;"	v	file:
used	./include/common/memory.h	/^	unsigned int used;	\/* how many chunks are currently in use *\/$/;"	m	struct:pool_head
used	./include/types/hdr_idx.h	/^	short used;                 \/* # of elements really used (1..size) *\/$/;"	m	struct:hdr_idx
used_listener_id	./include/types/proxy.h	/^		struct eb_root used_listener_id;\/* list of listener IDs in use *\/$/;"	m	struct:proxy::__anon109	typeref:struct:proxy::__anon109::eb_root
used_proxy_id	./src/proxy.c	/^struct eb_root used_proxy_id = EB_ROOT;	\/* list of proxy IDs in use *\/$/;"	v	typeref:struct:eb_root
used_server_id	./include/types/proxy.h	/^		struct eb_root used_server_id;	\/* list of server IDs in use *\/$/;"	m	struct:proxy::__anon109	typeref:struct:proxy::__anon109::eb_root
user	./include/types/auth.h	/^	char *user, *pass;$/;"	m	struct:auth_users
user	./include/types/proto_http.h	/^	char *user, *pass;                    \/* extracted username & password *\/$/;"	m	struct:http_auth_data
useragentid	./include/types/global.h	/^		da_evidence_id_t useragentid;$/;"	m	struct:global::__anon75
userlist	./include/common/uri_auth.h	/^	struct userlist *userlist;	\/* private userlist to emulate legacy "stats auth user:password" *\/$/;"	m	struct:uri_auth	typeref:struct:uri_auth::userlist
userlist	./include/types/auth.h	/^struct userlist {$/;"	s
userlist	./src/auth.c	/^struct userlist *userlist = NULL;    \/* list of all existing userlists *\/$/;"	v	typeref:struct:userlist
userlist_free	./src/auth.c	/^userlist_free(struct userlist *ul)$/;"	f
userlist_postinit	./src/auth.c	/^int userlist_postinit()$/;"	f
users	./include/common/memory.h	/^	unsigned int users;	\/* number of pools sharing this zone *\/$/;"	m	struct:pool_head
users	./include/common/mini-clist.h	/^	struct list users;$/;"	m	struct:bref	typeref:struct:bref::list
users	./include/types/auth.h	/^	struct auth_users *users;$/;"	m	struct:userlist	typeref:struct:userlist::auth_users
users	./include/types/mailers.h	/^	int users;			\/* number of users of this mailers section *\/$/;"	m	struct:mailers
usr	./include/types/arg.h	/^	struct userlist *usr;$/;"	m	union:arg_data	typeref:struct:arg_data::userlist
utf8_next	./src/standard.c	/^unsigned char utf8_next(const char *s, int len, unsigned int *c)$/;"	f
utf8_return_code	./include/common/standard.h	/^static inline unsigned char utf8_return_code(unsigned int code)$/;"	f
utf8_return_length	./include/common/standard.h	/^static inline unsigned char utf8_return_length(unsigned char code)$/;"	f
utoa_pad	./src/standard.c	/^char *utoa_pad(unsigned int n, char *dst, size_t size)$/;"	f
uuid	./include/types/proxy.h	/^	int uuid;				\/* universally unique proxy ID, used for SNMP *\/$/;"	m	struct:proxy
uweight	./include/types/server.h	/^	unsigned iweight,uweight, eweight;	\/* initial weight, user-specified weight, and effective weight *\/$/;"	m	struct:server
ux	./include/types/global.h	/^		} ux;$/;"	m	struct:global::__anon73	typeref:struct:global::__anon73::__anon74
ux	./include/types/listener.h	/^	} ux;$/;"	m	struct:bind_conf	typeref:struct:bind_conf::__anon77
uxst_add_listener	./src/proto_uxst.c	/^void uxst_add_listener(struct listener *listener)$/;"	f
uxst_bind_listener	./src/proto_uxst.c	/^static int uxst_bind_listener(struct listener *listener, char *errmsg, int errlen)$/;"	f	file:
uxst_bind_listeners	./src/proto_uxst.c	/^static int uxst_bind_listeners(struct protocol *proto, char *errmsg, int errlen)$/;"	f	file:
uxst_connect_server	./src/proto_uxst.c	/^int uxst_connect_server(struct connection *conn, int data, int delack)$/;"	f
uxst_get_dst	./src/proto_uxst.c	/^int uxst_get_dst(int fd, struct sockaddr *sa, socklen_t salen, int dir)$/;"	f
uxst_get_src	./src/proto_uxst.c	/^int uxst_get_src(int fd, struct sockaddr *sa, socklen_t salen, int dir)$/;"	f
uxst_pause_listener	./src/proto_uxst.c	/^int uxst_pause_listener(struct listener *l)$/;"	f
uxst_unbind_listener	./src/proto_uxst.c	/^static int uxst_unbind_listener(struct listener *listener)$/;"	f	file:
uxst_unbind_listeners	./src/proto_uxst.c	/^static int uxst_unbind_listeners(struct protocol *proto)$/;"	f	file:
v	./include/types/hdr_idx.h	/^	struct hdr_idx_elem *v;     \/* the array itself *\/$/;"	m	struct:hdr_idx	typeref:struct:hdr_idx::hdr_idx_elem
v	./include/types/proto_http.h	/^			int v, v_l;            \/* VERSION, length *\/$/;"	m	struct:http_msg::__anon99::__anon100
v	./src/xxhash.c	/^    U32 v;$/;"	m	struct:_U32_S	file:
v	./src/xxhash.c	/^    U64 v;$/;"	m	struct:_U64_S	file:
v1	./src/xxhash.c	/^    U32 v1;$/;"	m	struct:__anon148	file:
v1	./src/xxhash.c	/^    U64 v1;$/;"	m	struct:__anon149	file:
v2	./src/xxhash.c	/^    U32 v2;$/;"	m	struct:__anon148	file:
v2	./src/xxhash.c	/^    U64 v2;$/;"	m	struct:__anon149	file:
v3	./src/xxhash.c	/^    U32 v3;$/;"	m	struct:__anon148	file:
v3	./src/xxhash.c	/^    U64 v3;$/;"	m	struct:__anon149	file:
v4	./src/xxhash.c	/^    U32 v4;$/;"	m	struct:__anon148	file:
v4	./src/xxhash.c	/^    U64 v4;$/;"	m	struct:__anon149	file:
v4tov6	./src/standard.c	/^void v4tov6(struct in6_addr *sin6_addr, struct in_addr *sin_addr)$/;"	f
v6tov4	./src/standard.c	/^int v6tov4(struct in_addr *sin_addr, struct in6_addr *sin6_addr)$/;"	f
v_l	./include/types/proto_http.h	/^			int v, v_l;            \/* VERSION, length *\/$/;"	m	struct:http_msg::__anon99::__anon100
v_l	./include/types/proto_http.h	/^			int v_l;               \/* VERSION length (version starts at buf->p) *\/$/;"	m	struct:http_msg::__anon99::__anon101
val	./contrib/halog/halog.c	/^		struct eb64_node val;$/;"	m	union:url_stat::__anon1	typeref:struct:url_stat::__anon1::eb64_node	file:
val	./include/types/acl.h	/^	unsigned int val;           \/* or'ed bit mask of all acl_expr's SMP_VAL_* *\/$/;"	m	struct:acl
val	./include/types/acl.h	/^	unsigned int val;           \/* or'ed bit mask of all suites's SMP_VAL_* *\/$/;"	m	struct:acl_cond
val	./include/types/pattern.h	/^	} val;                                  \/* direct value *\/$/;"	m	struct:pattern	typeref:union:pattern::__anon87
val	./include/types/proto_http.h	/^	int  val;  \/* relative to line, may skip some leading white spaces *\/$/;"	m	struct:hdr_ctx
val	./include/types/sample.h	/^	unsigned int val;                         \/* fetch validity (SMP_VAL_*) *\/$/;"	m	struct:sample_fetch
val	./src/cfgparse.c	/^	unsigned int val;$/;"	m	struct:cfg_opt	file:
val_args	./include/types/sample.h	/^	int (*val_args)(struct arg *arg_p,$/;"	m	struct:sample_conv
val_args	./include/types/sample.h	/^	int (*val_args)(struct arg *arg_p,$/;"	m	struct:sample_fetch
val_hdr	./src/proto_http.c	/^int val_hdr(struct arg *arg, char **err_msg)$/;"	f
val_payload_lv	./src/payload.c	/^int val_payload_lv(struct arg *arg, char **err_msg)$/;"	f
valid	./include/types/dns.h	/^		int valid;		\/*   a response is valid *\/$/;"	m	struct:dns_resolvers::__anon63
valid	./include/types/dns.h	/^		long int valid;		\/* - valid response *\/$/;"	m	struct:dns_nameserver::__anon65
value	./include/types/action.h	/^			long long int value;$/;"	m	struct:act_rule::__anon9::__anon19
value	./include/types/action.h	/^			struct list value;     \/* pattern to retrieve MAP value *\/$/;"	m	struct:act_rule::__anon9::__anon12	typeref:struct:act_rule::__anon9::__anon12::list
value	./include/types/applet.h	/^			long long value;	\/* value to compare against *\/$/;"	m	struct:appctx::__anon21::__anon25
value	./include/types/connection.h	/^	uint8_t value[0];$/;"	m	struct:tlv
var	./include/types/arg.h	/^	struct var_desc var;$/;"	m	union:arg_data	typeref:struct:arg_data::var_desc
var	./include/types/vars.h	/^struct var {$/;"	s
var_accounting_add	./src/vars.c	/^static int var_accounting_add(struct vars *vars, struct vars *per_sess, struct vars *per_strm, struct vars *per_chn, int size)$/;"	f	file:
var_accounting_diff	./src/vars.c	/^static void var_accounting_diff(struct vars *vars, struct vars *per_sess, struct vars *per_strm, struct vars *per_chn, int size)$/;"	f	file:
var_args_list	./src/log.c	/^struct logformat_var_args var_args_list[] = {$/;"	v	typeref:struct:logformat_var_args
var_desc	./include/types/vars.h	/^struct var_desc {$/;"	s
var_get	./src/vars.c	/^static inline struct var *var_get(struct vars *vars, const char *name)$/;"	f	file:
var_global_limit	./src/vars.c	/^static unsigned int var_global_limit = 0;$/;"	v	file:
var_global_size	./src/vars.c	/^static unsigned int var_global_size = 0;$/;"	v	file:
var_names	./src/vars.c	/^static char **var_names = NULL;$/;"	v	file:
var_names_nb	./src/vars.c	/^static int var_names_nb = 0;$/;"	v	file:
var_pool	./src/vars.c	/^static struct pool_head *var_pool = NULL;$/;"	v	typeref:struct:pool_head	file:
var_reqres_limit	./src/vars.c	/^static unsigned int var_reqres_limit = 0;$/;"	v	file:
var_sess_limit	./src/vars.c	/^static unsigned int var_sess_limit = 0;$/;"	v	file:
var_txn_limit	./src/vars.c	/^static unsigned int var_txn_limit = 0;$/;"	v	file:
vars	./include/types/action.h	/^		} vars;$/;"	m	union:act_rule::__anon9	typeref:struct:act_rule::__anon9::__anon17
vars	./include/types/session.h	/^	struct vars vars;               \/* list of variables for the session scope. *\/$/;"	m	struct:session	typeref:struct:session::vars
vars	./include/types/vars.h	/^struct vars {$/;"	s
vars_check_arg	./src/vars.c	/^int vars_check_arg(struct arg *arg, char **err)$/;"	f
vars_get_by_desc	./src/vars.c	/^int vars_get_by_desc(const struct var_desc *var_desc, struct stream *strm, struct sample *smp)$/;"	f
vars_get_by_name	./src/vars.c	/^int vars_get_by_name(const char *name, size_t len, struct stream *strm, struct sample *smp)$/;"	f
vars_init	./src/vars.c	/^void vars_init(struct vars *vars, enum vars_scope scope)$/;"	f
vars_max_size	./src/vars.c	/^static int vars_max_size(char **args, int section_type, struct proxy *curpx,$/;"	f	file:
vars_max_size_global	./src/vars.c	/^static int vars_max_size_global(char **args, int section_type, struct proxy *curpx,$/;"	f	file:
vars_max_size_reqres	./src/vars.c	/^static int vars_max_size_reqres(char **args, int section_type, struct proxy *curpx,$/;"	f	file:
vars_max_size_sess	./src/vars.c	/^static int vars_max_size_sess(char **args, int section_type, struct proxy *curpx,$/;"	f	file:
vars_max_size_txn	./src/vars.c	/^static int vars_max_size_txn(char **args, int section_type, struct proxy *curpx,$/;"	f	file:
vars_prune	./src/vars.c	/^void vars_prune(struct vars *vars, struct stream *strm)$/;"	f
vars_prune_per_sess	./src/vars.c	/^void vars_prune_per_sess(struct vars *vars)$/;"	f
vars_reqres	./include/types/stream.h	/^	struct vars vars_reqres;                \/* list of variables for the request and resp scope. *\/$/;"	m	struct:stream	typeref:struct:stream::vars
vars_scope	./include/types/vars.h	/^enum vars_scope {$/;"	g
vars_set_by_name	./src/vars.c	/^void vars_set_by_name(const char *name, size_t len, struct stream *strm, struct sample *smp)$/;"	f
vars_txn	./include/types/stream.h	/^	struct vars vars_txn;                   \/* list of variables for the txn scope. *\/$/;"	m	struct:stream	typeref:struct:stream::vars
ver_cmd	./include/types/connection.h	/^	uint8_t ver_cmd;   \/* protocol version and command *\/$/;"	m	struct:proxy_hdr_v2
verify	./include/types/connection.h	/^	uint32_t verify;$/;"	m	struct:tlv_ssl
verify	./include/types/listener.h	/^	int verify;                \/* verify method (set of SSL_VERIFY_* flags) *\/$/;"	m	struct:bind_conf
verify	./include/types/server.h	/^		int verify;			\/* verify method (set of SSL_VERIFY_* flags) *\/$/;"	m	struct:server::__anon122
verify_host	./include/types/server.h	/^		char *verify_host;              \/* hostname of certificate must match this host *\/$/;"	m	struct:server::__anon122
version	./doc/lua-api/conf.py	/^version = '1.0'$/;"	v
version	./src/shctx.c	/^	unsigned char version;$/;"	m	struct:shsess_packet	file:
vlen	./include/types/proto_http.h	/^	int  vlen; \/* relative to line+val, stops before trailing white spaces *\/$/;"	m	struct:hdr_ctx
vmaxlen	./include/types/checks.h	/^	int vmaxlen;	\/* value maximum length, used to determine the required memory allocation *\/$/;"	m	struct:extcheck_env
vsyscall	./src/i386-linux-vsys.c	/^static void *vsyscall = &int80;  \/* initialize vsyscall to use int80 by default *\/$/;"	v	file:
w	./tests/filltab25.c	/^	int w; \/* weight *\/$/;"	m	struct:srv	file:
wait_queue	./include/types/listener.h	/^	struct list wait_queue;		\/* link element to make the listener wait for something (LI_LIMITED)  *\/$/;"	m	struct:listener	typeref:struct:listener::list
wake	./include/types/connection.h	/^	int  (*wake)(struct connection *conn);  \/* data-layer callback to report activity *\/$/;"	m	struct:data_cb
wake_expired_tasks	./src/task.c	/^int wake_expired_tasks()$/;"	f
wake_me	./include/types/hlua.h	/^	struct list wake_me; \/* Part of list of signals to be targeted if an$/;"	m	struct:hlua_com	typeref:struct:hlua_com::list
wake_on_read	./include/types/applet.h	/^			struct list wake_on_read;$/;"	m	struct:appctx::__anon21::__anon30	typeref:struct:appctx::__anon21::__anon30::list
wake_on_write	./include/types/applet.h	/^			struct list wake_on_write;$/;"	m	struct:appctx::__anon21::__anon30	typeref:struct:appctx::__anon21::__anon30::list
wake_srv_chk	./src/checks.c	/^static int wake_srv_chk(struct connection *conn)$/;"	f	file:
wake_time	./include/types/hlua.h	/^	int wake_time; \/* The lua wants to be waked at this time, or before. *\/$/;"	m	struct:hlua
wakeup_ms	./include/types/hlua.h	/^	unsigned int wakeup_ms; \/* hour to wakeup. *\/$/;"	m	struct:hlua_sleep
warmup	./include/types/server.h	/^	struct task *warmup;                    \/* the task dedicated to the warmup when slowstart is set *\/$/;"	m	struct:server	typeref:struct:server::task
warned	./src/haproxy.c	/^unsigned int warned = 0;$/;"	v
warnif_cond_conflicts	./src/cfgparse.c	/^static int warnif_cond_conflicts(const struct acl_cond *cond, unsigned int where, const char *file, int line)$/;"	f	file:
warnif_misplaced_block	./src/cfgparse.c	/^int warnif_misplaced_block(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_misplaced_http_req	./src/cfgparse.c	/^int warnif_misplaced_http_req(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_misplaced_redirect	./src/cfgparse.c	/^int warnif_misplaced_redirect(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_misplaced_reqadd	./src/cfgparse.c	/^int warnif_misplaced_reqadd(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_misplaced_reqxxx	./src/cfgparse.c	/^int warnif_misplaced_reqxxx(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_misplaced_tcp_conn	./src/cfgparse.c	/^int warnif_misplaced_tcp_conn(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_misplaced_tcp_cont	./src/cfgparse.c	/^int warnif_misplaced_tcp_cont(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_rule_after_block	./src/cfgparse.c	/^int warnif_rule_after_block(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_rule_after_http_req	./src/cfgparse.c	/^int warnif_rule_after_http_req(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_rule_after_redirect	./src/cfgparse.c	/^int warnif_rule_after_redirect(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_rule_after_reqadd	./src/cfgparse.c	/^int warnif_rule_after_reqadd(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_rule_after_reqxxx	./src/cfgparse.c	/^int warnif_rule_after_reqxxx(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_rule_after_tcp_cont	./src/cfgparse.c	/^int warnif_rule_after_tcp_cont(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_rule_after_use_backend	./src/cfgparse.c	/^int warnif_rule_after_use_backend(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_rule_after_use_server	./src/cfgparse.c	/^int warnif_rule_after_use_server(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnifnotcap	./include/common/cfgparse.h	/^static inline int warnifnotcap(struct proxy *proxy, int cap, const char *file, int line, const char *arg, const char *hint)$/;"	f
wdiv	./include/types/backend.h	/^	int wdiv;			\/* ratio between effective weight and user weight *\/$/;"	m	struct:lbprm
wex	./include/types/channel.h	/^	int wex;                        \/* expiration date for a write or connect, in ticks *\/$/;"	m	struct:channel
when	./include/types/proxy.h	/^	struct timeval when;		\/* date of this event, (tv_sec == 0) means "never" *\/$/;"	m	struct:error_snapshot	typeref:struct:error_snapshot::timeval
wmult	./include/types/backend.h	/^	int wmult;			\/* ratio between user weight and effective weight *\/$/;"	m	struct:lbprm
word_match	./src/standard.c	/^int word_match(const char *sample, int slen, const char *word, int wlen)$/;"	f
wordlist	./include/common/mini-clist.h	/^struct wordlist {$/;"	s
wq	./include/types/task.h	/^	struct eb32_node wq;		\/* ebtree node used to hold the task in the wait queue *\/$/;"	m	struct:task	typeref:struct:task::eb32_node
wrapper_argc	./src/haproxy-systemd-wrapper.c	/^static int wrapper_argc;$/;"	v	file:
wrapper_argv	./src/haproxy-systemd-wrapper.c	/^static char **wrapper_argv;$/;"	v	file:
wscore	./include/types/server.h	/^	unsigned wscore;			\/* weight score, used during srv map computation *\/$/;"	m	struct:server
wt_hash	./tests/test_hashes.c	/^unsigned wt_hash ( void *key, int len )$/;"	f
wto	./include/types/channel.h	/^	int wto;                        \/* write timeout, in ticks *\/$/;"	m	struct:channel
x509v3_ext_names	./src/ssl_sock.c	/^static char *x509v3_ext_names[X509V3_EXT_SIZE] = {$/;"	v	file:
x509v3_ext_values	./src/ssl_sock.c	/^static char *x509v3_ext_values[X509V3_EXT_SIZE] = {$/;"	v	file:
xchg	./src/shctx.c	/^static inline unsigned int xchg(unsigned int *ptr, unsigned int x)$/;"	f	file:
xfer_large	./include/types/channel.h	/^	unsigned char xfer_large;       \/* number of consecutive large xfers *\/$/;"	m	struct:channel
xfer_small	./include/types/channel.h	/^	unsigned char xfer_small;       \/* number of consecutive small xfers *\/$/;"	m	struct:channel
xprt	./include/types/checks.h	/^	struct xprt_ops *xprt;			\/* transport layer operations for health checks *\/$/;"	m	struct:check	typeref:struct:check::xprt_ops
xprt	./include/types/connection.h	/^	const struct xprt_ops *xprt;  \/* operations at the transport layer *\/$/;"	m	struct:connection	typeref:struct:connection::xprt_ops
xprt	./include/types/listener.h	/^	struct xprt_ops *xprt;          \/* transport-layer operations for this socket *\/$/;"	m	struct:listener	typeref:struct:listener::xprt_ops
xprt	./include/types/mailers.h	/^	struct xprt_ops *xprt;		\/* SMTP server socket operations at transport layer *\/$/;"	m	struct:mailer	typeref:struct:mailer::xprt_ops
xprt	./include/types/peers.h	/^	struct xprt_ops *xprt;         \/* peer socket operations at transport layer *\/$/;"	m	struct:peer	typeref:struct:peer::xprt_ops
xprt	./include/types/server.h	/^	struct xprt_ops *xprt;                  \/* transport-layer operations *\/$/;"	m	struct:server	typeref:struct:server::xprt_ops
xprt_ctx	./include/types/connection.h	/^	void *xprt_ctx;               \/* general purpose pointer, initialized to NULL *\/$/;"	m	struct:connection
xprt_ops	./include/types/connection.h	/^struct xprt_ops {$/;"	s
xprt_st	./include/types/connection.h	/^	int xprt_st;                  \/* transport layer state, initialized to zero *\/$/;"	m	struct:connection
z	./include/types/dns.h	/^	unsigned char	z :1;		\/* no used *\/$/;"	m	struct:dns_header
zero	./src/haproxy.c	/^const int zero = 0;$/;"	v
zlib_pool_deflate_state	./src/compression.c	/^static struct pool_head *zlib_pool_deflate_state = NULL;$/;"	v	typeref:struct:pool_head	file:
zlib_pool_head	./src/compression.c	/^static struct pool_head *zlib_pool_head = NULL;$/;"	v	typeref:struct:pool_head	file:
zlib_pool_pending_buf	./src/compression.c	/^static struct pool_head *zlib_pool_pending_buf = NULL;$/;"	v	typeref:struct:pool_head	file:
zlib_pool_prev	./src/compression.c	/^static struct pool_head *zlib_pool_prev = NULL;$/;"	v	typeref:struct:pool_head	file:
zlib_pool_window	./src/compression.c	/^static struct pool_head *zlib_pool_window = NULL;$/;"	v	typeref:struct:pool_head	file:
zlib_used_memory	./src/compression.c	/^long zlib_used_memory = 0;$/;"	v
zlibmemlevel	./include/types/global.h	/^		int zlibmemlevel;    \/* zlib memlevel *\/$/;"	m	struct:global::__anon72
zlibwindowsize	./include/types/global.h	/^		int zlibwindowsize;  \/* zlib window size *\/$/;"	m	struct:global::__anon72
